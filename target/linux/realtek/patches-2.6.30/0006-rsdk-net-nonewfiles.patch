--- linux-2.6.30.9/net/bridge/br.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br.c	2013-05-02 01:47:59.217226614 +0300
@@ -22,15 +22,1605 @@
 
 #include "br_private.h"
 
+#include <linux/proc_fs.h>
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+#include <net/rtl/features/lan_restrict.h>
+
+#endif
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+extern int __init br_filter_init(void);
+extern void __exit br_filter_exit(void);
+#endif
+
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+#include <linux/inetdevice.h>
+#define NIPQUAD_HTTP(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+struct proc_dir_entry *http_file_server_root=NULL;
+struct proc_dir_entry *http_file_server_root_res1=NULL;
+extern unsigned int _lan_ip;
+extern unsigned int _lan_mask;
+void get_lan_ip_mask(void)
+{
+	struct in_device *in_dev;	
+	struct net_device *landev;
+	struct in_ifaddr *ifap = NULL;
+	
+      	if ((landev = __dev_get_by_name(&init_net, "br0")) != NULL){
+		in_dev=(struct in_device *)(landev->ip_ptr);
+		if (in_dev != NULL) {
+			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+				if (strcmp("br0", ifap->ifa_label) == 0){
+					_lan_ip = ifap->ifa_address;
+					_lan_mask = ifap->ifa_mask;
+					return; 
+				}
+			}
+		}
+	}	
+}
+static int getLanIp_read(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+
+      int len=0;
+
+      len = sprintf(page, "Lan IP=%u.%u.%u.%u\n", NIPQUAD_HTTP(_lan_ip));
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+   	
+      return len;
+
+}
+static int getLanIp_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char tmpbuf[80];
+
+      if (count < 2)
+	    return -EFAULT;
+	    
+	if (buffer && !copy_from_user(tmpbuf, buffer, 80))  {
+		get_lan_ip_mask();
+		return count;
+	}	
+      return -EFAULT;
+}
+int __init http_file_init(void)
+{
+#if defined(CONFIG_PROC_FS)
+
+	struct proc_dir_entry *devices = NULL,*pvc = NULL,*svc = NULL;
+	http_file_server_root = proc_mkdir("http_file",NULL);
+	if (!http_file_server_root){
+		printk("create folder fail\n");
+		return -ENOMEM;
+	}
+	http_file_server_root_res1 = create_proc_entry("getLanIp", 0, http_file_server_root);
+	if (http_file_server_root_res1) {
+		http_file_server_root_res1->write_proc = getLanIp_write;
+		http_file_server_root_res1->read_proc = getLanIp_read;
+	}
+#endif
+	return 0;
+}
+
+void __exit http_file_exit(void)
+{
+#if defined(CONFIG_PROC_FS)
+	if (http_file_server_root_res1) {
+		remove_proc_entry("getLanIp", http_file_server_root);
+		http_file_server_root_res1 = NULL;
+	}
+	remove_proc_entry("http_file",NULL);
+#endif 
+}
+
+#endif
+
+
+
+
+
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/inetdevice.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_multicast.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+int IGMPProxyOpened = 0;
+
 int (*br_should_route_hook)(struct sk_buff *skb);
 
-static const struct stp_proto br_stp_proto = {
-	.rcv	= br_stp_rcv,
-};
+static const struct stp_proto br_stp_proto = {
+	.rcv	= br_stp_rcv,
+};
+
+static struct pernet_operations br_net_ops = {
+	.exit	= br_net_exit,
+};
+
+//it's for host-slave hostapd EAP hack  amd inband hostip hack
+#if defined (CONFIG_RTL_EAP_RELAY) || defined (CONFIG_RTK_INBAND_HOST_HACK)
+struct proc_dir_entry *procHostMac=NULL;
+unsigned char inband_Hostmac[6]={0x00,0xE0,0x4C,0x81,0x96,0xC1}; 
+
+static int br_hostmac_read_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%x:%x:%x:%x:%x:%x\n", inband_Hostmac[0],inband_Hostmac[1]
+	  										, inband_Hostmac[2],inband_Hostmac[3]
+	  										, inband_Hostmac[4],inband_Hostmac[5]);
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_hostmac_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char br_tmp[48]; 
+       int mac[6];		  
+	
+      if (count < 2) 
+	    return -EFAULT;
+
+	
+      if (buffer && !copy_from_user(&br_tmp, buffer, 48)) {
+	  	int num=0;	
+		int i=0;
+             num = sscanf(br_tmp, "%d:%d:%d:%d:%d:%d",&mac[0],&mac[1]
+	  										, &mac[2],&mac[3]
+	  										, &mac[4],&mac[5]);
+            
+		for(i=0;i<6;i++)
+			inband_Hostmac[i] = (unsigned char)(mac[i] & 0x000000ff);	  	 
+            
+                if (num !=  6) {
+                        printk("br_hostmac_write_proc invalid vlan parameter!\n");
+                }
+	    return count;
+      }
+      return -EFAULT;
+}
+#endif
+
+#if defined (CONFIG_RTK_INBAND_HOST_HACK)
+struct proc_dir_entry *procHostIp=NULL;
+unsigned int inband_HostIP=0xC0A801FE;
+int br_hackMac_enable=0; //only wps will need hack now!!!
+extern void init_listen_endpoint(); //from br_input.c
+static int br_hostip_read_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%d %d.%d.%d.%d\n", br_hackMac_enable,(unsigned char)((inband_HostIP>>24)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>16)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>8)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>0)&0x000000ff)
+								  	);
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+
+      return len;
+
+}
+
+static int br_hostip_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char br_tmp[48]; 
+       unsigned int tmp_ip[4];		  
+	
+      if (count < 2) 
+	    return -EFAULT;
+
+	
+      if (buffer && !copy_from_user(&br_tmp, buffer, 48)) {
+	  	int num=0;	
+             num = sscanf(br_tmp, "%d %d.%d.%d.%d",&br_hackMac_enable,&tmp_ip[0],&tmp_ip[1]
+	  										, &tmp_ip[2],&tmp_ip[3]);
+            inband_HostIP =  ((tmp_ip[0] << 24) & 0xff000000) |
+						((tmp_ip[1] << 16) & 0x00ff0000) |
+						((tmp_ip[2] << 8) & 0x0000ff00) |
+						((tmp_ip[3] << 0) & 0x000000ff) ;
+							
+  		  		init_listen_endpoint();	//in br_input.c	            
+                if (num !=  5) {
+                        printk("br_hostip_write_proc invalid vlan parameter!\n");
+                }
+
+	    return count;
+      }
+      return -EFAULT;
+}
+#endif
+
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+int rtl_wlan_block_relay_enable=0;
+struct proc_dir_entry *procwlanblockrelay=NULL;
+static int br_wlanblockread_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "wlanblock:%c\n\n",rtl_wlan_block_relay_enable+'0');
+	if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+}
+static int br_wlanblockwrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char block_tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&block_tmp, buffer, 1)) {
+		rtl_wlan_block_relay_enable = block_tmp - '0';
+		if(rtl_wlan_block_relay_enable)
+		{
+			rtl_wlan_block_relay_enable=1;
+		}
+		else
+			rtl_wlan_block_relay_enable=0;	
+	    	return count;
+      }
+	return -EFAULT;
+}
+#endif
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+struct proc_dir_entry *procIgmpSnoop=NULL;
+int igmpsnoopenabled=0;	// Should be 0(default), set 1 when igmpproxy up!
+extern struct net_bridge *bridge0;
+static int br_igmpSnoopRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+      int i,j,k;
+   
+    len = sprintf(page, "igmpsnoopenabled:%c\n\n", igmpsnoopenabled + '0');
+    len += sprintf(page+len, "bridge multicast fdb:\n");
+
+
+	for (i = 0; i < BR_HASH_SIZE; i++) {
+		struct net_bridge_fdb_entry *f;
+		struct hlist_node *h, *n;
+		
+		j=0;
+		hlist_for_each_entry_safe(f, h, n, &bridge0->hash[i], hlist) {
+			if(MULTICAST_MAC(f->addr.addr) )
+			{
+				  len += sprintf(page+len,"[%d][%d]mCastMac:0x%x:%x:%x:%x:%x:%x,use_count is %d,ageing_timer is %lu\n",
+					i,j,f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5],f->use_count,(jiffies<f->ageing_timer) ?0:(jiffies-f->ageing_timer));
+				
+				for(k=0;k<FDB_IGMP_EXT_NUM;k++)
+				{
+					if(f->igmp_fdb_arr[k].valid)
+					{
+						len += sprintf(page+len,"\t<%d>clientMac:0x%x:%x:%x:%x:%x:%x,ageing_time:%lu\n",
+						k,f->igmp_fdb_arr[k].SrcMac[0],f->igmp_fdb_arr[k].SrcMac[1],f->igmp_fdb_arr[k].SrcMac[2],f->igmp_fdb_arr[k].SrcMac[3],f->igmp_fdb_arr[k].SrcMac[4],f->igmp_fdb_arr[k].SrcMac[5],(jiffies<f->igmp_fdb_arr[k].ageing_time) ?0:(jiffies-f->igmp_fdb_arr[k].ageing_time));
+					}
+				}
+
+				j++;
+				len += sprintf(page+len,"--------------------------------------------\n");
+			}
+
+		}
+		
+	}
+
+	
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpSnoopWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char br_tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&br_tmp, buffer, 1)) {
+		igmpsnoopenabled = br_tmp - '0';
+		if(igmpsnoopenabled)
+		{
+			igmpsnoopenabled=1;
+		}
+		else
+		{
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)		
+			rtl865x_reinitMulticast();
+#endif
+			rtl_flushAllIgmpRecord();
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+static struct proc_dir_entry *procIgmpDb;
+extern int igmp_show(struct seq_file *s, void *v);
+extern int igmp_write(struct file *file, const char __user *buffer, size_t count, loff_t *data);
+int igmp_db_open(struct inode *inode, struct file *file)
+{
+        return(single_open(file, igmp_show, NULL));
+}
+
+int igmp_db_write(struct file *file, const char __user *buffer, size_t count, loff_t *data)
+{
+         igmp_write(file, buffer, count,data);
+}
+
+struct file_operations igmp_db_seq_file_operations = {
+        .open           = igmp_db_open,
+        .read           = seq_read,
+        .write		= igmp_db_write,
+        .llseek         = seq_lseek,
+        .release        = single_release,
+};
+
+struct proc_dir_entry *procMCastFastFwd=NULL;
+int ipMulticastFastFwd=0;
+int needCheckMfc=0;
+static int br_mCastFastFwdRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c,%c\n", ipMulticastFastFwd + '0',needCheckMfc + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mCastFastFwdWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned int tmp=0; 
+	char 		tmpbuf[512];
+	char		*strptr;
+	char		*tokptr;
+	
+
+	if (count < 2) 
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmpbuf, buffer, count)) 
+	{
+		tmpbuf[count] = '\0';
+
+		strptr=tmpbuf;
+
+		
+		tokptr = strsep(&strptr,",");
+		if (tokptr==NULL)
+		{
+			tmp=simple_strtol(strptr, NULL, 0);
+			printk("tmp=%d\n",tmp);
+			if(tmp==0)
+			{
+				ipMulticastFastFwd=0;
+			}
+			return -EFAULT;
+		}
+		
+		ipMulticastFastFwd = simple_strtol(tokptr, NULL, 0);
+		//printk("ipMulticastFastFwd=%d\n",ipMulticastFastFwd);
+		if(ipMulticastFastFwd)
+		{
+			ipMulticastFastFwd=1;
+		}
+
+		tokptr = strsep(&strptr,",");
+		if (tokptr==NULL)
+		{
+			return -EFAULT;
+		}
+		
+		needCheckMfc = simple_strtol(tokptr, NULL, 0);
+
+		if(needCheckMfc)
+		{
+			needCheckMfc=1;
+		}
+
+		return count;
+	}
+	return -EFAULT;
+}
+
+struct proc_dir_entry *procIgmpQuery=NULL;
+int igmpQueryEnabled=0;	
+static int br_igmpQueryRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", igmpQueryEnabled + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpQueryWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		igmpQueryEnabled = tmp - '0';
+		if(igmpQueryEnabled)
+		{
+			igmpQueryEnabled=1;
+		}
+		else
+		{
+			igmpQueryEnabled=0;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+
+#if defined (CONFIG_RTL_QUERIER_SELECTION)
+
+#define MAX_QUERIER_RECORD 8
+#define QUERIER_EXPIRED_TIME 255
+
+struct querierInfo
+{
+	unsigned int version;
+	unsigned char devName[IFNAMSIZ];
+	unsigned int querierIp[4];
+	unsigned int lastJiffies;
+};
+
+struct querierInfo querierInfoList[MAX_QUERIER_RECORD];
+
+int br_initQuerierInfo(void)
+{
+
+	memset(querierInfoList, 0, sizeof(querierInfoList));
+	return 0;
+	
+}
+
+int br_updateQuerierInfo(unsigned int version, unsigned char *devName, unsigned int* querierIp)
+{
+	int i;
+	unsigned long oldestJiffies;
+	unsigned long oldestIdx=0;
+	
+	if(querierIp==NULL)
+	{
+		return -1;	
+	}
+	
+	if((version!=4) && (version!=6))
+	{
+		return -1;	
+	}
+	
+	/*find matched one*/
+	for(i=0; i<MAX_QUERIER_RECORD; i++)
+	{
+		if((querierInfoList[i].version==version))
+		{
+			if( (version==4) && (querierInfoList[i].querierIp[0]==querierIp[0]))
+			{
+				strcpy(querierInfoList[i].devName,devName);
+				querierInfoList[i].lastJiffies=jiffies;
+				return 0;
+	
+			}
+
+			if((version ==6) && (memcmp(querierInfoList[i].querierIp, querierIp, 16) ==0)) 
+			{
+				strcpy(querierInfoList[i].devName,devName);
+				querierInfoList[i].lastJiffies=jiffies;
+				return 0;
+			}
+		}
+	
+	}
+	
+	/*no matched one, find an empty one*/
+	for(i=0; i<MAX_QUERIER_RECORD; i++)
+	{
+		if(querierInfoList[i].version==0)
+		{
+			querierInfoList[i].version=version;
+			if(version==4)
+			{
+				querierInfoList[i].querierIp[0]=querierIp[0];
+			}
+			else if (version ==6)
+			{
+				memcpy(querierInfoList[i].querierIp, querierIp, 16);
+			}
+			strcpy(querierInfoList[i].devName,devName);
+			querierInfoList[i].lastJiffies=jiffies;
+			
+			return 0;
+		}
+	}
+	
+	/*all entries are used, find oldest one*/
+	oldestJiffies=querierInfoList[0].lastJiffies;
+	oldestIdx=0;
+	for(i=0; i<MAX_QUERIER_RECORD; i++)
+	{
+		if(time_before(querierInfoList[i].lastJiffies,oldestJiffies))
+		{
+			oldestJiffies=querierInfoList[i].lastJiffies;
+			oldestIdx=i;
+		}
+	}
+	
+	querierInfoList[oldestIdx].version=version;
+	if(version==4)
+	{
+		querierInfoList[oldestIdx].querierIp[0]=querierIp[0];
+	}
+	else if (version ==6)
+	{
+		memcpy(querierInfoList[oldestIdx].querierIp, querierIp, 16);
+	}
+	
+	strcpy(querierInfoList[oldestIdx].devName,devName);
+	querierInfoList[oldestIdx].lastJiffies=jiffies;
+	
+	return 0;
+
+	
+}
+
+int br_querierSelection(struct net_bridge *br,unsigned int ipVer)	
+{
+	int i;
+	int ret=1;
+	struct net_device* brDev = NULL;
+	struct in_device *in_dev;	
+	struct net_device *landev;
+	struct in_ifaddr *ifap = NULL;
+	unsigned int brIpAddr=0;
+	unsigned char brIpv6Addr[16]={	0xfe,0x80,0x00,0x00,				/*source address*/
+									0x00,0x00,0x00,0x00,				/*be zero*/	
+									0x00,0x00,0x00,					/*upper 3 bytes mac address |0x02*/ 
+									0xff,0xfe,						/*fixed*/
+									0x00,0x00,0x00					/*lowert 3 bytes mac address*/	};
+
+	
+	if(br==NULL)
+	{
+		return 1;
+	}
+	
+	brDev = br->dev;
+
+	if(ipVer==4)
+	{
+		/*get bridge ip address*/
+		if ((landev = __dev_get_by_name(&init_net, RTL_PS_BR0_DEV_NAME)) != NULL){
+			in_dev=(struct net_device *)(landev->ip_ptr);
+			if (in_dev != NULL) {
+				for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+					if (strcmp(RTL_PS_BR0_DEV_NAME, ifap->ifa_label) == 0)
+					{
+							memcpy(&brIpAddr,&ifap->ifa_address,4);
+					}
+				}
+				
+			}
+		}
+
+		for(i=0; i<MAX_QUERIER_RECORD; i++)
+		{
+			if(	(querierInfoList[i].version==4)&&
+				time_after(querierInfoList[i].lastJiffies+QUERIER_EXPIRED_TIME*HZ,jiffies)&&
+				(querierInfoList[i].querierIp < brIpAddr))
+			{
+				ret=0;
+			}
+		}
+		
+	}
+	else if (ipVer==6)
+	{
+	
+		memcpy(&brIpv6Addr[8],brDev->dev_addr,3);		/*generate br link-local ipv6 address*/
+		brIpv6Addr[8]=brIpv6Addr[8]|0x02;		
+		memcpy(&brIpv6Addr[13],&brDev->dev_addr[3],3);	
+		#if 1
+		printk("br0 ipv6 address is:\n");
+
+		{
+			int j;
+			for(j=0; j<16; j++)	
+			{
+				printk("%x",brIpv6Addr[j]);
+				if((j!=0) &&(j%4==0))
+				{
+					printk("-");
+				}
+			}
+			printk("\n");
+		}
+		#endif
+		
+		for(i=0; i<MAX_QUERIER_RECORD; i++)
+		{
+			if(	(querierInfoList[i].version==6)&&
+				time_after(querierInfoList[i].lastJiffies+QUERIER_EXPIRED_TIME*HZ,jiffies))
+			{
+				if(memcmp(querierInfoList[i].querierIp, brIpv6Addr, 16)<0)
+				{
+					ret=0;
+				}
+			}
+		}
+		
+		
+	}
+	
+	return ret;
+}
+
+
+struct proc_dir_entry *procIgmpQuerierInfo=NULL;
+
+static int br_igmpQuerierInfoRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+	int len=0;
+	int i;
+	unsigned long elapseJiffies;
+	for(i=0; i<MAX_QUERIER_RECORD; i++)
+	{
+		if((querierInfoList[i].version==4) && time_after(querierInfoList[i].lastJiffies+QUERIER_EXPIRED_TIME*HZ,jiffies))
+		{
+			if(jiffies > querierInfoList[i].lastJiffies)
+			{
+				elapseJiffies=jiffies-querierInfoList[i].lastJiffies;
+			}
+			else
+			{
+				elapseJiffies=jiffies+((unsigned long)0xFFFFFFFF-querierInfoList[i].lastJiffies)+1;
+			}
+
+			len += sprintf(page+len, "%s %d.%d.%d.%d %u\n",
+				querierInfoList[i].devName,
+				((querierInfoList[i].querierIp[0]>>24)&0xFF) ,
+				((querierInfoList[i].querierIp[0]>>16)&0xFF),
+				((querierInfoList[i].querierIp[0]>>8)&0xFF),
+				(querierInfoList[i].querierIp[0]&0xFF),elapseJiffies/HZ);
+		}
+	}
+	
+	
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+
+}
+
+static int br_igmpQuerierInfoWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned char tmp[64]; 
+
+	if (count < 2) 
+	{
+		return -EFAULT;
+	}
+	
+	if(count >sizeof(tmp))
+	{
+		return -EFAULT;
+	}
+	  
+	
+    return 0;
+}
+
+
+
+struct proc_dir_entry *procMldQuerierInfo=NULL;
+
+static int br_mldQuerierInfoRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+	int len=0;
+	int i;
+	unsigned long elapseJiffies;
+
+	for(i=0; i<MAX_QUERIER_RECORD; i++)
+	{
+		if((querierInfoList[i].version==6) && time_after(querierInfoList[i].lastJiffies+QUERIER_EXPIRED_TIME*HZ,jiffies))
+		{
+			if(jiffies > querierInfoList[i].lastJiffies)
+			{
+				elapseJiffies=jiffies-querierInfoList[i].lastJiffies;
+			}
+			else
+			{
+				elapseJiffies=jiffies+((unsigned long)0xFFFFFFFF-querierInfoList[i].lastJiffies)+1;
+			}
+
+			len += sprintf(page+len, "%s %x-%x-%x-%x %u\n",
+				querierInfoList[i].devName,
+				querierInfoList[i].querierIp[0],
+				querierInfoList[i].querierIp[1],
+				querierInfoList[i].querierIp[2],
+				querierInfoList[i].querierIp[3],elapseJiffies/HZ);
+		}
+	}
+
+	if (len <= off+count) *eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len>count) len = count;
+	if (len<0) len = 0;
+	return len;
+
+}
+
+static int br_mldQuerierInfoWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned char tmp[64]; 
+
+	if (count < 2) 
+	{
+		return -EFAULT;
+	}
+	
+	if(count >sizeof(tmp))
+	{
+		return -EFAULT;
+	}
+	  
+	
+    return 0;
+}
+
+#endif
+
+
+struct proc_dir_entry *procIgmpVersion=NULL;
+int igmpVersion=2;
+static int br_igmpVersionRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", igmpVersion + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpVersionWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		igmpVersion = tmp - '0';
+		if(igmpVersion>=3)
+		{
+			igmpVersion=3;
+		}
+		else if (igmpVersion<=2)
+		{
+			igmpVersion=2;
+		}
+		else
+		{
+			igmpVersion=2;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+
+/*igmpv3 general query*/
+static unsigned char igmpV3QueryBuf[64]={	0x01,0x00,0x5e,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*offset:6*/
+									0x08,0x00,						/*offset:12*/
+									0x46,0x00,0x00,0x24,				/*offset:14*/
+									0x00,0x00,0x40,0x00,				/*offset:18*/
+									0x01,0x02,0x00,0x00,				/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*offset:26,source ip*/
+									0xe0,0x00,0x00,0x01,				/*offset:30,destination ip*/
+									0x94,0x04,0x00,0x00,				/*offset:34,router alert option*/
+									0x11,0x01,0x00,0x00,				/*offset:38*/
+									0x00,0x00,0x00,0x00,				/*offset:42,queried multicast ip address*/
+									0x0a,0x3c,0x00,0x00,				/*offset:46*/
+									0x00,0x00,0x00,0x00,				/*offset:50*/
+									0x00,0x00,0x00,0x00,				/*offset:54*/
+									0x00,0x00,0x00,0x00,				/*offset:58*/
+									0x00,0x00							/*offset:62*/
+									
+								};			
+
+
+
+/*igmpv2 general query*/
+static unsigned char igmpV2QueryBuf[64]={	0x01,0x00,0x5e,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*offset:6*/
+									0x08,0x00,						/*offset:12*/
+									0x45,0x00,0x00,0x1c,				/*offset:14*/
+									0x00,0x00,0x40,0x00,				/*offset:18*/
+									0x01,0x02,0x00,0x00,				/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*offset:26*/
+									0xe0,0x00,0x00,0x01,				/*offset:30*/
+									0x11,0x01,0x0c,0xfa,				/*offset:34*/
+									0x00,0x00,0x00,0x00,				/*offset:38*/
+									0x00,0x00,0x00,0x00,				/*offset:42*/
+									0x00,0x00,0x00,0x00,				/*offset:46*/
+									0x00,0x00,0x00,0x00,				/*offset:50*/
+									0x00,0x00,0x00,0x00,				/*offset:54*/
+									0x00,0x00,0x00,0x00,				/*offset:58*/
+									0x00,0x00							/*offset:62*/
 
-static struct pernet_operations br_net_ops = {
-	.exit	= br_net_exit,
-};
+								};			
+
+
+
+static unsigned short  br_ipv4Checksum(unsigned char *pktBuf, unsigned int pktLen)
+{
+	/*note: the first bytes of  packetBuf should be two bytes aligned*/
+	unsigned int  checksum=0;
+	unsigned int  count=pktLen;
+	unsigned short   *ptr= (unsigned short *)pktBuf;	
+	
+	 while(count>1)
+	 {
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+		  count -= 2;
+	 }
+	 
+	if(count>0)
+	{
+		checksum+= *(pktBuf+pktLen-1)<<8; /*the last odd byte is treated as bit 15~8 of unsigned short*/
+	}
+
+	/* Roll over carry bits */
+	checksum = (checksum >> 16) + (checksum & 0xffff);
+	checksum += (checksum >> 16);
+
+	/* Return checksum */
+	return ((unsigned short) ~ checksum);
+
+}
+
+static unsigned char* br_generateIgmpQuery(struct net_bridge * br)
+{
+	struct net_device* brDev = NULL;
+	unsigned short checkSum=0;
+	struct in_device *in_dev;	
+	struct net_device *landev;
+	struct in_ifaddr *ifap = NULL;
+	
+      
+	if(br==NULL)
+	{
+		return NULL;
+	}
+	
+	brDev = br->dev;
+	if(igmpVersion==3)
+	{
+		memcpy(&igmpV3QueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	}
+	else
+	{
+		memcpy(&igmpV2QueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	}
+	
+	/*set source ip address*/
+	if ((landev = __dev_get_by_name(&init_net, RTL_PS_BR0_DEV_NAME)) != NULL){
+		in_dev=(struct net_device *)(landev->ip_ptr);
+		if (in_dev != NULL) {
+			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+				if (strcmp(RTL_PS_BR0_DEV_NAME, ifap->ifa_label) == 0){
+					if(igmpVersion==3)
+					{
+						memcpy(&igmpV3QueryBuf[26],&ifap->ifa_address,4);
+					}
+					else
+					{
+						memcpy(&igmpV2QueryBuf[26],&ifap->ifa_address,4);
+					}
+					
+				}
+			}
+			
+		}
+	}
+	else
+	{
+		return NULL;
+	}
+	
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(!strcmp(RTL_PS_BR1_DEV_NAME, br->dev->name))
+	{
+		if (landev = brDev){
+			in_dev=(struct net_device *)(landev->ip_ptr);
+			if (in_dev != NULL) {
+				for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+					if (strcmp(br->dev->name, ifap->ifa_label) == 0){
+						if(igmpVersion==3)
+						{
+							memcpy(&igmpV3QueryBuf[26],&ifap->ifa_address,4);
+						}
+						else
+						{
+							memcpy(&igmpV2QueryBuf[26],&ifap->ifa_address,4);
+						}
+					}
+				}
+			}
+		}
+	}
+        #endif
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[24]=0;
+		igmpV3QueryBuf[25]=0;
+	}
+	else
+	{
+		igmpV2QueryBuf[24]=0;
+		igmpV2QueryBuf[25]=0;
+	}
+	
+	if(igmpVersion==3)
+	{
+		checkSum=br_ipv4Checksum(&igmpV3QueryBuf[14],24);
+	}
+	else
+	{
+		checkSum=br_ipv4Checksum(&igmpV2QueryBuf[14],20);
+	}
+
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[24]=(checkSum&0xff00)>>8;
+		igmpV3QueryBuf[25]=(checkSum&0x00ff);
+
+	}
+	else
+	{
+		igmpV2QueryBuf[24]=(checkSum&0xff00)>>8;
+		igmpV2QueryBuf[25]=(checkSum&0x00ff);
+
+	}
+	
+
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[40]=0;
+		igmpV3QueryBuf[41]=0;
+		checkSum=br_ipv4Checksum(&igmpV3QueryBuf[38],12);
+		igmpV3QueryBuf[40]=(checkSum&0xff00)>>8;
+		igmpV3QueryBuf[41]=(checkSum&0x00ff);
+	}
+	else
+	{
+		igmpV2QueryBuf[36]=0;
+		igmpV2QueryBuf[37]=0;
+		checkSum=br_ipv4Checksum(&igmpV2QueryBuf[34],8);
+		igmpV2QueryBuf[36]=(checkSum&0xff00)>>8;
+		igmpV2QueryBuf[37]=(checkSum&0x00ff);
+	}
+
+	if(igmpVersion==3)
+	{
+		return igmpV3QueryBuf;
+	}
+	else
+	{
+		return igmpV2QueryBuf;
+	}
+	
+	return NULL;
+}
+
+
+void br_igmpQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	unsigned char *igmpBuf=NULL;
+	struct sk_buff *skb;
+	struct sk_buff *skb2;
+	struct net_bridge_port *p, *n;
+	struct net_bridge_port *prev;
+	unsigned int fwdCnt=0;
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(IGMPProxyOpened && strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+#else
+	if(IGMPProxyOpened)
+#endif
+	{
+		return ;
+	}
+	
+	if(igmpQueryEnabled==0)
+	{
+		return;
+	}
+
+	
+#if defined (CONFIG_RTL_QUERIER_SELECTION)
+	if(br_querierSelection(br,4)==0)
+	{
+		return;
+	}
+#endif	
+
+	skb=dev_alloc_skb(1024);
+	if(skb==NULL)
+	{
+		return;
+	}
+
+	memset(skb->data,64,0);
+	igmpBuf=br_generateIgmpQuery(br);
+	if(igmpBuf==NULL)
+	{
+		return;
+	}
+
+	memcpy(skb->data,igmpBuf,64);
+
+	skb->len = 0;
+	if(igmpVersion==3)
+	{
+		skb_put(skb, 50);
+	}
+	else
+	{
+		skb_put(skb, 42);
+	}
+	
+	skb->dev=br->dev;
+	
+	prev = NULL;
+	fwdCnt=0;
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{ 
+		if ((p->state == BR_STATE_FORWARDING) && (strncmp(p->dev->name, "peth",4)!=0) && (strncmp(p->dev->name, "pwlan",5)!=0)) 
+		{
+			if (prev != NULL) 
+			{                                                                                       
+				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+				{
+					br->dev->stats.tx_dropped++;
+					kfree_skb(skb);
+					return 0;
+				} 
+				skb2->dev=prev->dev;
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb2, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+				#endif                  
+				fwdCnt++;
+			}
+				                                                                               
+			prev = p;
+		}
+	}
+
+	if (prev != NULL) 
+	{
+		skb->dev=prev->dev;
+	       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+		prev->dev->hard_start_xmit(skb, prev->dev);
+		#else
+		prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+		#endif                            
+		fwdCnt++;
+	}
+
+	if(fwdCnt==0)
+	{
+		/*to avoid memory leak*/
+		kfree_skb(skb);
+	}
+	return;
+}
+
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+struct proc_dir_entry *procMldQuery=NULL;
+int mldQueryEnabled=0;	
+static int br_mldQueryRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", mldQueryEnabled + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mldQueryWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		mldQueryEnabled = tmp - '0';
+		if(mldQueryEnabled)
+		{
+			mldQueryEnabled=1;
+		}
+		else
+		{
+			mldQueryEnabled=0;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+struct proc_dir_entry *procMldVersion=NULL;
+int mldVersion=2;
+static int br_mldVersionRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", mldVersion + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mldVersionWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		mldVersion = tmp - '0';
+		if(mldVersion>=2)
+		{
+			mldVersion=2;
+		}
+		else if (mldVersion<=1)
+		{
+			mldVersion=1;
+		}
+		else
+		{
+			mldVersion=2;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+static unsigned char mldQueryBuf[90]={	0x33,0x33,0x00,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*source mac*/	/*offset:6*/
+									0x86,0xdd,						/*ether type*/	/*offset:12*/
+									0x60,0x00,0x00,0x00,				/*version(1 byte)-traffic cliass(1 byte)- flow label(2 bytes)*/	/*offset:14*/
+									0x00,0x20,0x00,0x01,				/*payload length(2 bytes)-next header(1 byte)-hop limit(value:1 1byte)*//*offset:18*/
+									0xfe,0x80,0x00,0x00,				/*source address*/	/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*be zero*/	/*offset:26*/
+									0x00,0x00,0x00,					/*upper 3 bytes mac address |0x02*/ /*offset:30*/
+									0xff,0xfe,						/*fixed*/
+									0x00,0x00,0x00,					/*lowert 3 bytes mac address*/	 /*offset:35*/
+									0xff,0x02,0x00,0x00,				/*destination address is fixed as FF02::1*/	/*offset:38*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x01,			
+									0x3a,0x00,						/*icmp type(1 byte)-length(1 byte)*/	 /*offset:54*/
+									0x05,0x02,0x00,0x00,				/*router alert option*/
+									0x01,0x00,						/*padN*/
+									0x82,0x00,						/*type(query:0x82)-code(0)*/	/*offset:62*/
+									0x00,0x00,						/*checksum*/	/*offset:64*/
+									0x00,0x0a,						/*maximum reponse code*/
+									0x00,0x00,						/*reserved*/
+									0x00,0x00,0x00,0x00,				/*multicast address,fixed as 0*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00,
+									0x0a,0x3c,0x00,0x00
+								};			
+
+static unsigned char ipv6PseudoHdrBuf[40]=	{	
+									0xfe,0x80,0x00,0x00,				/*source address*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0xff,			
+									0xfe,0x00,0x00,0x00,			 	
+									0xff,0x02,0x00,0x00,				/*destination address*/
+									0x00,0x00,0x00,0x00,		
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x01,				
+									0x00,0x00,0x00,0x18,				/*upper layer packet length*/
+									0x00,0x00,0x00,0x3a					/*zero padding(3 bytes)-next header(1 byte)*/
+									};		
+
+static unsigned short br_ipv6Checksum(unsigned char *pktBuf, unsigned int pktLen, unsigned char  *ipv6PseudoHdrBuf)
+{
+	unsigned int  checksum=0;
+	unsigned int count=pktLen;
+	unsigned short   *ptr;
+
+	/*compute ipv6 pseudo-header checksum*/
+	ptr= (unsigned short  *) (ipv6PseudoHdrBuf);	
+	for(count=0; count<20; count++) /*the pseudo header is 40 bytes long*/
+	{
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+	}
+	
+	/*compute the checksum of mld buffer*/
+	 count=pktLen;
+	 ptr=(unsigned short  *) (pktBuf);	
+	 while(count>1)
+	 {
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+		  count -= 2;
+	 }
+	 
+	if(count>0)
+	{
+		checksum+= *(pktBuf+pktLen-1)<<8; /*the last odd byte is treated as bit 15~8 of unsigned short*/
+	}
+
+	/* Roll over carry bits */
+	checksum = (checksum >> 16) + (checksum & 0xffff);
+	checksum += (checksum >> 16);
+
+	/* Return checksum */
+	return ((uint16) ~ checksum);
+	
+}
+static unsigned char* br_generateMldQuery(struct net_bridge * br)
+{
+	struct net_device* brDev = NULL;
+	unsigned short checkSum=0;
+	if(br==NULL)
+	{
+		return NULL;
+	}
+	
+	brDev = br->dev;
+	
+	memcpy(&mldQueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	
+	memcpy(&mldQueryBuf[30],brDev->dev_addr,3);		/*set  mld query packet source ip address*/
+	mldQueryBuf[30]=mldQueryBuf[30]|0x02;		
+	memcpy(&mldQueryBuf[35],&brDev->dev_addr[3],3);		
+
+	
+	memcpy(ipv6PseudoHdrBuf,&mldQueryBuf[22],16);			/*set pseudo-header source ip*/
+	if(mldVersion==2)
+	{
+		mldQueryBuf[19]=	0x24;
+	}
+	else
+	{
+		mldQueryBuf[19]=	0x20;
+	}
+
+	mldQueryBuf[64]=0;/*reset checksum*/
+	mldQueryBuf[65]=0;
+	if(mldVersion==2)
+	{
+		ipv6PseudoHdrBuf[35]=28;
+		checkSum=br_ipv6Checksum(&mldQueryBuf[62],28,ipv6PseudoHdrBuf);
+	}
+	else
+	{
+		ipv6PseudoHdrBuf[35]=24;
+		checkSum=br_ipv6Checksum(&mldQueryBuf[62],24,ipv6PseudoHdrBuf);
+	}
+	
+	
+	mldQueryBuf[64]=(checkSum&0xff00)>>8;
+	mldQueryBuf[65]=(checkSum&0x00ff);
+	return mldQueryBuf;
+	
+	
+}
+
+
+void br_mldQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	struct sk_buff *skb;
+	struct sk_buff *skb2;
+	struct net_bridge_port *p, *n;
+	struct net_bridge_port *prev;
+	unsigned int fwdCnt=0;
+	unsigned char *mldBuf=NULL;
+
+	if(mldQueryEnabled==0)
+	{
+		return;
+	}
+	
+#if defined (CONFIG_RTL_QUERIER_SELECTION)
+	if(br_querierSelection(br,6)==0)
+	{
+		return;
+	}
+#endif	
+
+	skb=dev_alloc_skb(1024);
+	if(skb==NULL)
+	{
+		return;
+	}
+	
+	memset(skb->data,86,0);
+	mldBuf=br_generateMldQuery(br);
+	if(mldBuf==NULL)
+	{
+		return;
+	}
+	
+	if(mldVersion==2)
+	{
+		memcpy(skb->data,mldBuf,90);
+		skb->len = 0;
+		skb_put(skb, 90);
+	}
+	else
+	{
+		memcpy(skb->data,mldBuf,86);
+		skb->len = 0;
+		skb_put(skb, 86);
+	}
+ 
+	prev = NULL;
+	fwdCnt=0;
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{ 
+		if ((p->state == BR_STATE_FORWARDING) && (strncmp(p->dev->name, "peth",4)!=0) && (strncmp(p->dev->name, "pwlan",5)!=0)) 
+		{
+			if (prev != NULL) 
+			{                                                                                       
+				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+				{
+					br->dev->stats.tx_dropped++;
+					kfree_skb(skb);
+					return 0;
+				} 
+				skb2->dev=prev->dev;
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb2, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+				#endif                  
+				fwdCnt++;
+			}
+				                                                                               
+			prev = p;
+		}
+	}
+
+	if (prev != NULL) 
+	{
+		skb->dev=prev->dev;
+	       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+		prev->dev->hard_start_xmit(skb, prev->dev);
+		#else
+		prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+		#endif                            
+		fwdCnt++;
+	}
+
+	if(fwdCnt==0)
+	{
+		/*to avoid memory leak*/
+		kfree_skb(skb);
+	}
+	
+	return;
+}
+#endif
+
+static unsigned int mCastQueryTimerCnt=0;
+void br_mCastQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	
+	mod_timer(&br->mCastQuerytimer, jiffies+MCAST_QUERY_INTERVAL*HZ);
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+		if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+		{
+			br_igmpQueryTimerExpired(arg);
+			return;
+		}
+	#endif
+	
+	if(mCastQueryTimerCnt%2==0)
+	{
+		br_igmpQueryTimerExpired(arg);
+	}
+	else
+	{
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		br_mldQueryTimerExpired(arg);
+		#endif
+	}
+	mCastQueryTimerCnt++;
+	
+	return;
+}
+
+extern struct net_bridge *find_br_by_name(char *name);
+
+void br_signal_igmpProxy(void)
+{
+
+	struct task_struct *task;
+	struct net_bridge *br;
+
+	br = find_br_by_name(RTL_PS_BR0_DEV_NAME);
+	if(br==NULL)
+	{
+		return;
+	}
+
+	if(br->igmpProxy_pid==0)
+	{
+		return;
+	}
+	
+	read_lock(&tasklist_lock);
+//	task = find_task_by_pid(br->igmpProxy_pid);
+	task = find_task_by_vpid(br->igmpProxy_pid);
+	read_unlock(&tasklist_lock);
+	if(task)
+	{
+		send_sig(SIGUSR2,task,0);
+	}
+	else {
+	    //printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+	}
+}
+
+#endif
+
+struct proc_dir_entry *procIgmpProxy = NULL;
+static int br_igmpProxyRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+      int len;
+      len = sprintf(page, "%c\n", IGMPProxyOpened + '0');
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+static int br_igmpProxyWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+    unsigned char chartmp; 
+	  
+    if (count > 1) {	//call from shell
+      	if (buffer && !copy_from_user(&chartmp, buffer, 1)) {
+	    	IGMPProxyOpened = chartmp - '0';			
+	    }
+	}else if(count==1){//call from demon(demon direct call br's ioctl)
+			//memcpy(&chartmp,buffer,1);
+			if(buffer){
+				get_user(chartmp,buffer);	
+		    		IGMPProxyOpened = chartmp - '0';
+			}else
+				return -EFAULT;
+
+	}else{
+
+		return -EFAULT;
+	}
+	return count;
+}
 
 static int __init br_init(void)
 {
@@ -50,6 +1640,102 @@ static int __init br_init(void)
 	if (err)
 		goto err_out1;
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	lan_restrict_init();
+#endif
+
+#if defined (CONFIG_RTL_EAP_RELAY) || defined (CONFIG_RTK_INBAND_HOST_HACK)
+		procHostMac = create_proc_entry("br_hostmac", 0, NULL);
+		if (procHostMac) {
+		    procHostMac->read_proc = br_hostmac_read_proc;
+		    procHostMac->write_proc = br_hostmac_write_proc;
+		}
+#endif
+
+#if defined (CONFIG_RTK_INBAND_HOST_HACK)
+		procHostIp = create_proc_entry("br_hostip", 0, NULL);
+		if (procHostIp) {
+		    procHostIp->read_proc = br_hostip_read_proc;
+		    procHostIp->write_proc = br_hostip_write_proc;
+		}
+#endif
+
+
+#if defined(CONFIG_PROC_FS) && defined (CONFIG_RTL_WLAN_BLOCK_RELAY)
+		procwlanblockrelay = create_proc_entry("br_wlanblock", 0, NULL);
+		if(procwlanblockrelay) {
+			procwlanblockrelay->read_proc = br_wlanblockread_proc;
+			procwlanblockrelay->write_proc = br_wlanblockwrite_proc;
+		}
+#endif
+
+#if defined (CONFIG_PROC_FS) && defined (CONFIG_RTL_IGMP_SNOOPING)	
+		procIgmpSnoop = create_proc_entry("br_igmpsnoop", 0, NULL);
+		if (procIgmpSnoop) {
+		    procIgmpSnoop->read_proc = br_igmpSnoopRead_proc;
+		    procIgmpSnoop->write_proc = br_igmpSnoopWrite_proc;
+		}
+
+		procIgmpDb=create_proc_entry("br_igmpDb", 0, NULL);
+		if(procIgmpDb != NULL)
+		{
+			procIgmpDb->proc_fops = &igmp_db_seq_file_operations;
+
+		}
+
+		procMCastFastFwd= create_proc_entry("br_mCastFastFwd", 0, NULL);
+		if (procMCastFastFwd) {
+		    procMCastFastFwd->read_proc = br_mCastFastFwdRead_proc;
+		    procMCastFastFwd->write_proc = br_mCastFastFwdWrite_proc;
+		}
+
+		procIgmpVersion= create_proc_entry("br_igmpVersion", 0, NULL);
+		if (procIgmpVersion) {
+		    procIgmpVersion->read_proc = br_igmpVersionRead_proc;
+		    procIgmpVersion->write_proc = br_igmpVersionWrite_proc;
+		}
+		
+		procIgmpQuery= create_proc_entry("br_igmpquery", 0, NULL);
+		if (procIgmpQuery) {
+		    procIgmpQuery->read_proc = br_igmpQueryRead_proc;
+		    procIgmpQuery->write_proc = br_igmpQueryWrite_proc;
+		}
+#if defined (CONFIG_RTL_QUERIER_SELECTION)		
+		br_initQuerierInfo();
+		procIgmpQuerierInfo = create_proc_entry("br_igmpQuerierInfo", 0, NULL);
+		if (procIgmpQuerierInfo) {
+			procIgmpQuerierInfo->read_proc = br_igmpQuerierInfoRead_proc;
+			procIgmpQuerierInfo->write_proc = br_igmpQuerierInfoWrite_proc;
+		}
+
+		procMldQuerierInfo = create_proc_entry("br_mldQuerierInfo", 0, NULL);
+		if (procMldQuerierInfo) {
+			procMldQuerierInfo->read_proc = br_mldQuerierInfoRead_proc;
+			procMldQuerierInfo->write_proc = br_mldQuerierInfoWrite_proc;
+		}
+#endif
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+		procMldVersion= create_proc_entry("br_mldVersion", 0, NULL);
+		if (procMldVersion) {
+		    procMldVersion->read_proc = br_mldVersionRead_proc;
+		    procMldVersion->write_proc = br_mldVersionWrite_proc;
+		}
+		procMldQuery= create_proc_entry("br_mldquery", 0, NULL);
+		if (procMldQuery) {
+		    procMldQuery->read_proc = br_mldQueryRead_proc;
+		    procMldQuery->write_proc = br_mldQueryWrite_proc;
+		}
+#endif
+#endif
+
+#if  defined (CONFIG_PROC_FS) 	
+		procIgmpProxy = create_proc_entry("br_igmpProxy", 0, NULL);
+		if (procIgmpProxy) {
+		    procIgmpProxy->read_proc = br_igmpProxyRead_proc;
+		    procIgmpProxy->write_proc = br_igmpProxyWrite_proc;
+		}
+#endif
 	err = br_netfilter_init();
 	if (err)
 		goto err_out2;
@@ -67,7 +1753,12 @@ static int __init br_init(void)
 
 	br_fdb_get_hook = br_fdb_get;
 	br_fdb_put_hook = br_fdb_put;
-
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+	br_filter_init();
+#endif
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	http_file_init();
+#endif	
 	return 0;
 err_out4:
 	unregister_netdevice_notifier(&br_device_notifier);
@@ -86,6 +1777,63 @@ static void __exit br_deinit(void)
 {
 	stp_proto_unregister(&br_stp_proto);
 
+#if  defined (CONFIG_PROC_FS) && defined (CONFIG_RTL_IGMP_SNOOPING)
+	if (procIgmpSnoop) {
+		remove_proc_entry("br_igmpsnoop", procIgmpSnoop);		
+		procIgmpSnoop = NULL;
+	}
+
+	if(procIgmpDb!=NULL)
+	{
+		remove_proc_entry("br_igmpDb", procIgmpDb);
+	}
+	
+	if (procMCastFastFwd) {
+		remove_proc_entry("br_mCastFastFwd", procMCastFastFwd);		
+		procMCastFastFwd = NULL;
+	}
+
+	if (procIgmpVersion) {
+	 	 remove_proc_entry("br_igmpVersion", procIgmpVersion);		
+		procIgmpVersion = NULL;
+	}
+	
+	if (procIgmpQuery) {
+	 	 remove_proc_entry("br_igmpquery", procIgmpQuery);		
+		procIgmpQuery = NULL;
+	}
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+	if (procMldVersion) {
+	 	 remove_proc_entry("br_mldVersion", procMldVersion);		
+		procMldVersion = NULL;
+	}
+	if (procMldQuery) {
+		 remove_proc_entry("br_mldquery", procMldQuery);		
+		procMldQuery = NULL;
+	}
+#endif	
+
+#if defined (CONFIG_RTL_QUERIER_SELECTION)		
+		if (procIgmpQuerierInfo) {
+			remove_proc_entry("br_igmpQuerierInfo", procIgmpQuerierInfo);	
+			procIgmpQuerierInfo=NULL;
+		}
+
+		if (procMldQuerierInfo) {
+			remove_proc_entry("br_mldQuerierInfo", procMldQuerierInfo);	
+			procMldQuerierInfo=NULL;
+		}
+#endif
+
+#endif	
+
+#if  defined (CONFIG_PROC_FS) 
+	if (procIgmpProxy) {
+		remove_proc_entry("br_igmpProxy", procIgmpProxy);		
+		procIgmpProxy = NULL;
+	}
+#endif
 	br_netlink_fini();
 	unregister_netdevice_notifier(&br_device_notifier);
 	brioctl_set(NULL);
@@ -100,6 +1848,12 @@ static void __exit br_deinit(void)
 
 	br_handle_frame_hook = NULL;
 	br_fdb_fini();
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+	br_filter_exit();
+#endif
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	http_file_exit();
+#endif	
 }
 
 EXPORT_SYMBOL(br_should_route_hook);
--- linux-2.6.30.9/net/bridge/br_device.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_device.c	2013-05-02 01:47:59.217226614 +0300
@@ -19,6 +19,55 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+/*2008-01-15,for porting igmp snooping to linux kernel 2.6*/
+#include <linux/ip.h>
+#include <linux/in.h>
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+extern int igmpsnoopenabled;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+extern int mldSnoopEnabled;
+#endif
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+#include <net/rtl/rtl865x_multicast.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+extern unsigned int br0SwFwdPortMask;
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int nicIgmpModuleIndex;
+#endif
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+extern uint32 rtl_hw_vlan_get_tagged_portmask(void);
+#endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+extern unsigned int br1SwFwdPortMask;
+extern unsigned int nicIgmpModuleIndex_2;
+#endif
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr);
+#endif
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+#define ETHER_HDR_LEN 14
+#define ARP_HRD_LEN 8
+extern unsigned char inband_Hostmac[];
+extern int br_hackMac_enable;
+extern void check_listen_info(struct sk_buff *skb);
+#endif
+
 /* net device transmit always called with no BH (preempt_disabled) */
 int br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
@@ -26,6 +75,43 @@ int br_dev_xmit(struct sk_buff *skb, str
 	const unsigned char *dest = skb->data;
 	struct net_bridge_fdb_entry *dst;
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+	struct iphdr *iph=NULL;
+	unsigned char proto=0;
+	unsigned char reserved=0;
+#if defined (CONFIG_RTL_MLD_SNOOPING) 	
+	struct ipv6hdr *ipv6h=NULL;
+#endif
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	int ret=FAILED;
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	unsigned int srcPort=skb->srcPort;
+	unsigned int srcVlanId=skb->srcVlanId;
+#endif
+#endif	
+
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+// send all paket that from local with hostmac (after bridge mac learning)	
+	//hex_dump(skb->data, 48);
+	if(br_hackMac_enable){			
+		if(memcmp(skb->data,inband_Hostmac,6)) //if destmac is not to host
+			memcpy(skb->data+6, inband_Hostmac,6); //then modify source mac to hostmac
+		else
+			goto ap_hcm_out;
+		// if it is arp then sender mac also need modify to hostmac
+		if( (skb->data[12] == 0x08) && (skb->data[13] == 0x06) ) //0806 = ARP
+		{
+			memcpy(skb->data+ETHER_HDR_LEN+ARP_HRD_LEN, inband_Hostmac,6); //modify arp sender mac			
+		}
+		else if((skb->data[12] == 0x08) && (skb->data[13] == 0x00)) //IP
+		{
+			check_listen_info(skb);
+		}
+	}
+ap_hcm_out:		
+#endif
+
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
@@ -32,8 +118,100 @@ int br_dev_xmit(struct sk_buff *skb, str
 	skb_reset_mac_header(skb);
 	skb_pull(skb, ETH_HLEN);
 
+
 	if (dest[0] & 1)
+	{
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+		if(igmpsnoopenabled) 
+		{	
+			if(MULTICAST_MAC(dest))
+			{
+			
+				iph=(struct iphdr *)skb_network_header(skb);
+				proto =  iph->protocol;
+				#if 0
+				if(( iph->daddr&0xFFFFFF00)==0xE0000000)
+				{
+				        reserved=1;
+				}
+				#endif
+
+				#if defined(CONFIG_USB_UWIFI_HOST)
+				if(iph->daddr == 0xEFFFFFFA || iph->daddr == 0xE1010101)
+				#else
+				if(iph->daddr == 0xEFFFFFFA)
+				#endif
+				{
+					/*for microsoft upnp*/
+					reserved=1;
+				}
+				
+				if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))  && (reserved ==0))
+				{
+					multicastDataInfo.ipVersion=4;
+					multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
+					multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+			
+					br_multicast_deliver(br, multicastFwdInfo.fwdPortMask, skb, 0);
+					if((ret==SUCCESS) && (multicastFwdInfo.cpuFlag==0))
+					{
+						#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+						if((srcVlanId!=0) && (srcPort!=0xFFFF))
+						{
+							#if defined(CONFIG_RTK_VLAN_SUPPORT)
+							if(rtk_vlan_support_enable == 0)
+							{
+								rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+							}
+							#else
+							rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+							#endif
+						}
+						#endif		
+					}
+				
+				}
+				else
+				{
+					br_flood_deliver(br, skb);
+				}
+
+				
+			}
+#if defined(CONFIG_RTL_MLD_SNOOPING)	
+			else if(mldSnoopEnabled && IPV6_MULTICAST_MAC(dest))
+			{
+				ipv6h=(struct ipv6hdr *)skb_network_header(skb);
+				proto=re865x_getIpv6TransportProtocol(ipv6h);
+				if ((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+				{
+					multicastDataInfo.ipVersion=6;
+					memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+					memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+					br_multicast_deliver(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				}
+				else
+				{
+					br_flood_deliver(br, skb);
+				}
+			}
+#endif		
+			else
+			{
 		br_flood_deliver(br, skb);
+			}
+		
+		}
+		else
+		{ 
+			br_flood_deliver(br, skb);
+		}	
+#else
+		br_flood_deliver(br, skb);
+#endif
+	}
 	else if ((dst = __br_fdb_get(br, dest)) != NULL)
 		br_deliver(dst->dst, skb);
 	else
@@ -180,8 +358,148 @@ void br_dev_setup(struct net_device *dev
 	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
 	dev->tx_queue_len = 0;
 	dev->priv_flags = IFF_EBRIDGE;
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+			NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
+			NETIF_F_NETNS_LOCAL | NETIF_F_GSO|NETIF_F_GRO|NETIF_F_LRO;
 
+#elif defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP)
+        dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+                        NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
+                        NETIF_F_NETNS_LOCAL | NETIF_F_GSO|NETIF_F_GRO;
+#else
 	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
 			NETIF_F_NETNS_LOCAL | NETIF_F_GSO;
+#endif
 }
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+
+int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr)
+{
+	int ret;
+	//int fwdDescCnt;
+	//unsigned short port_bitmask=0;
+
+	unsigned int tagged_portmask=0;
+
+
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo  multicastFwdInfo;
+	
+	rtl865x_tblDrv_mCast_t * existMulticastEntry;
+	rtl865x_mcast_fwd_descriptor_t  fwdDescriptor;
+
+	#if 0
+	printk("%s:%d,srcPort is %d,srcVlanId is %d,srcIpAddr is 0x%x,destIpAddr is 0x%x\n",__FUNCTION__,__LINE__,srcPort,srcVlanId,srcIpAddr,destIpAddr);
+	#endif
+
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0 &&strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)!=0 )
+	{
+		return -1;
+	}
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0 && (brFwdPortMask & br0SwFwdPortMask))
+	{
+		return -1;
+	}	
+	
+	if(strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)==0 && (brFwdPortMask & br1SwFwdPortMask))
+	{
+		return -1;
+	}
+#else
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0)
+	{
+		return -1;
+	}
+
+	if(brFwdPortMask & br0SwFwdPortMask)
+	{
+		return -1;
+	}
+#endif
+	//printk("%s:%d,destIpAddr is 0x%x, srcIpAddr is 0x%x, srcVlanId is %d, srcPort is %d\n",__FUNCTION__,__LINE__,destIpAddr, srcIpAddr, srcVlanId, srcPort);
+	existMulticastEntry=rtl865x_findMCastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort);
+	if(existMulticastEntry!=NULL)
+	{
+		/*it's already in cache */
+		return 0;
+
+	}
+
+	if(brFwdPortMask==0)
+	{
+		rtl865x_blockMulticastFlow(srcVlanId, srcPort, srcIpAddr, destIpAddr);
+		return 0;
+	}
+	
+	multicastDataInfo.ipVersion=4;
+	multicastDataInfo.sourceIp[0]=  srcIpAddr;
+	multicastDataInfo.groupAddr[0]=  destIpAddr;
+
+	/*add hardware multicast entry*/
+
+	#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
+		strcpy(fwdDescriptor.netifName,"eth*");
+		fwdDescriptor.fwdPortMask=0xFFFFFFFF;
+		ret= rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+	}
+	else if(strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
+		strcpy(fwdDescriptor.netifName,"eth2");
+		fwdDescriptor.fwdPortMask=0xFFFFFFFF;
+		ret= rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex_2, &multicastDataInfo, &multicastFwdInfo);
+	}
+	#else
+	memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
+	strcpy(fwdDescriptor.netifName,"eth*");
+	fwdDescriptor.fwdPortMask=0xFFFFFFFF;
+	
+	ret= rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+	#endif
+	if(ret!=0)
+	{
+		return -1;
+	}
+	else
+	{
+		if(multicastFwdInfo.cpuFlag)
+		{
+			fwdDescriptor.toCpu=1;
+		}
+		fwdDescriptor.fwdPortMask=multicastFwdInfo.fwdPortMask & (~(1<<srcPort));
+	}
+
+#if defined(CONFIG_RTL_HW_VLAN_SUPPORT)
+	if(rtl_hw_vlan_ignore_tagged_mc == 1)
+		tagged_portmask = rtl_hw_vlan_get_tagged_portmask();
+#endif
+	if((fwdDescriptor.fwdPortMask & tagged_portmask) == 0)
+	{
+
+		ret=rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort,
+							&fwdDescriptor, 1, 0, 0, 0);
+	}
+
+	return 0;
+}
+
+#endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+int rtl865x_same_root(struct net_device *dev1,struct net_device *dev2){
+
+	struct net_bridge_port *p = rcu_dereference(dev1->br_port);
+	struct net_bridge_port *p2 = rcu_dereference(dev2->br_port);
+	return !strncmp(p->br->dev->name,p2->br->dev->name,3);
+}
+#endif
--- linux-2.6.30.9/net/bridge/br_fdb.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_fdb.c	2013-05-02 01:47:59.217226614 +0300
@@ -23,6 +23,35 @@
 #include <asm/atomic.h>
 #include <asm/unaligned.h>
 #include "br_private.h"
+#include <linux/wireless.h>
+
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_fdb_api.h>
+
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+
+#if defined (CONFIG_RTL_LAYERED_DRIVER_L2)&& defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+#include <net/rtl/features/lan_restrict.h>
+
+#endif
+
+#endif	/*	defined(CONFIG_RTL_819X)	*/
+
+#if defined(CONFIG_RTL_819X)
+static int fdb_entry_max = 2048;
+static int fdb_entry_num = 0;
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+extern int IGMPProxyOpened;
+void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn );
+//void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent);
+#endif
 
 static struct kmem_cache *br_fdb_cache __read_mostly;
 static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
@@ -75,6 +104,11 @@ static inline void fdb_delete(struct net
 {
 	hlist_del_rcu(&f->hlist);
 	br_fdb_put(f);
+	#if 0
+	#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(f);
+	#endif
+	#endif
 }
 
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
@@ -104,6 +138,7 @@ void br_fdb_changeaddr(struct net_bridge
 				}
 
 				/* delete old one */
+				//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 				fdb_delete(f);
 				goto insert;
 			}
@@ -116,9 +151,118 @@ void br_fdb_changeaddr(struct net_bridge
 	spin_unlock_bh(&br->hash_lock);
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+ void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent)
+{
+	int i2;
+	unsigned long igmp_walktimeout;	
+	unsigned char *DA;
+	unsigned char *SA;
+	#if defined	(MCAST_TO_UNICAST)
+	struct net_device *dev=NULL;
+	#endif
+	
+	igmp_walktimeout = 	jiffies - IGMP_EXPIRE_TIME;	
+	    
+	//IGMP_EXPIRE_TIME
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++)
+	{
+		if(ent->igmp_fdb_arr[i2].valid == 1){
+
+			// when timeout expire
+			if(time_before_eq(ent->igmp_fdb_arr[i2].ageing_time, igmp_walktimeout))
+			{
+				DEBUG_PRINT("%s:%d\n",__FUNCTION__,__LINE__);	
+				SA = ent->igmp_fdb_arr[i2].SrcMac;					
+				DEBUG_PRINT("expired src mac:%02x,%02x,%02x,%02x,%02x,%02x\n",
+					SA[0],SA[1],SA[2],SA[3],SA[4],SA[5]);								
+
+				DA = ent->addr.addr;					
+				DEBUG_PRINT("fdb:%02x:%02x:%02x-%02x:%02x:%02x\n",
+					DA[0],DA[1],DA[2],DA[3],DA[4],DA[5]);				
+
+
+
+				/*---for process wlan client expired start---*/								
+				#if defined	(MCAST_TO_UNICAST)
+				dev = __dev_get_by_name(&init_net, RTL_PS_WLAN0_DEV_NAME);	
+	
+				
+				if (dev) {		
+					unsigned char StaMacAndGroup[20];
+					memcpy(StaMacAndGroup, DA , 6);
+					memcpy(StaMacAndGroup+6, SA, 6);
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (dev->do_ioctl != NULL) {
+						dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#else
+					if (dev->netdev_ops->ndo_do_ioctl != NULL) {
+						dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#endif
+						DEBUG_PRINT("(fdb expire) wlan0 ioctl to DEL! M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+							StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+							StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+					}
+				}
+					
+				#if defined (CONFIG_RTL_92D_SUPPORT)
+				dev = __dev_get_by_name(&init_net, RTL_PS_WLAN1_DEV_NAME);	
+	
+				if (dev) {		
+					unsigned char StaMacAndGroup[20];
+					memcpy(StaMacAndGroup, DA , 6);
+					memcpy(StaMacAndGroup+6, SA, 6);
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (dev->do_ioctl != NULL) {
+						dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#else
+					if (dev->netdev_ops->ndo_do_ioctl != NULL) {
+						dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#endif
+						DEBUG_PRINT("(fdb expire) wlan0 ioctl to DEL! M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+							StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+							StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+					}
+				}
+				#endif
+				#endif			
+				/*---for process wlan client expired end---*/
+
+			
+				del_igmp_ext_entry(ent , SA , ent->igmp_fdb_arr[i2].port);
+
+	
+				if ( (ent->portlist & 0x7f)==0){
+					ent->group_src &=  ~(1 << 1); // eth0 all leave
+				}
+			
+				if ( (ent->portlist & 0x80)==0){
+					ent->group_src &=  ~(1 << 2); // wlan0 all leave
+				}
+			
+			
+			}			
+			
+		}		
+		
+	}		
+	
+}
+#endif
+
 void br_fdb_cleanup(unsigned long _data)
 {
 	struct net_bridge *br = (struct net_bridge *)_data;
+#if 0
+#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2)
+	int32 port_num;
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	unsigned char swap_addr[ETHER_ADDR_LEN];
+#endif
+	int ret;
+	unsigned long hw_aging;
+#endif
+#endif
 	unsigned long delay = hold_time(br);
 	unsigned long next_timer = jiffies + br->forward_delay;
 	int i;
@@ -130,14 +275,48 @@ void br_fdb_cleanup(unsigned long _data)
 
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
 			unsigned long this_timer;
+			
+			#if defined	(CONFIG_RTL_IGMP_SNOOPING)
+			if(	f->is_static &&
+				f->igmpFlag &&
+				MULTICAST_MAC(f->addr.addr))
+			{
+										
+				br_igmp_fdb_expired(f);
+				
+				if(time_before_eq(f->ageing_timer +300*HZ,  jiffies))
+				{
+					DEBUG_PRINT("fdb_delete:f->addr.addr is 0x%02x:%02x:%02x-%02x:%02x:%02x\n",
+					f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5]);	
+					fdb_delete(f);
+				}
+			
+			}
+			#endif
+
 			if (f->is_static)
 				continue;
-			this_timer = f->ageing_timer + delay;
+			
+			#if defined(CONFIG_RTL_819X)
+				rtl_br_fdb_cleanup_hooks(br,f, delay);
+			#endif
+			this_timer = f->ageing_timer+delay;
+			
 			if (time_before_eq(this_timer, jiffies))
+			{
 				fdb_delete(f);
+				/*delete  an  FDB Entry   */
+			} 
 			else if (time_before(this_timer, next_timer))
+			{
 				next_timer = this_timer;
 		}
+			else
+			{
+				//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
+			}
+
+		} //end hlist_for_each_entry_safe
 	}
 	spin_unlock_bh(&br->hash_lock);
 
@@ -156,10 +337,26 @@ void br_fdb_flush(struct net_bridge *br)
 		struct net_bridge_fdb_entry *f;
 		struct hlist_node *h, *n;
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
+		#if defined (CONFIG_RTL_IGMP_SNOOPING)
+			if(	f->is_static && 
+				f->igmpFlag &&
+				MULTICAST_MAC(f->addr.addr) )
+			{
+				br_igmp_fdb_expired(f);
+				if(time_before_eq(f->ageing_timer + 300*HZ,  jiffies))
+				{
+					//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
+					fdb_delete(f);
+				}
+			}
+		#endif
 			if (!f->is_static)
+				{
+					//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 				fdb_delete(f);
 		}
 	}
+	}
 	spin_unlock_bh(&br->hash_lock);
 }
 
@@ -200,7 +397,7 @@ void br_fdb_delete_by_port(struct net_br
 					}
 				}
 			}
-
+			//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 			fdb_delete(f);
 		skip_delete: ;
 		}
@@ -217,8 +414,15 @@ struct net_bridge_fdb_entry *__br_fdb_ge
 
 	hlist_for_each_entry_rcu(fdb, h, &br->hash[br_mac_hash(addr)], hlist) {
 		if (!compare_ether_addr(fdb->addr.addr, addr)) {
-			if (unlikely(has_expired(br, fdb)))
+			if (unlikely(has_expired(br, fdb))) {
+			#if defined(CONFIG_RTL_819X)
+				if (rtl___br_fdb_get_timeout_hooks(br, fdb, addr)==RTL_PS_HOOKS_BREAK) {
+					break;
+				}
+			#else
 				break;
+			#endif
+			}
 			return fdb;
 		}
 	}
@@ -240,18 +444,51 @@ struct net_bridge_fdb_entry *br_fdb_get(
 	return fdb;
 }
 
-static void fdb_rcu_free(struct rcu_head *head)
+/*static void fdb_rcu_free(struct rcu_head *head)
 {
 	struct net_bridge_fdb_entry *ent
 		= container_of(head, struct net_bridge_fdb_entry, rcu);
 	kmem_cache_free(br_fdb_cache, ent);
+#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(f);
+	fdb_entry_num--;
+	if(fdb_entry_num < 0)
+	{
+		printk("fdb entry num error!!!!\n");
+		fdb_entry_num = 0;
+	}
+#endif
+}*/
+
+static void fdb_rcu_free(struct rcu_head *head)
+{
+struct net_bridge_fdb_entry *ent
+		= container_of(head, struct net_bridge_fdb_entry, rcu);	
+	kmem_cache_free(br_fdb_cache, ent);
+#if defined(CONFIG_RTL_819X)
+	#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(ent);
+	#endif
+	fdb_entry_num--;
+	if(fdb_entry_num < 0)
+	{
+		printk("fdb entry num error!!!!\n");
+		fdb_entry_num = 0;
+	}
+	/*printk("fdb_entry_num:%d\n",fdb_entry_num);*/
+#endif
 }
 
 /* Set entry up for deletion with RCU  */
 void br_fdb_put(struct net_bridge_fdb_entry *ent)
 {
-	if (atomic_dec_and_test(&ent->use_count))
+	
+	if (atomic_dec_and_test(&ent->use_count)) {
+
 		call_rcu(&ent->rcu, fdb_rcu_free);
+		//rtl_fdb_delete_hooks(ent);
+	
+	}
 }
 
 /*
@@ -323,17 +560,44 @@ static struct net_bridge_fdb_entry *fdb_
 {
 	struct net_bridge_fdb_entry *fdb;
 
+#if defined(CONFIG_RTL_819X)
+	if(fdb_entry_num >= fdb_entry_max)
+		return NULL;
+#endif
+	int i3;
+
 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
-	if (fdb) {
+	if (fdb) 
+	{
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
 		atomic_set(&fdb->use_count, 1);
+		#if defined(CONFIG_RTL_819X)
+			fdb_entry_num++;
+		#endif
 		hlist_add_head_rcu(&fdb->hlist, head);
 
 		fdb->dst = source;
 		fdb->is_local = is_local;
 		fdb->is_static = is_local;
 		fdb->ageing_timer = jiffies;
+		
+		#if defined (CONFIG_RTL_IGMP_SNOOPING)
+		
+		fdb->group_src = 0;
+		fdb->igmpFlag=0;
+		for(i3=0 ; i3<FDB_IGMP_EXT_NUM ;i3++)
+		{
+			fdb->igmp_fdb_arr[i3].valid = 0;
+			fdb->portUsedNum[i3] = 0;		
+		}
+		#endif
+		
+		#if defined(CONFIG_RTL_819X)
+		rtl_fdb_create_hooks(fdb, addr);		
+		#endif
+		
 	}
+	
 	return fdb;
 }
 
@@ -342,10 +606,16 @@ static int fdb_insert(struct net_bridge
 {
 	struct hlist_head *head = &br->hash[br_mac_hash(addr)];
 	struct net_bridge_fdb_entry *fdb;
-
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+	if(((addr[0]==0xff) && (addr[1]==0xff) && (addr[2]==0xff) && (addr[3]==0xff) && (addr[4]==0xff) && (addr[5]==0xff))||
+		((addr[0]==0) && (addr[1]==0) && (addr[2]==0) && (addr[3]==0) && (addr[4]==0) && (addr[5]==0)))
+	{
+		return -EINVAL;
+	}
+#else	
 	if (!is_valid_ether_addr(addr))
 		return -EINVAL;
-
+#endif
 	fdb = fdb_find(head, addr);
 	if (fdb) {
 		/* it is okay to have multiple ports with same
@@ -357,6 +627,7 @@ static int fdb_insert(struct net_bridge
 		printk(KERN_WARNING "%s adding interface with same address "
 		       "as a received packet\n",
 		       source->dev->name);
+		//printk("[%s][%d].\n", __FUNCTION__, __LINE__);
 		fdb_delete(fdb);
 	}
 
@@ -393,15 +664,66 @@ void br_fdb_update(struct net_bridge *br
 		return;
 
 	fdb = fdb_find(head, addr);
-	if (likely(fdb)) {
+	if (likely(fdb)) 
+	{
+		
 		/* attempt to update an entry for a local interface */
-		if (unlikely(fdb->is_local)) {
+		if (unlikely(fdb->is_local)) 
+		{
 			if (net_ratelimit())
 				printk(KERN_WARNING "%s: received packet with "
 				       " own address as source address\n",
 				       source->dev->name);
-		} else {
+		} 
+		else 
+		{
 			/* fastpath: update of existing entry */
+			/* 02-17-2012: move to WLAN driver update_fwtbl_asoclst() to avoid hacking the Linux kernel or the other kernel */
+#if 0 //defined (CONFIG_RTL865X_ETH)
+//                       if (((unsigned long)fdb->dst) != ((unsigned long)source->br->dev->a)) { 
+			if (fdb->dst != source)
+			{	
+				update_hw_l2table(source->dev->name, addr);
+			}
+#endif			
+
+			if (fdb->dst != source) {
+				//panic_printk("mac addr: 0x%02x%02x%02x%02x%02x%02x -- port no: %d, new: %d\n",
+				//	fdb->addr.addr[0], fdb->addr.addr[1],  fdb->addr.addr[2], fdb->addr.addr[3], fdb->addr.addr[4], 
+				//	fdb->addr.addr[5], fdb->dst->port_no, source->port_no);
+
+				if (!memcmp(fdb->dst->dev->name, "wlan", 4)) {
+					// del sta
+					struct iwreq wrq;
+					unsigned char para[32];
+
+					memset(para, 0, 32);
+					sprintf(para, "%02x%02x%02x%02x%02x%02xno", fdb->addr.addr[0], fdb->addr.addr[1],  
+						fdb->addr.addr[2], fdb->addr.addr[3], fdb->addr.addr[4], fdb->addr.addr[5]);
+	                wrq.u.data.pointer = para;
+	                wrq.u.data.length = strlen(para);
+#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (fdb->dst->dev->do_ioctl != NULL)
+						fdb->dst->dev->do_ioctl(fdb->dst->dev, (struct ifreq *)&wrq, 0x89f7/* RTL8185_IOCTL_DEL_STA */);
+#else
+					if (fdb->dst->dev->netdev_ops->ndo_do_ioctl != NULL)
+						fdb->dst->dev->netdev_ops->ndo_do_ioctl(fdb->dst->dev, (struct ifreq *)&wrq, 0x89f7/* RTL8185_IOCTL_DEL_STA */);
+#endif
+				}
+				else if (!memcmp(fdb->dst->dev->name, "eth", 3)) {
+					struct ifreq frq;
+
+					memset(&frq, 0, sizeof(struct ifreq));
+#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (fdb->dst->dev->do_ioctl != NULL)
+						fdb->dst->dev->do_ioctl(fdb->dst->dev, &frq, 2210);
+#else
+					if (fdb->dst->dev->netdev_ops->ndo_do_ioctl != NULL)
+						fdb->dst->dev->netdev_ops->ndo_do_ioctl(fdb->dst->dev, &frq, 2210);
+#endif
+				}
+			}
+
 			fdb->dst = source;
 			fdb->ageing_timer = jiffies;
 		}
@@ -415,3 +737,266 @@ void br_fdb_update(struct net_bridge *br
 		spin_unlock(&br->hash_lock);
 	}
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int chk_igmp_ext_entry(
+	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac)
+{
+
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;
+
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6)){
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+extern int bitmask_to_id(unsigned char val);
+
+void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac , unsigned char portComeIn)
+{
+
+//	if(fdb->igmp_ext_array == NULL)
+//		return 0;
+
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+	DEBUG_PRINT("add_igmp,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		add[0],add[1],add[2],add[3],add[4],add[5],
+		srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+	
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 0){
+			fdb->igmp_fdb_arr[i2].valid = 1	;
+			fdb->igmp_fdb_arr[i2].ageing_time = jiffies ;			
+			memcpy(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6);
+			fdb->igmp_fdb_arr[i2].port = portComeIn ;
+			fdb->portlist |= portComeIn;
+			fdb->portUsedNum[bitmask_to_id(portComeIn)]++;
+			DEBUG_PRINT("portUsedNum[%d]=%d\n\n",bitmask_to_id(portComeIn) , fdb->portUsedNum[bitmask_to_id(portComeIn)]);
+			return ;
+		}
+	}
+	DEBUG_PRINT("%s:entry Rdy existed!!!\n", __FUNCTION__);	
+}
+
+void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac , unsigned char portComeIn)
+{
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+		DEBUG_PRINT("update_igmp,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		add[0],add[1],add[2],add[3],add[4],add[5],
+		srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6)){
+
+				fdb->igmp_fdb_arr[i2].ageing_time = jiffies ;
+				//DEBUG_PRINT("update jiffies ok!\n");
+				if(fdb->igmp_fdb_arr[i2].port != portComeIn){
+
+					unsigned char port_orig = fdb->igmp_fdb_arr[i2].port ;					
+					int index = bitmask_to_id(port_orig);
+
+					fdb->portUsedNum[index]-- ;
+					DEBUG_PRINT("(--) portUsedNum[%d]=%d\n",index , fdb->portUsedNum[index] );					
+					if(fdb->portUsedNum[index] <= 0){
+						fdb->portlist &= ~(port_orig);
+						if(fdb->portUsedNum[index]< 0){
+							DEBUG_PRINT("!! portNum[%d] < 0 at (update_igmp_ext_entry)\n",index);
+							fdb->portUsedNum[index] = 0 ;
+						}
+					}					
+
+					
+					fdb->portUsedNum[bitmask_to_id(portComeIn)]++;
+					DEBUG_PRINT("(++) portUsedNum[%d]=%d\n",bitmask_to_id(portComeIn) , fdb->portUsedNum[bitmask_to_id(portComeIn)] );										
+					fdb->portlist |= portComeIn;						
+
+					
+					fdb->igmp_fdb_arr[i2].port = portComeIn ;					
+					DEBUG_PRINT("	!!! portlist be updated:%x !!!!\n",fdb->portlist);
+					
+				}
+				return ;
+			}			
+		}		
+	}
+
+	DEBUG_PRINT("%s: ...fail!!\n", __FUNCTION__);
+}
+
+
+void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn )
+{
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+
+				
+
+	
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6))
+			{
+				fdb->igmp_fdb_arr[i2].ageing_time -=  300*HZ; // make it expired	
+				fdb->igmp_fdb_arr[i2].valid = 0;
+				DEBUG_PRINT("\ndel_igmp_ext_entry,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x success!!!\n",
+				add[0],add[1],add[2],add[3],add[4],add[5],
+				srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+				
+				//DEBUG_PRINT("%s:success!!\n", __FUNCTION__);
+				
+				if(portComeIn != 0){
+					int index;
+					index = bitmask_to_id(portComeIn);
+					fdb->portUsedNum[index]--;
+					if(fdb->portUsedNum[index] <= 0){
+						DEBUG_PRINT("portUsedNum[%d] == 0 ,update portlist from (%x)  " ,index ,fdb->portlist);
+						fdb->portlist &= ~ portComeIn;
+						DEBUG_PRINT("to (%x) \n" ,fdb->portlist);
+						
+						if(fdb->portUsedNum[index] < 0){
+						DEBUG_PRINT("!! portUsedNum[%d]=%d < 0 at (del_igmp_ext_entry)  \n" ,index ,fdb->portUsedNum[index]);
+						fdb->portUsedNum[index] = 0;
+						}
+					}else{
+						DEBUG_PRINT("(del) portUsedNum[%d] = %d \n" ,index, fdb->portUsedNum[index]);
+					}
+				
+				}	
+				DEBUG_PRINT("\n");
+				return ;
+			}			
+		}
+	}
+
+	DEBUG_PRINT("%s:entry not existed!!\n\n", __FUNCTION__);	
+}
+
+
+
+
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+int rtl865x_checkMacAddrLocation(unsigned char *addr, unsigned int *isElanMac, unsigned int *isWlanMac)
+{
+	struct net_device *brDev;
+	struct net_bridge *br;
+	struct net_bridge_fdb_entry *fdb;
+
+	if((addr==NULL) || (isElanMac==NULL) || (isWlanMac==NULL))
+	{
+		return -1;
+	}
+
+	*isElanMac=0;
+	*isWlanMac=0;
+
+	brDev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+      	if ( brDev== NULL)
+	{
+		return -1;
+	}
+
+	if (!(brDev->priv_flags & IFF_EBRIDGE))
+	{
+		
+		return -1;
+	}
+	else 
+	{
+		br = (struct net_bridge *)netdev_priv(brDev);
+	}
+	
+	
+	fdb=__br_fdb_get(br, addr);
+
+	if(fdb==NULL)
+	{
+		return -1;
+	}
+	
+	if(strncmp(fdb->dst->dev->name, RTL_PS_ETH_NAME,3)==0)
+	{
+		*isElanMac=1;
+		
+	}
+	else if(strncmp(fdb->dst->dev->name, RTL_PS_WLAN_NAME,4)==0)
+	{
+		*isWlanMac=1;
+	}	
+	else
+	{
+		return -1;
+	}
+
+	return 0;
+	
+}
+#endif
+
+#ifdef CONFIG_RTL865X_LANPORT_RESTRICTION
+int rtl_delFdbByMac(const unsigned char *macAddr, const char* devName)
+{
+	int i;
+	struct net_bridge_port *p;
+	struct net_device *dev;
+	struct net_bridge *br;
+
+	if((macAddr==NULL) ||(devName ==NULL) )
+		return FAILED;
+
+	dev = __dev_get_by_name(&init_net, devName);
+
+	if(dev->br_port == NULL)
+		return FAILED;
+	
+	p = dev->br_port;
+
+	if(p->br == NULL)
+		return FAILED;
+
+	br = p->br;
+
+	spin_lock_bh(&br->hash_lock);
+
+	for (i = 0; i < BR_HASH_SIZE; i++) {
+		struct net_bridge_fdb_entry *f;
+		struct hlist_node *h, *n;
+
+		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
+			if(f->is_static)
+				continue;
+
+			if (!compare_ether_addr(f->addr.addr, macAddr)){
+				fdb_delete(f);
+				spin_unlock_bh(&br->hash_lock);
+				return SUCCESS;
+			}
+		}
+	}
+	
+	spin_unlock_bh(&br->hash_lock);
+	return FAILED;
+}		
+#endif
+
+
--- linux-2.6.30.9/net/bridge/br_forward.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_forward.c	2013-05-02 01:47:59.218226614 +0300
@@ -17,12 +17,71 @@
 #include <linux/if_vlan.h>
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/ip.h>
+#include <linux/in.h>
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#endif
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+extern int igmpsnoopenabled;
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int br0SwFwdPortMask;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int mldSnoopEnabled;
+#endif
+#endif
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+extern unsigned int brIgmpModuleIndex_2;
+extern unsigned int br1SwFwdPortMask;
+extern struct net_bridge *bridge1;
+#endif
+
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+#include <net/rtl/features/rtl_ps_log.h>
+
 
 /* Don't forward packets to originating port or forwarding diasabled */
 static inline int should_deliver(const struct net_bridge_port *p,
 				 const struct sk_buff *skb)
 {
-	return (skb->dev != p->dev && p->state == BR_STATE_FORWARDING);
+	if (skb->dev == p->dev ||
+	    p->state != BR_STATE_FORWARDING)
+		return 0;
+
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		if (skb->src_info) {
+			struct vlan_info_item *pitem = rtl_get_vlan_info_item_by_dev(p->dev);
+
+			/* index == 1, it means skb is cloned skb in rx_vlan_process */
+			if (skb->src_info->index) {
+				if (pitem && pitem->info.forwarding_rule!=1)
+					return 0;
+			}
+
+			/* vlan_br can't send packet to vlan_nat */
+			if (skb->src_info->forwarding_rule==1) {
+				if (pitem && pitem->info.forwarding_rule==2)
+					return 0;
+			}
+
+			/* vlan_nat can't send packet to vlan_br */
+			if (skb->src_info->forwarding_rule==2) {
+				if (pitem && pitem->info.forwarding_rule==1)
+					return 0;
+			}
+		}
+#endif
+	return 1;
 }
 
 static inline unsigned packet_length(const struct sk_buff *skb)
@@ -41,7 +100,9 @@ int br_dev_queue_push_xmit(struct sk_buf
 			kfree_skb(skb);
 		else {
 			skb_push(skb, ETH_HLEN);
-
+			#if	defined(CONFIG_RTL_819X)
+			rtl_br_dev_queue_push_xmit_before_xmit_hooks(skb);
+			#endif
 			dev_queue_xmit(skb);
 		}
 	}
@@ -102,6 +163,27 @@ void br_forward(const struct net_bridge_
 	kfree_skb(skb);
 }
 
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+#define ETH_P_RTK_NOTIFY 0x9000 //mark_issue
+#define ETH_P_RTK_NOTIFY1 0x9001
+#define ETH_P_RTK		0x8899	// Realtek Remote Control Protocol (RRCP)
+#define LOCAL_INBAND_IF1 "eth1"
+#define LOCAL_INBAND_IF0 "eth0"
+
+static inline int inband_deliver_check(struct net_bridge_port *p, struct sk_buff *skb)
+{
+	struct ethhdr *eth_hdr_p;
+	eth_hdr_p = eth_hdr(skb);
+
+	if(eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY || eth_hdr_p->h_proto == ETH_P_RTK
+							  || eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY1 )
+		if(memcmp(p->dev->name,LOCAL_INBAND_IF1,4) && memcmp(p->dev->name,LOCAL_INBAND_IF0,4) ) //not foward if not eth1 or eth0
+			return 0;
+	return 1;
+
+}
+#endif
+
 /* called under bridge lock */
 static void br_flood(struct net_bridge *br, struct sk_buff *skb,
 	void (*__packet_hook)(const struct net_bridge_port *p,
@@ -109,15 +191,39 @@ static void br_flood(struct net_bridge *
 {
 	struct net_bridge_port *p;
 	struct net_bridge_port *prev;
-
+	const unsigned char *dest = eth_hdr(skb)->h_dest;
 	prev = NULL;
 
 	list_for_each_entry_rcu(p, &br->port_list, list) {
+#ifndef CONFIG_RTK_INBAND_HOST_HACK
 		if (should_deliver(p, skb)) {
+#else
+		if ((should_deliver(p, skb)) && (inband_deliver_check(p, skb))) {
+#endif
+			/*patch for wan/lan receive duplicate unknown unicast/broadcast packet when pppoe/ipv6 passthrough enable*/
+			/*except the packet dmac=33:33:xx:xx:xx:xx*/
+			if((strcmp(skb->dev->name,"peth0")==0)&&(!(dest[0]==0x33&&dest[1]==0x33)))
+			{
+				 if((strncmp(p->dev->name,"eth",3)==0))
+				 {
+					continue;
+				 }
+			}
+
+			/*patch for lan->wan duplicat packet(dmac=33:33:ff:xx:xx:xx) when pppoe/ipv6 passthrough enable*/
+			if((strcmp(skb->dev->name,"eth0")==0)&&((dest[0]==0x33&&dest[1]==0x33&&dest[2]==0xff)))
+			{
+				 if((strncmp(p->dev->name,"peth0",5)==0))
+				 {
+					continue;
+				 }
+			}
+
 			if (prev != NULL) {
 				struct sk_buff *skb2;
 
 				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+					LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
 					br->dev->stats.tx_dropped++;
 					kfree_skb(skb);
 					return;
@@ -150,3 +256,543 @@ void br_flood_forward(struct net_bridge
 {
 	br_flood(br, skb, __br_forward);
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int bitmask_to_id(unsigned char val)
+{
+	int i;
+	for (i=0; i<8; i++) {
+		if (val & (1 <<i))
+			break;
+	}
+
+	if(i>=8)
+	{
+		i=7;
+	}
+	return (i);
+}
+
+static void br_multicast(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone,
+		  void (*__packet_hook)(const struct net_bridge_port *p, struct sk_buff *skb))
+{
+//	char i;
+	struct net_bridge_port *prev;
+	struct net_bridge_port *p, *n;
+	unsigned short port_bitmask=0;
+        if (clone) {
+                struct sk_buff *skb2;
+
+                if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+			LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
+                        br->dev->stats.tx_dropped++;
+                        return;
+                }
+
+                skb = skb2;
+        }
+
+	prev = NULL;
+
+	list_for_each_entry_safe(p, n, &br->port_list, list) {
+		port_bitmask = (1 << p->port_no);
+                if ((port_bitmask & fwdPortMask) && should_deliver(p, skb)) {
+                        if (prev != NULL) {
+                                struct sk_buff *skb2;
+
+                                if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+					LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
+                                        br->dev->stats.tx_dropped++;
+                                        kfree_skb(skb);
+                                        return;
+                                }
+
+                                __packet_hook(prev, skb2);
+                        }
+
+                        prev = p;
+                }
+	}
+
+        if (prev != NULL) {
+                __packet_hook(prev, skb);
+                return;
+        }
+
+	kfree_skb(skb);
+}
+
+void br_multicast_deliver(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone)
+{
+	br_multicast(br, fwdPortMask, skb, clone, __br_deliver);
+}
+void br_multicast_forward(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone)
+{
+	br_multicast(br, fwdPortMask, skb, clone, __br_forward);
+}
+
+extern struct net_bridge *bridge0;
+extern int ipMulticastFastFwd;
+extern int needCheckMfc;
+#if defined (CONFIG_IP_MROUTE)
+#if defined (CONFIG_RTL_IGMP_PROXY)
+extern int rtl865x_checkMfcCache(struct net *net,struct net_device *dev,__be32 origin,__be32 mcastgrp);
+#endif
+#endif
+
+#if defined(CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+
+extern int rtl865x_blockMulticastFlow(unsigned int srcVlanId, unsigned int srcPort,unsigned int srcIpAddr, unsigned int destIpAddr);
+extern int rtl865x_curOpMode;
+
+#define MAX_UNKNOWN_MULTICAST_NUM 16
+#define MAX_UNKNOWN_MULTICAST_PPS 1500
+#define BLOCK_UNKNOWN_MULTICAST 1
+
+struct rtl865x_unKnownMCastRecord
+{
+	unsigned int groupAddr;
+	unsigned long lastJiffies;
+	unsigned long pktCnt;
+	unsigned int valid;
+};
+struct rtl865x_unKnownMCastRecord unKnownMCastRecord[MAX_UNKNOWN_MULTICAST_NUM];
+
+int rtl865x_checkUnknownMCastLoading(struct rtl_multicastDataInfo *mCastInfo)
+{
+	int i;
+	if(mCastInfo==NULL)
+	{
+		return 0;
+	}
+	/*check entry existed or not*/
+	for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+	{
+		if((unKnownMCastRecord[i].valid==1) && (unKnownMCastRecord[i].groupAddr==mCastInfo->groupAddr[0]))
+		{
+			break;
+		}
+	}
+
+	/*find an empty one*/
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+		{
+			if(unKnownMCastRecord[i].valid!=1)
+			{
+				break;
+			}
+		}
+	}
+
+	/*find an exipired one */
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		for(i=0; i<MAX_UNKNOWN_MULTICAST_NUM; i++)
+		{
+			if(	time_before(unKnownMCastRecord[i].lastJiffies+HZ,jiffies)
+				|| time_after(unKnownMCastRecord[i].lastJiffies,jiffies+HZ)	)
+			{
+		
+				break;
+			}
+		}
+	}
+
+	if(i==MAX_UNKNOWN_MULTICAST_NUM)
+	{
+		return 0;
+	}
+
+	unKnownMCastRecord[i].groupAddr=mCastInfo->groupAddr[0];
+	unKnownMCastRecord[i].valid=1;
+	
+	if(time_after(unKnownMCastRecord[i].lastJiffies+HZ,jiffies))
+	{
+		unKnownMCastRecord[i].pktCnt++;
+	}
+	else
+	{
+		unKnownMCastRecord[i].lastJiffies=jiffies;
+		unKnownMCastRecord[i].pktCnt=0;
+	}
+
+	if(unKnownMCastRecord[i].pktCnt>MAX_UNKNOWN_MULTICAST_PPS)
+	{
+		return BLOCK_UNKNOWN_MULTICAST;
+	}
+
+	return 0;
+}
+int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
+{
+	const unsigned char *dest = NULL;
+	unsigned char *ptr;
+	struct iphdr *iph=NULL;
+	unsigned char proto=0;
+	unsigned char reserved=0;
+	int ret=-1;
+
+	struct net_bridge_port *prev;
+	struct net_bridge_port *p, *n;
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	struct sk_buff *skb2;
+
+	unsigned short port_bitmask=0;
+	#if defined (CONFIG_RTL_MLD_SNOOPING)
+	struct ipv6hdr * ipv6h=NULL;
+	#endif
+	unsigned int fwdCnt;
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+	struct net_device *dev=skb->dev;
+#endif
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	struct net_bridge *bridge = bridge0;
+	unsigned int brSwFwdPortMask = br0SwFwdPortMask;
+#endif	
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	unsigned int srcPort=skb->srcPort;
+	unsigned int srcVlanId=skb->srcVlanId;
+#endif
+	/*check fast forward enable or not*/
+	if(ipMulticastFastFwd==0)
+	{
+		return -1;
+	}
+
+	/*check dmac is multicast or not*/
+	dest=eth_hdr(skb)->h_dest;
+	if((dest[0]&0x01)==0)
+	{
+		return -1;
+	}
+
+	//printk("%s:%d,dest is 0x%x-%x-%x-%x-%x-%x\n",__FUNCTION__,__LINE__,dest[0],dest[1],dest[2],dest[3],dest[4],dest[5]);
+	if(igmpsnoopenabled==0)
+	{
+		return -1;
+	}
+
+	/*check bridge0 exist or not*/
+	if((bridge0==NULL) ||(bridge0->dev->flags & IFF_PROMISC))
+	{
+		return -1;
+	}
+
+	if((skb->dev==NULL) ||(strncmp(skb->dev->name,RTL_PS_BR0_DEV_NAME,3)==0))
+	{
+		return -1;
+	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if((strncmp(skb->dev->name,RTL_PS_BR1_DEV_NAME,3)==0))
+	{
+		return -1;
+	}
+	#endif
+
+	/*check igmp snooping enable or not, and check dmac is ipv4 multicast mac or not*/
+	if  ((dest[0]==0x01) && (dest[1]==0x00) && (dest[2]==0x5e))
+	{
+		//printk("%s:%d,skb->dev->name is %s\n",__FUNCTION__,__LINE__,skb->dev->name );
+		ptr=(unsigned char *)eth_hdr(skb)+12;
+		/*check vlan tag exist or not*/
+		if(*(int16 *)(ptr)==(int16)htons(0x8100))
+		{
+			ptr=ptr+4;
+		}
+
+		/*check it's ipv4 packet or not*/
+		if(*(int16 *)(ptr)!=(int16)htons(ETH_P_IP))
+		{
+			return -1;
+		}
+
+		iph=(struct iphdr *)(ptr+2);
+
+		if(iph->daddr== 0xEFFFFFFA)
+		{
+			/*for microsoft upnp*/
+			reserved=1;
+		}
+
+		/*only speed up udp and tcp*/
+		proto =  iph->protocol;
+		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
+		 if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP)) && (reserved ==0))
+		{
+
+			#if defined (CONFIG_IP_MROUTE)
+			/*multicast data comes from wan, need check multicast forwardig cache*/
+			if((strncmp(skb->dev->name,RTL_PS_WAN0_DEV_NAME,4)==0) && needCheckMfc )
+			{
+				#if	defined (CONFIG_RTL_IGMP_PROXY)
+				if(rtl865x_checkMfcCache(&init_net,dev,iph->saddr,iph->daddr)!=0)
+				#endif	
+				{
+					if(rtl865x_checkUnknownMCastLoading(&multicastDataInfo)==BLOCK_UNKNOWN_MULTICAST)
+					{
+#if defined( CONFIG_RTL865X_HARDWARE_MULTICAST) || defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+						if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+						{
+							rtl865x_blockMulticastFlow(srcVlanId, srcPort, iph->saddr,iph->daddr);
+						}
+						else
+#endif
+						{
+							kfree_skb(skb);
+							return 0;
+						}
+					}
+				
+					return -1;
+				}
+			}
+			#endif
+
+			multicastDataInfo.ipVersion=4;
+			multicastDataInfo.sourceIp[0]=  (unsigned int)(iph->saddr);
+			multicastDataInfo.groupAddr[0]=  (unsigned int)(iph->daddr);
+
+            #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT //fix tim
+			if(!strcmp(skb->dev->name,RTL_PS_ETH_NAME_ETH2)){
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex_2, &multicastDataInfo, &multicastFwdInfo);
+					bridge = bridge1;
+					brSwFwdPortMask = br1SwFwdPortMask;
+			}
+			else
+		    #endif
+			ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+
+			//printk("%s:%d,ret is %d\n",__FUNCTION__,__LINE__,ret);
+			 if((ret!=0)||multicastFwdInfo.reservedMCast || multicastFwdInfo.unknownMCast)
+			{
+				if( multicastFwdInfo.unknownMCast && 
+					(strncmp(skb->dev->name,RTL_PS_WAN0_DEV_NAME,4)==0) && 		//only block heavyloading multicast data from wan
+					(rtl865x_checkUnknownMCastLoading(&multicastDataInfo)==BLOCK_UNKNOWN_MULTICAST))
+				{
+#if defined( CONFIG_RTL865X_HARDWARE_MULTICAST) || defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+					if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+					{
+						rtl865x_blockMulticastFlow(srcVlanId, srcPort, iph->saddr,iph->daddr);
+					}
+					else
+#endif
+					{
+						kfree_skb(skb);
+						return 0;
+					}
+				}
+				return -1;
+			}
+
+
+			//printk("%s:%d,br0SwFwdPortMask is 0x%x,multicastFwdInfo.fwdPortMask is 0x%x\n",__FUNCTION__,__LINE__,br0SwFwdPortMask,multicastFwdInfo.fwdPortMask);
+			#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+			if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+			{
+				/*multicast data comes from ethernet port*/
+				#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if( (brSwFwdPortMask & multicastFwdInfo.fwdPortMask)==0)
+				#else
+				if( (br0SwFwdPortMask & multicastFwdInfo.fwdPortMask)==0)
+				#endif
+				{
+					/*hardware forwarding ,let slow path handle packets trapped to cpu*/
+					return -1;
+				}
+			}
+			#endif
+
+			skb_push(skb, ETH_HLEN);
+
+			prev = NULL;
+			fwdCnt=0;
+
+        #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+			list_for_each_entry_safe(p, n, &bridge->port_list, list) 
+		#else
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list)
+		#endif
+			{
+				port_bitmask = (1 << p->port_no);
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && should_deliver(p, skb)) 
+				{
+					if (prev != NULL)
+					{
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
+						{
+							LOG_MEM_ERROR("%s(%d) skb clone failed, drop it\n", __FUNCTION__, __LINE__);
+                            #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+							bridge->dev->stats.tx_dropped++;
+			    			#else
+							bridge0->dev->stats.tx_dropped++;
+							#endif
+							kfree_skb(skb);
+							return 0;
+						}
+						skb2->dev=prev->dev;
+						//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+						#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+						prev->dev->hard_start_xmit(skb2, prev->dev);
+						#else
+						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+						#endif
+						fwdCnt++;
+					}
+
+					prev = p;
+				}
+			}
+
+			if (prev != NULL)
+			{
+				skb->dev=prev->dev;
+				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+			       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+				#endif
+				fwdCnt++;
+			}
+
+			if(fwdCnt==0)
+			{
+				/*avoid memory leak*/
+				skb_pull(skb, ETH_HLEN);
+				return -1;
+			}
+
+			return 0;
+
+		}
+
+	}
+
+#if 0 //defined (CONFIG_RTL_MLD_SNOOPING)
+	/*check igmp snooping enable or not, and check dmac is ipv4 multicast mac or not*/
+	if  ((dest[0]==0x33) && (dest[1]==0x33) && (dest[2]!=0xff))
+	{
+		struct net_bridge_port *p;
+		if(mldSnoopEnabled==0)
+		{
+			return -1;
+		}
+
+		/*due to ipv6 passthrough*/
+		p= rcu_dereference(skb->dev->br_port);
+		if(p==NULL)
+		{
+			return -1;
+		}
+
+		//printk("%s:%d,skb->dev->name is %s\n",__FUNCTION__,__LINE__,skb->dev->name );
+		ptr=(unsigned char *)eth_hdr(skb)+12;
+		/*check vlan tag exist or not*/
+		if(*(int16 *)(ptr)==(int16)htons(0x8100))
+		{
+			ptr=ptr+4;
+		}
+
+		/*check it's ipv6 packet or not*/
+		if(*(int16 *)(ptr)!=(int16)htons(ETH_P_IPV6))
+		{
+			return -1;
+		}
+
+		ipv6h=(struct ipv6hdr *)(ptr+2);
+		proto =  re865x_getIpv6TransportProtocol(ipv6h);
+
+		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
+		 if((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+		{
+			multicastDataInfo.ipVersion=6;
+			memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+			memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));
+			/*
+			printk("%s:%d,sourceIp is %x-%x-%x-%x\n",__FUNCTION__,__LINE__,
+				multicastDataInfo.sourceIp[0],multicastDataInfo.sourceIp[1],multicastDataInfo.sourceIp[2],multicastDataInfo.sourceIp[3]);
+			printk("%s:%d,groupAddr is %x-%x-%x-%x\n",__FUNCTION__,__LINE__,
+				multicastDataInfo.groupAddr[0],multicastDataInfo.groupAddr[1],multicastDataInfo.groupAddr[2],multicastDataInfo.groupAddr[3]);
+			*/
+			ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+			//printk("%s:%d,ret is %d\n",__FUNCTION__,__LINE__,ret);
+			if(ret!=0)
+			{
+				if(multicastFwdInfo.unknownMCast)
+				{
+					multicastFwdInfo.fwdPortMask=0xFFFFFFFF;
+				}
+				else
+				{
+					return -1;
+				}
+
+			}
+
+			//printk("%s:%d,multicastFwdInfo.fwdPortMask is 0x%x\n",__FUNCTION__,__LINE__,multicastFwdInfo.fwdPortMask);
+
+			skb_push(skb, ETH_HLEN);
+
+			prev = NULL;
+			fwdCnt=0;
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list)
+			{
+				port_bitmask = (1 << p->port_no);
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING))
+				{
+					if (prev != NULL)
+					{
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL)
+						{
+							kfree_skb(skb);
+							return 0;
+						}
+						skb2->dev=prev->dev;
+						//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+						#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+						prev->dev->hard_start_xmit(skb2, prev->dev);
+						#else
+						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+						#endif
+						fwdCnt++;
+					}
+
+					prev = p;
+				}
+			}
+
+			if (prev != NULL)
+			{
+				skb->dev=prev->dev;
+				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+			       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+				#endif
+				fwdCnt++;
+			}
+
+			if(fwdCnt==0)
+			{
+				//printk("%s:%d\n",__FUNCTION__,__LINE__);
+				/*avoid memory leak*/
+				skb_pull(skb, ETH_HLEN);
+				return -1;
+			}
+
+			return 0;
+		}
+
+	}
+#endif
+
+	return -1;
+}
+
+#endif
--- linux-2.6.30.9/net/bridge/br_if.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_if.c	2013-05-02 01:47:59.218226614 +0300
@@ -23,6 +23,29 @@
 
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+struct net_bridge *bridge0=NULL;
+unsigned int brIgmpModuleIndex=0xFFFFFFFF;
+unsigned int br0SwFwdPortMask=0xFFFFFFFF;
+extern void br_mCastQueryTimerExpired(unsigned long arg);
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+struct net_bridge *bridge1=NULL;
+unsigned int brIgmpModuleIndex_2=0xFFFFFFFF;
+unsigned int br1SwFwdPortMask=0xFFFFFFFF;
+#endif
+#endif
+
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtk_stp.h>
+#endif
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_generateBridgeDeviceInfo( struct net_bridge *br, rtl_multicastDeviceInfo_t *devInfo);
+#endif
 /*
  * Determine initial path cost based on speed.
  * using recommendations from 802.1d standard
@@ -58,6 +81,12 @@ static int port_cost(struct net_device *
 	return 100;	/* assume old 10Mbps */
 }
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+int br_initial_port_cost(struct net_device *dev)
+{
+	return port_cost(dev);
+}
+#endif
 
 /*
  * Check for port carrier transistions.
@@ -131,6 +160,13 @@ static void del_nbp(struct net_bridge_po
 	struct net_bridge *br = p->br;
 	struct net_device *dev = p->dev;
 
+#if 0
+#ifdef STP_DISABLE_ETH
+	//Chris: stp+mesh
+	p->disable_by_mesh = 0;
+#endif
+#endif 
+
 	sysfs_remove_link(br->ifobj, dev->name);
 
 	dev_set_promiscuity(dev, -1);
@@ -168,6 +204,32 @@ static void del_br(struct net_bridge *br
 	unregister_netdevice(br->dev);
 }
 
+#if defined (CONFIG_RTK_MESH) || defined (CONFIG_RTL_IGMP_SNOOPING)
+struct net_bridge *find_br_by_name(char *name)
+{
+	struct net_bridge *br;
+	struct net_device *dev =NULL;;
+
+	dev = __dev_get_by_name(&init_net, name);
+	if (dev == NULL) 
+	{
+		return NULL;
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		return NULL;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+	return br;
+}
+
+
+#endif
+
 static struct net_device *new_bridge_dev(struct net *net, const char *name)
 {
 	struct net_bridge *br;
@@ -199,13 +261,28 @@ static struct net_device *new_bridge_dev
 	br->root_port = 0;
 	br->bridge_max_age = br->max_age = 20 * HZ;
 	br->bridge_hello_time = br->hello_time = 2 * HZ;
+#if defined(CONFIG_RTL_819X)
+	br->bridge_forward_delay = br->forward_delay = 10 * HZ;
+#else
 	br->bridge_forward_delay = br->forward_delay = 15 * HZ;
+#endif
 	br->topology_change = 0;
 	br->topology_change_detected = 0;
 	br->ageing_time = 300 * HZ;
 
+#if defined (CONFIG_RTK_MESH)
+	br->eth0_monitor_interval = MESH_PORTAL_EXPIRE * HZ;
+	br->mesh_pathsel_pid=0;
+#if defined (STP_ADDCOST_ETH)
+	br->is_cost_changed = 0;
+#endif
+#endif
+
 	br_netfilter_rtable_init(br);
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	br->igmpProxy_pid=0;
+#endif
 	INIT_LIST_HEAD(&br->age_list);
 
 	br_stp_timer_init(br);
@@ -241,7 +318,15 @@ static struct net_bridge_port *new_nbp(s
 {
 	int index;
 	struct net_bridge_port *p;
-
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
 	index = find_portno(br);
 	if (index < 0)
 		return ERR_PTR(index);
@@ -258,11 +343,163 @@ static struct net_bridge_port *new_nbp(s
 	p->port_no = index;
 	br_init_port(p);
 	p->state = BR_STATE_DISABLED;
+
+//Chris: stp+mesh
+#if 0
+ #if defined STP_DISABLE_ETH
+	p->disable_by_mesh = 0;
+ #endif
+#endif
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port !=WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_DISABLED);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_DISABLED);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net, WLAN_IF_NAME)) == NULL)
+			{	
+				return NULL;
+			}
+			pseudo_dev->br_port->state = BR_STATE_DISABLED;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net, WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return NULL;
+			}
+			pseudo_dev->br_port->state = BR_STATE_DISABLED;
+			retval = SUCCESS;
+		}
+		#endif
+		else if(Port == NO_MAPPING)
+		{
+			p->state = BR_STATE_DISABLED;
+		}
+	}
+	
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , BR_STATE_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, BR_STATE_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 	br_stp_port_timer_init(p);
 
 	return p;
 }
 
+#if defined (CONFIG_RTK_MESH)
+/*notice:this function is different from kernel 2.4 sdk*/
+int br_set_meshpathsel_pid(int pid)
+{
+	struct net_device *dev=NULL;
+	struct net_bridge *br=NULL;
+	
+	int ret=0;
+
+	dev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+	if (dev == NULL) 
+	{
+		ret =  -ENXIO; 	/* Could not find device */
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		ret = -EPERM;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+
+	br->mesh_pathsel_pid = pid;
+
+	if( !pid )
+		br->eth0_received = 0;
+
+	printk("Receive Pathsel daemon pid:%d\n",br->mesh_pathsel_pid);
+	return 1;
+}
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int br_set_igmpProxy_pid(int pid)
+{
+	struct net_device *dev;
+	struct net_bridge *br=NULL;
+	int ret=0;
+
+	dev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+	if (dev == NULL) 
+	{
+		ret =  -ENXIO; 	/* Could not find device */
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		ret = -EPERM;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+	
+	if(br!=NULL)
+	{
+		br->igmpProxy_pid= pid;
+	}
+
+	return 1;
+}
+#endif
+
 int br_add_bridge(struct net *net, const char *name)
 {
 	struct net_device *dev;
@@ -286,6 +523,60 @@ int br_add_bridge(struct net *net, const
 	ret = br_sysfs_addbr(dev);
 	if (ret)
 		unregister_netdevice(dev);
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(strcmp(name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t devInfo;
+		memset(&devInfo, 0, sizeof(rtl_multicastDeviceInfo_t ));
+		strcpy(devInfo.devName, RTL_PS_BR0_DEV_NAME);
+		
+		ret=rtl_registerIgmpSnoopingModule(&brIgmpModuleIndex);
+		#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		if(ret==0)
+		{
+			 rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&devInfo);
+		}
+		#endif
+		bridge0=netdev_priv(dev);
+		if(bridge0!=NULL)
+		{
+			init_timer(&bridge0->mCastQuerytimer);
+			bridge0->mCastQuerytimer.data=bridge0;
+			bridge0->mCastQuerytimer.expires=jiffies+MCAST_QUERY_INTERVAL*HZ;
+			bridge0->mCastQuerytimer.function=(void*)br_mCastQueryTimerExpired;
+			add_timer(&bridge0->mCastQuerytimer);
+		}
+		
+		rtl_setIpv4UnknownMCastFloodMap(brIgmpModuleIndex, 0xFFFFFFFF);
+		rtl_setIpv6UnknownMCastFloodMap(brIgmpModuleIndex, 0xFFFFFFFF);
+	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t devInfo2;
+		memset(&devInfo2, 0, sizeof(rtl_multicastDeviceInfo_t ));
+		strcpy(devInfo2.devName, RTL_PS_BR1_DEV_NAME);
+		
+		ret=rtl_registerIgmpSnoopingModule(&brIgmpModuleIndex_2);
+		#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		if(ret==0)
+		{
+			 rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex_2,&devInfo2);
+		}
+		#endif
+		bridge1=netdev_priv(dev);
+		if(bridge1!=NULL)
+		{
+			init_timer(&bridge1->mCastQuerytimer);
+			bridge1->mCastQuerytimer.data=bridge1;
+			bridge1->mCastQuerytimer.expires=jiffies+MCAST_QUERY_INTERVAL*HZ;
+			bridge1->mCastQuerytimer.function=(void*)br_mCastQueryTimerExpired;
+			add_timer(&bridge1->mCastQuerytimer);
+		}
+	}
+#endif
+#endif
  out:
 	rtnl_unlock();
 	return ret;
@@ -318,6 +609,33 @@ int br_del_bridge(struct net *net, const
 	else
 		del_br(netdev_priv(dev));
 
+	#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(strcmp(name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_unregisterIgmpSnoopingModule(brIgmpModuleIndex);
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		if(bridge0 && timer_pending(&bridge0->mCastQuerytimer))
+		{
+			del_timer(&bridge0->mCastQuerytimer);
+		}
+		#endif
+		bridge0=NULL;
+	}
+    #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_unregisterIgmpSnoopingModule(brIgmpModuleIndex_2);
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		if(bridge1 && timer_pending(&bridge1->mCastQuerytimer))
+		{
+			del_timer(&bridge1->mCastQuerytimer);
+		}
+		#endif
+		bridge1=NULL;
+	}
+	#endif
+	#endif
+
 	rtnl_unlock();
 	return ret;
 }
@@ -420,6 +738,31 @@ int br_add_if(struct net_bridge *br, str
 
 	kobject_uevent(&p->kobj, KOBJ_ADD);
 
+	#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&brDevInfo);
+		}
+		br0SwFwdPortMask=brDevInfo.swPortMask;
+	}
+	#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex_2,&brDevInfo);
+		}
+		br1SwFwdPortMask=brDevInfo.swPortMask;
+	}
+	#endif
+	#endif
+
 	return 0;
 err2:
 	br_fdb_delete_by_port(br, p, 1);
@@ -448,6 +791,31 @@ int br_del_if(struct net_bridge *br, str
 	br_features_recompute(br);
 	spin_unlock_bh(&br->lock);
 
+	#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&brDevInfo);
+		}
+		br0SwFwdPortMask=brDevInfo.swPortMask;
+	}
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex_2,&brDevInfo);
+		}
+		br1SwFwdPortMask=brDevInfo.swPortMask;
+	}
+#endif
+	#endif
+
 	return 0;
 }
 
@@ -466,3 +834,41 @@ restart:
 	rtnl_unlock();
 
 }
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_generateBridgeDeviceInfo( struct net_bridge *br, rtl_multicastDeviceInfo_t *devInfo)
+{
+	struct net_bridge_port *p, *n;
+	
+	if((br==NULL) || (devInfo==NULL))
+	{
+		return -1;
+	}
+	
+	memset(devInfo, 0, sizeof(rtl_multicastDeviceInfo_t));
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0 && strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME)!=0 )
+#else
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0)
+#endif
+	{
+		return -1;
+	}
+
+	strcpy(devInfo->devName,br->dev->name);
+	
+		
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{
+		if(memcmp(p->dev->name, RTL_PS_ETH_NAME,3)!=0)
+		{
+			devInfo->swPortMask|=(1<<p->port_no);
+		}
+		devInfo->portMask|=(1<<p->port_no);
+		
+	}
+	
+	return 0;
+}
+#endif
--- linux-2.6.30.9/net/bridge/br_input.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_input.c	2013-05-02 01:47:59.219226613 +0300
@@ -17,13 +17,335 @@
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/ip.h>
+#include <linux/in.h>
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#endif
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+#include <linux/netfilter_ipv4/ip_tables.h>
+#endif
+
+extern int igmpsnoopenabled;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int mldSnoopEnabled;
+#endif
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int br0SwFwdPortMask;
+
+#ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+extern unsigned int brIgmpModuleIndex_2;
+extern unsigned int br1SwFwdPortMask;
+#endif
+
+#if defined (MCAST_TO_UNICAST)
+extern int IGMPProxyOpened;
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#include <linux/icmpv6.h>
+//#define	DBG_ICMPv6	//enable it to debug icmpv6 check
+static char ICMPv6_check(struct sk_buff *skb , unsigned char *gmac);
+#endif	//end of IPV6_MCAST_TO_UNICAST
+
+#endif	//end of MCAST_TO_UNICAST
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+#include <net/udp.h>
+#endif
+
+static char igmp_type_check(struct sk_buff *skb, unsigned char *gmac,unsigned int *gIndex,unsigned int *moreFlag);
+static void br_update_igmp_snoop_fdb(unsigned char op, struct net_bridge *br, struct net_bridge_port *p, unsigned char *gmac
+									,struct sk_buff *skb);
+#endif	//end of CONFIG_RTL_IGMP_SNOOPING
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+extern int br_filter_enter(struct sk_buff *skb);
+extern unsigned char dut_br0_mac[];
+extern unsigned char Filter_State;
+extern int enable_filter;
+#endif
+
 /* Bridge group multicast address 802.1d (pg 51). */
 const u8 br_group_address[ETH_ALEN] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
 
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+#include <net/arp.h>
+#include <net/tcp.h>
+extern unsigned char inband_Hostmac[]; //mark_test
+extern unsigned int inband_HostIP;
+extern int br_hackMac_enable;
+
+#define RTK_WPS_LISTEN_PORT 52881
+#define MAX_LISTEN_ENDPOINT 8
+
+struct listen_info {
+	unsigned int src_ip;
+	unsigned short src_port;
+	unsigned char state;
+	unsigned char sync_retry;
+};
+
+enum {
+  IDLE_STATE = 0,
+  SYN_SENT_STATE,
+  CONNECTED_STATE,
+  FIN_WAIT_STATE,  
+  RTK_MAX_STATES /* Leave at the end! */
+};
+
+
+static struct listen_info listen_endpoint[MAX_LISTEN_ENDPOINT];
+
+void init_listen_endpoint()
+{
+	memset(&listen_endpoint[0],0,sizeof(struct listen_info)*MAX_LISTEN_ENDPOINT);
+}
+
+static int is_listening_endpoint(unsigned int ip,unsigned short port,struct tcphdr *tcph_ptr)
+{
+	int i,ret=0;
+
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( (listen_endpoint[i].src_port== port ) && (listen_endpoint[i].src_ip == ip) && 
+			(listen_endpoint[i].state != IDLE_STATE))			
+			break;
+	}
+
+	if( i == MAX_LISTEN_ENDPOINT)
+		return 0; //not listen..
+
+	if(listen_endpoint[i].state == SYN_SENT_STATE)	
+	{
+		if( tcph_ptr->syn  &&  tcph_ptr->ack )  //rcv - syn ack
+		{
+			listen_endpoint[i].state = CONNECTED_STATE;
+			ret=1;
+		}
+	} 	
+	else if(listen_endpoint[i].state == CONNECTED_STATE)// can rcv all pkt	
+	{
+		ret=1;
+		if(tcph_ptr->rst)
+			listen_endpoint[i].state = IDLE_STATE;
+	}
+	else if(listen_endpoint[i].state == FIN_WAIT_STATE)	//rcv ack to finish
+	{
+		ret=1;		  
+		if( (tcph_ptr->ack && (!(tcph_ptr->fin)))  || tcph_ptr->rst )  //rcv - pure  ack or rst , fin+ack will not enter idle state
+		{
+			listen_endpoint[i].state = IDLE_STATE;		
+		}	
+	}
+	
+	return ret;	
+}
+
+static void add_listen_info(unsigned int pkt_ip, unsigned short pkt_port)
+{
+	int i;
+	int entry1=-1,entry2=-1,entry2_retry=0;
+	//rule 1 , find idle state entry to replace
+	//rule 2 , find syn_sent state entry to replace
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( listen_endpoint[i].state == IDLE_STATE )			
+		{
+			entry1 = i;
+			break;
+		}
+		else if( (listen_endpoint[i].state == SYN_SENT_STATE) && (listen_endpoint[i].sync_retry >= 2))
+		{
+			if(listen_endpoint[i].sync_retry > entry2_retry)
+			{
+				entry2 = i;
+				entry2_retry = listen_endpoint[i].sync_retry;
+			}			
+		}
+	}		
+
+	if(entry1 < 0) //no idle entry
+	{
+		if(entry2 < 0)
+		{
+			printk("no ap_hcm listen_entry can be used!!!\n");
+			return;
+		}				
+		else
+			entry1 = entry2;
+	}	
+
+	listen_endpoint[entry1].src_ip = pkt_ip;
+	listen_endpoint[entry1].src_port= pkt_port;
+	listen_endpoint[entry1].state = SYN_SENT_STATE;
+	listen_endpoint[entry1].sync_retry= 0;
+
+}
+
+void check_listen_info(struct sk_buff *skb)
+{
+	struct iphdr *iph_ptr;
+	struct tcphdr *tcph_ptr;
+	int i,in_listening=0;
+	unsigned int pkt_ip;
+	unsigned short pkt_port;
+
+	//iph_ptr = skb->nh.iph;
+	iph_ptr = ip_hdr(skb); //mark_26
+	tcph_ptr=(void *) iph_ptr + iph_ptr->ihl*4;
+	pkt_ip = iph_ptr->daddr;
+	pkt_port = tcph_ptr->dest;
+
+	if((iph_ptr->protocol != IPPROTO_TCP))
+		return;
+
+	if((tcph_ptr->source == RTK_WPS_LISTEN_PORT)) //ingnore wps
+		return;
+	
+	//find if the pkt is already listening
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( (listen_endpoint[i].src_port== pkt_port ) && (listen_endpoint[i].src_ip == pkt_ip) )			
+		{
+			in_listening=1;
+			break;
+		}	
+	}
+
+	if(in_listening == 0) //the entry not find , so pnly sync pkt need to create a new listen entry
+	{
+		if((tcph_ptr->syn) && (!(tcph_ptr->ack)))
+			add_listen_info(pkt_ip,pkt_port);
+	}
+	else //already in listen
+	{
+		if( (tcph_ptr->syn) && (!(tcph_ptr->ack))) //only syn pkt
+		{
+			listen_endpoint[i].state = SYN_SENT_STATE;
+			listen_endpoint[i].sync_retry++;
+		}
+		else if((tcph_ptr->fin))
+		{
+			listen_endpoint[i].state = FIN_WAIT_STATE;
+		}
+		else if((tcph_ptr->rst))
+		{
+			listen_endpoint[i].state = IDLE_STATE;
+		}	
+		
+	}	
+
+}
+
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+
+void br_signal_pathsel(struct net_bridge *br)
+{
+	struct task_struct *task;
+	if(br==NULL)
+	{
+		return;
+	}
+	read_lock(&tasklist_lock);
+	task = find_task_by_vpid(br->mesh_pathsel_pid);
+	read_unlock(&tasklist_lock);
+	if(task)
+	{
+    	    	//printk("Send signal from kernel\n");
+		send_sig(SIGUSR2,task,0);
+	}
+	else {
+	//printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+	}
+}
+
+/*
+void br_signal_pathsel()
+{
+	struct task_struct *task;
+
+	struct net_bridge *br;
+
+	br = find_br_by_name("br0");
+	
+	read_lock(&tasklist_lock);
+    task = find_task_by_pid(br->mesh_pathsel_pid);
+    read_unlock(&tasklist_lock);
+    if(task)
+    {
+    	//printk("Send signal from kernel\n");
+        send_sig(SIGUSR2,task,0);
+		//br->stp_enabled = 1; //now pathsel daemon can turn it on
+	}
+    else {
+        //printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+    }
+}
+*/
+#endif	//CONFIG_RTK_MESH
+
 static void br_pass_frame_up(struct net_bridge *br, struct sk_buff *skb)
 {
 	struct net_device *indev, *brdev = br->dev;
 
+#if 0//defined (CONFIG_RTL_IGMP_SNOOPING)
+        unsigned char *dest;
+        struct net_bridge_port *p;
+        unsigned char macAddr[6];
+        unsigned char operation;
+        struct iphdr *iph;
+	unsigned char proto=0;  
+                          
+	//iph = skb->nh.iph;
+	iph=(struct iphdr *)skb_network_header(skb);
+	proto =  iph->protocol;    
+	dest =  eth_hdr(skb)->h_dest;
+	p = skb->dev->br_port;
+
+	if (igmpsnoopenabled && MULTICAST_MAC(dest) && (eth_hdr(skb)->h_proto == ETH_P_IP)){
+                if (proto== IPPROTO_IGMP){
+			uint32 fwdPortMask;
+			//rtl_igmpMldProcess(brIgmpModuleIndex, skb->mac.raw, p->port_no, &fwdPortMask);
+			rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);
+			if ((operation=igmp_type_check(skb, macAddr)) > 0) {	
+               	            br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+                          }
+		}
+        }
+
+	#if defined (MCAST_TO_UNICAST)	
+	#if defined (IPV6_MCAST_TO_UNICAST)
+	else if(igmpsnoopenabled 
+		&& IPV6_MULTICAST_MAC(dest) 
+		&& (eth_hdr(skb)->h_proto == ETH_P_IPV6) )
+	{		
+		operation = ICMPv6_check(skb , macAddr);
+		if (operation > 0) {
+				#ifdef	DBG_ICMPv6
+				if( operation == 1)
+					printk("ICMPv6 mac add (from frame_up)\n");
+				else if(operation == 2)
+					printk("ICMPv6 mac del (from frame_up)\n");	
+				#endif
+               	br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+		}
+	}
+	#endif	//end of IPV6_MCAST_TO_UNICAST
+	#endif
+#endif
 	brdev->stats.rx_packets++;
 	brdev->stats.rx_bytes += skb->len;
 
@@ -34,6 +356,178 @@ static void br_pass_frame_up(struct net_
 		netif_receive_skb);
 }
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+extern int32 rtl865x_BlkCheck(const unsigned char *addr);
+#endif
+
+#if defined(CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST) 
+extern int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr);
+#endif
+
+#ifdef CONFIG_RTL_EAP_RELAY
+extern unsigned char inband_Hostmac[];
+//unsigned char Wlan_mac[6]={0x00,0xE0,0x4C,0x01,0x96,0xC0};
+#endif
+
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+#define RTL_WLAN_INT_PREFIX "wlan"
+extern int rtl_wlan_block_relay_enable;
+#endif
+
+#if defined (CONFIG_RTL_QUERIER_SELECTION)
+#define HOP_BY_HOP_OPTIONS_HEADER 0
+#define ROUTING_HEADER 43
+#define FRAGMENT_HEADER 44
+#define DESTINATION_OPTION_HEADER 60
+#define NO_NEXT_HEADER 59
+#define ICMP_PROTOCOL 58
+#define IPV4_ROUTER_ALTER_OPTION 0x94040000
+#define IPV6_ROUTER_ALTER_OPTION 0x05020000
+#define IPV6_HEADER_LENGTH 40
+#define MLD_QUERY 130
+#define MLDV1_REPORT 131
+#define MLDV1_DONE 132
+#define MLDV2_REPORT 143
+#define S_FLAG_MASK 0x08
+
+extern int br_updateQuerierInfo(unsigned int version, unsigned char *devName, unsigned int* querierIp);
+
+int check_igmpQueryExist(struct iphdr * iph)
+{
+
+	if(iph==NULL)
+	{
+		return 0;
+	}
+
+	if(*(unsigned char *)((unsigned char*)iph+((iph->ihl)<<2))==0x11)
+	{
+		return 1;
+	}
+	
+	return 0;
+}
+
+
+
+int check_mldQueryExist(struct ipv6hdr* ipv6h)
+{
+
+	unsigned char *ptr=NULL;
+	unsigned char *startPtr=NULL;
+	unsigned char *lastPtr=NULL;
+	unsigned char nextHeader=0;
+	unsigned short extensionHdrLen=0;
+
+	unsigned char  optionDataLen=0;
+	unsigned char  optionType=0;
+	unsigned int ipv6RAO=0;
+
+	if(ipv6h==NULL)
+	{
+		return 0;
+	}
+
+	if(ipv6h->version!=6)
+	{
+		return 0;
+	}
+
+	startPtr= (unsigned char *)ipv6h;
+	lastPtr=startPtr+sizeof(struct ipv6hdr)+(ipv6h->payload_len);
+	nextHeader= ipv6h ->nexthdr;
+	ptr=startPtr+sizeof(struct ipv6hdr);
+
+	while(ptr<lastPtr)
+	{
+		switch(nextHeader)
+		{
+			case HOP_BY_HOP_OPTIONS_HEADER:
+				/*parse hop-by-hop option*/
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+				ptr=ptr+2;
+
+				while(ptr<(startPtr+extensionHdrLen+sizeof(struct ipv6hdr)))
+				{
+					optionType=ptr[0];
+					/*pad1 option*/
+					if(optionType==0)
+					{
+						ptr=ptr+1;
+						continue;
+					}
+
+					/*padN option*/
+					if(optionType==1)
+					{
+						optionDataLen=ptr[1];
+						ptr=ptr+optionDataLen+2;
+						continue;
+					}
+
+					/*router altert option*/
+					if(ntohl(*(uint32 *)(ptr))==IPV6_ROUTER_ALTER_OPTION)
+					{
+						ipv6RAO=IPV6_ROUTER_ALTER_OPTION;
+						ptr=ptr+4;
+						continue;
+					}
+
+					/*other TLV option*/
+					if((optionType!=0) && (optionType!=1))
+					{
+						optionDataLen=ptr[1];
+						ptr=ptr+optionDataLen+2;
+						continue;
+					}
+
+
+				}
+
+				break;
+
+			case ROUTING_HEADER:
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+                            ptr=ptr+extensionHdrLen;
+				break;
+
+			case FRAGMENT_HEADER:
+				nextHeader=ptr[0];
+				ptr=ptr+8;
+				break;
+
+			case DESTINATION_OPTION_HEADER:
+				nextHeader=ptr[0];
+				extensionHdrLen=((uint16)(ptr[1])+1)*8;
+				ptr=ptr+extensionHdrLen;
+				break;
+
+			case ICMP_PROTOCOL:
+				nextHeader=NO_NEXT_HEADER;
+				if(ptr[0]==MLD_QUERY)
+				{
+					return 1;
+
+				}
+				break;
+
+			default:
+				/*not ipv6 multicast protocol*/
+				return 0;
+		}
+
+	}
+	return 0;
+}
+
+#endif
 /* note: already called with rcu_read_lock (preempt_disabled) */
 int br_handle_frame_finish(struct sk_buff *skb)
 {
@@ -50,9 +544,134 @@ int br_handle_frame_finish(struct sk_buf
 	br = p->br;
 	br_fdb_update(br, p, eth_hdr(skb)->h_source);
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	if (rtl865x_BlkCheck(eth_hdr(skb)->h_source) == TRUE)
+	{
+
+		kfree_skb(skb);
+		goto out;
+	}
+#endif
+	
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)	
+	if(enable_filter){
+		struct iphdr *iph_check;
+		iph_check = (struct iphdr *)skb_network_header(skb);	
+		if(Filter_State==0){
+			if(memcmp(dut_br0_mac, dest, 6)){
+				if(iph_check->protocol==IPPROTO_ICMP){
+					goto drop;
+				}
+			}
+		}
+#if 0		
+		else if(Filter_State==1 && (dest[0] & 1 == 0)){
+			struct udphdr *udph;
+			udph=(void *)iph_check + iph_check->ihl*4;
+			if(iph_check->protocol==IPPROTO_UDP && udph->dest ==68){ //if dhcp server packet if unicast
+				if(br_filter_enter(skb))
+					goto err;
+			}
+		}
+#endif		
+	}
+#endif
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) || defined(CONFIG_RTL_ULINKER)
+	if(enable_filter){			
+		if(br_filter_enter(skb))
+			goto drop;
+	}	
+#endif	
+
+
 	if (p->state == BR_STATE_LEARNING)
 		goto drop;
 
+//mark_issue, all filter above will not work in host ip hack ,FIX ME
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+	//if it is arp response then we need to pass to both local and remote host	
+	//and redirect some protocol wps,802.1x to local not to remote host	
+	if(br_hackMac_enable == 0) //donot nothing 
+		goto ap_hcm_out;
+	else{		
+		if(eth_hdr(skb)->h_proto == ETH_P_ARP)
+		{
+			struct arphdr *arp = arp_hdr(skb);
+			if(arp->ar_op == __constant_htons(ARPOP_REPLY))
+			{
+				struct sk_buff *skb3;
+
+				if(memcmp(dest,inband_Hostmac,6)) //goout if mac is not for host
+					goto ap_hcm_out;
+
+				skb3 = skb_clone(skb, GFP_ATOMIC);			
+				if (skb3 != NULL) {
+					struct arphdr *arp3 = arp_hdr(skb3);
+					unsigned char *arp_ptr= (unsigned char *)(arp3+1);
+					//memcpy(arp_ptr+10,br->dev.dev_addr,6);   // cheat ARP layer that it's a ARP reply for local					
+					memcpy(arp_ptr+10,skb->dev->dev_addr,6);   // mark_issue, 	perm_addr in 2.6	
+					//memcpy(eth_hdr(skb3)->h_dest,br->dev.dev_addr,6);  							
+					memcpy(eth_hdr(skb3)->h_dest,skb->dev->dev_addr,6);  // mark_issue, 	perm_addr in 2.6							
+					//passedup = 1;				
+					//hex_dump(skb3->data,48);
+					skb3->pkt_type=PACKET_HOST; 
+					br_pass_frame_up(br, skb3);
+					memcpy(dest,inband_Hostmac,6); //recovery packet's mac to host
+				}
+			}
+		}
+		else if(eth_hdr(skb)->h_proto == ETH_P_IP)	//check packet's destIP == br0IP == Hostip
+		{
+			struct iphdr *iph_ptr;				
+			//struct udphdr *udph_ptr;
+			iph_ptr = ip_hdr(skb); //mark_26		
+		
+			if(iph_ptr->daddr == inband_HostIP )
+			{
+				if(memcmp(dest,inband_Hostmac,6)) //goout if mac is not for host
+					goto ap_hcm_out;
+
+				if((iph_ptr->protocol==IPPROTO_TCP))
+				{
+					struct tcphdr *tcph_ptr;
+					int trap_to_local =0;
+
+					tcph_ptr=(void *) iph_ptr + iph_ptr->ihl*4;
+
+					if( tcph_ptr->dest <= 1024) //dont listen  public tcp port, just bypass to Host ...
+						goto ap_hcm_out;
+
+					//listen for wps dst port 	
+					if( (tcph_ptr->dest == RTK_WPS_LISTEN_PORT)  || 
+					is_listening_endpoint(iph_ptr->saddr,tcph_ptr->source,tcph_ptr))
+						trap_to_local = 1;
+
+					if(trap_to_local)
+					{
+						//memcpy(dest,br->dev.dev_addr,6);  						
+						memcpy(eth_hdr(skb)->h_dest,skb->dev->dev_addr,6);										
+						//hex_dump(skb->data,48);
+						skb->pkt_type=PACKET_HOST; 
+						br_pass_frame_up(br, skb);
+						goto out;										
+					}	
+
+				}
+				//use icmp packet for test		
+				#if 0
+				else if(iph_ptr->protocol==IPPROTO_ICMP)
+				{
+					memcpy(dest,br->dev.dev_addr,6);  				
+					br_pass_frame_up(br, skb);
+						goto out;
+				}			
+				#endif
+			}			
+		}
+	}		
+ap_hcm_out:	
+#endif
 	/* The packet skb2 goes to the local host (NULL to skip). */
 	skb2 = NULL;
 
@@ -65,10 +684,22 @@ int br_handle_frame_finish(struct sk_buf
 		br->dev->stats.multicast++;
 		skb2 = skb;
 	} else if ((dst = __br_fdb_get(br, dest)) && dst->is_local) {
+#ifdef CONFIG_RTL_EAP_RELAY
+		if(eth_hdr(skb)->h_proto == 0x888E)
+		{			
+			memcpy(eth_hdr(skb)->h_dest,inband_Hostmac,6);
+			//else if(!memcmp(eth_hdr(skb)->h_source,inband_Hostmac,6)) // if src_mac == host .
+			//	memcpy(eth_hdr(skb)->h_source,Wlan_mac,6);
+			dst = __br_fdb_get(br, dest);					
+		}
+		else
+#endif	
+		{		
 		skb2 = skb;
 		/* Do not forward the packet since it's local. */
 		skb = NULL;
 	}
+	}
 
 	if (skb2 == skb)
 		skb2 = skb_clone(skb, GFP_ATOMIC);
@@ -76,12 +707,257 @@ int br_handle_frame_finish(struct sk_buf
 	if (skb2)
 		br_pass_frame_up(br, skb2);
 
+
 	if (skb) {
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+		if(rtl_wlan_block_relay_enable && dst){
+			if(!memcmp(skb->dev->name,RTL_WLAN_INT_PREFIX,sizeof(RTL_WLAN_INT_PREFIX)-1)){
+				if(!memcmp(dst->dst->dev->name,RTL_WLAN_INT_PREFIX,sizeof(RTL_WLAN_INT_PREFIX)-1))
+					goto drop;
+			}
+		}
+#endif
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if (is_multicast_ether_addr(dest) && igmpsnoopenabled) {
+		struct iphdr *iph=NULL;
+#if defined (CONFIG_RTL_MLD_SNOOPING) 	
+		struct ipv6hdr *ipv6h=NULL;
+#endif
+		uint32 fwdPortMask=0;
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		unsigned int srcPort=skb->srcPort;
+		unsigned int srcVlanId=skb->srcVlanId;
+#endif
+
+		unsigned char proto=0;
+		unsigned char reserved=0;
+		int ret=FAILED;
+		
+		unsigned char macAddr[6];
+		unsigned char operation;
+		char tmpOp;
+		unsigned int gIndex=0;
+		unsigned int moreFlag=1;
+		
+		struct rtl_multicastDataInfo multicastDataInfo;
+		struct rtl_multicastFwdInfo multicastFwdInfo;
+
+		if ( !(br->dev->flags & IFF_PROMISC) 
+		 &&MULTICAST_MAC(dest) 
+		&& (eth_hdr(skb)->h_proto == ETH_P_IP))
+		{
+
+			iph=(struct iphdr *)skb_network_header(skb);
+			#if defined(CONFIG_USB_UWIFI_HOST)
+				if(iph->daddr == 0xEFFFFFFA || iph->daddr == 0xE1010101)
+			#else
+				if(iph->daddr == 0xEFFFFFFA)
+			#endif
+			
+			{
+				/*for microsoft upnp*/
+				reserved=1;
+			}
+#if 0
+			if((iph->daddr&0xFFFFFF00)==0xE0000000)
+			reserved=1;
+#endif
+			proto =  iph->protocol;  
+			if (proto == IPPROTO_IGMP) 
+			{	
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+				//filter igmp pkts by upper hook like iptables 
+				if(IgmpRxFilter_Hook != NULL)
+				{
+					struct net_device	*origDev=skb->dev;
+					if((skb->dev->br_port) && (skb->dev->br_port->br))
+					{
+						skb->dev=skb->dev->br_port->br->dev;
+					}
+					
+					if(IgmpRxFilter_Hook(skb, NF_INET_PRE_ROUTING,  skb->dev, NULL,dev_net(skb->dev)->ipv4.iptable_filter) !=NF_ACCEPT)
+					{
+						skb->dev=origDev;
+						DEBUG_PRINT(" filter a pkt:%d %s:% \n", k, skb->dev->name, &(dev_net(skb->dev)->ipv4.iptable_filter->name[0]));
+						goto drop;
+					}
+					else
+					{
+						skb->dev=origDev;
+					}
+						
+					
+					
+				}else
+					DEBUG_PRINT("IgmpRxFilter_Hook is NULL\n");
+#endif
+				while(moreFlag)
+				{
+					tmpOp=igmp_type_check(skb, macAddr, &gIndex, &moreFlag);
+					if(tmpOp>0)
+					{
+						//printk("%s:%d,macAddr is 0x%x:%x:%x:%x:%x:%x\n",__FUNCTION__,__LINE__,macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
+						operation=(unsigned char)tmpOp;
+						br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+					}
+				}
+				
+				#if defined (CONFIG_RTL_QUERIER_SELECTION)
+				if(check_igmpQueryExist(iph)==1)
+				{
+					/*igmp query packet*/
+					if(skb->dev->br_port)
+					{
+						br_updateQuerierInfo(4,skb->dev->br_port->br->dev->name,&(iph->saddr));
+					}
+					else
+					{
+						br_updateQuerierInfo(4,skb->dev->name,&(iph->saddr));
+					}
+				}
+				#endif
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+				{
+					rtl_igmpMldProcess(brIgmpModuleIndex_2, skb_mac_header(skb), p->port_no, &fwdPortMask);
+					//flooding igmp packet
+					fwdPortMask=(~(1<<(p->port_no))) & 0xFFFFFFFF;
+				}
+				else
+				#endif
+				rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);
+				br_multicast_forward(br, fwdPortMask, skb, 0);
+			}
+			else if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP)) && (reserved ==0))
+			{
+
+				iph=(struct iphdr *)skb_network_header(skb);
+				multicastDataInfo.ipVersion=4;
+				multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
+				multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
+				
+                #ifdef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+				if(!strcmp(br->dev->name,RTL_PS_BR1_DEV_NAME))
+				{
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex_2, &multicastDataInfo, &multicastFwdInfo);
+				}
+				else
+				#endif
+				ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+				br_multicast_forward(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				if((ret==SUCCESS) && (multicastFwdInfo.cpuFlag==0))
+				{
+
+					#if defined  (CONFIG_RTL_HARDWARE_MULTICAST)
+					if((srcVlanId!=0) && (srcPort!=0xFFFF))
+					{
+						#if defined(CONFIG_RTK_VLAN_SUPPORT)
+						if(rtk_vlan_support_enable == 0)
+						{
+							rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+						}
+						#else
+						rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+						#endif
+					}	
+					#endif
+				}
+				
+
+			}
+			else
+			{
+				br_flood_forward(br, skb);
+			}
+		}
+		else if(!(br->dev->flags & IFF_PROMISC) 
+			&& IPV6_MULTICAST_MAC(dest)
+			&& (eth_hdr(skb)->h_proto == ETH_P_IPV6))
+		{
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+			tmpOp=ICMPv6_check(skb , macAddr);
+			if(tmpOp > 0){
+				operation=(unsigned char)tmpOp;
+#ifdef	DBG_ICMPv6
+			if( operation == 1)
+				printk("icmpv6 add from frame finish\n");
+			else if(operation == 2)
+				printk("icmpv6 del from frame finish\n");	
+#endif
+				br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+			}
+#endif
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+			if(mldSnoopEnabled)
+			{
+				ipv6h=(struct ipv6hdr *)skb_network_header(skb);
+				proto =  re865x_getIpv6TransportProtocol(ipv6h);
+				/*icmp protocol*/
+				if (proto == IPPROTO_ICMPV6) 
+				{	
+					#if defined (CONFIG_RTL_QUERIER_SELECTION)
+					if(check_mldQueryExist(ipv6h)==1)
+					{
+						if(skb->dev->br_port)
+						{
+							br_updateQuerierInfo(6,skb->dev->br_port->br->dev->name,&(ipv6h->saddr));
+						}
+						else
+						{
+							br_updateQuerierInfo(6,skb->dev->name,&(ipv6h->saddr));
+						}
+
+					}
+					#endif
+					rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);	
+					br_multicast_forward(br, fwdPortMask, skb, 0);
+				}
+				else if ((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+				{
+					multicastDataInfo.ipVersion=6;
+					memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+					memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));	
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+					br_multicast_forward(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				
+				}
+				else
+				{
+					br_flood_forward(br, skb);
+				}	
+			}
+			else
+#endif				
+			{
+				br_flood_forward(br, skb);
+			}
+
+		}
+		else
+		{
+			br_flood_forward(br, skb);
+		}
+
+	
+	}
+	else
+	{
+		/*known/unknown unicast packet*/
 		if (dst)
 			br_forward(dst->dst, skb);
 		else
 			br_flood_forward(br, skb);
 	}
+#else 
+
+		if (dst)
+			br_forward(dst->dst, skb);
+		else
+			br_flood_forward(br, skb);
+#endif	// CONFIG_RTL_IGMP_SNOOPING
+	}
 
 out:
 	return 0;
@@ -138,12 +1014,28 @@ struct sk_buff *br_handle_frame(struct n
 		if (p->br->stp_enabled == BR_NO_STP && dest[5] == 0)
 			goto forward;
 
+#if !defined(CONFIG_RTL_ULINKER)
 		if (NF_HOOK(PF_BRIDGE, NF_BR_LOCAL_IN, skb, skb->dev,
 			    NULL, br_handle_local_finish))
 			return NULL;	/* frame consumed by filter */
 		else
 			return skb;	/* continue processing */
+#endif
+	}
+#if 0
+#if defined (STP_DISABLE_ETH)
+//chris: auto stp on
+	if (!(p->br->dev->flags & IFF_UP))
+		goto err;
+
+	if (p->state==BR_STATE_DISABLED && p->disable_by_mesh ==0){
+		goto err;
+	}else if (!strncmp(p->dev->name,"eth", 3)){
+			p->br->stp_enabled = 1;
+			mod_timer(&p->br->eth0_autostp_timer, jiffies+p->br->eth0_monitor_interval);
 	}
+#endif	
+#endif 
 
 forward:
 	switch (p->state) {
@@ -159,6 +1051,26 @@ forward:
 		if (!compare_ether_addr(p->br->dev->dev_addr, dest))
 			skb->pkt_type = PACKET_HOST;
 
+#if defined (CONFIG_RTK_MESH)
+if (p->state == BR_STATE_FORWARDING) {
+		//brian modify for trigger portal-enable event
+		if(!strncmp(p->dev->name,RTL_PS_ETH_NAME, 3)){
+			if(p->br->mesh_pathsel_pid!= 0){
+				if( !(p->br->eth0_received) )
+				{
+					p->br->eth0_received = 1;
+					p->br->stp_enabled = 1;
+					br_signal_pathsel(p->br);
+					printk(KERN_INFO,"eth0 learning, event pathsel daemon \n");
+				}
+				
+				mod_timer(&p->br->eth0_monitor_timer, jiffies+p->br->eth0_monitor_interval);
+				
+			}
+		}
+}
+#endif	//CONFIG_RTK_MESH
+
 		NF_HOOK(PF_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
 			br_handle_frame_finish);
 		break;
@@ -168,3 +1080,452 @@ drop:
 	}
 	return NULL;
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+/*Convert  MultiCatst IPV6_Addr to MAC_Addr*/
+static void CIPV6toMac
+	(unsigned char* icmpv6_McastAddr, unsigned char *gmac )
+{
+	/*ICMPv6 valid addr 2^32 -1*/
+	gmac[0] = 0x33;
+	gmac[1] = 0x33;
+	gmac[2] = icmpv6_McastAddr[12];
+	gmac[3] = icmpv6_McastAddr[13];
+	gmac[4] = icmpv6_McastAddr[14];
+	gmac[5] = icmpv6_McastAddr[15];			
+}
+
+
+
+static char ICMPv6_check(struct sk_buff *skb , unsigned char *gmac)
+{
+	
+	struct ipv6hdr *ipv6h;
+	char* protoType;	
+	
+	/* check IPv6 header information */
+	//ipv6h = skb->nh.ipv6h;
+	ipv6h = (struct ipv6hdr *)skb_network_header(skb);
+	if(ipv6h->version != 6){	
+		//printk("ipv6h->version != 6\n");
+		return -1;
+	}
+
+
+	/*Next header: IPv6 hop-by-hop option (0x00)*/
+	if(ipv6h->nexthdr == 0)	{
+		protoType = (unsigned char*)( (unsigned char*)ipv6h + sizeof(struct ipv6hdr) );	
+	}else{
+		//printk("ipv6h->nexthdr != 0\n");
+		return -1;
+	}
+
+	if(protoType[0] == 0x3a){
+		
+		//printk("recv icmpv6 packet\n");
+		struct icmp6hdr* icmpv6h = (struct icmp6hdr*)(protoType + 8);
+		unsigned char* icmpv6_McastAddr ;
+	
+		if(icmpv6h->icmp6_type == 0x83){
+			
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8);
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener report) \n",icmpv6h->icmp6_type);
+			#endif
+
+		}else if(icmpv6h->icmp6_type == 0x8f){		
+		
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8 + 4);
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener report v2) \n",icmpv6h->icmp6_type);
+			#endif			
+		}else if(icmpv6h->icmp6_type == 0x84){
+		
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8 );			
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener done ) \n",icmpv6h->icmp6_type);
+			#endif			
+		}
+		else{
+			#ifdef	DBG_ICMPv6
+			printk("Type: 0x%x (unknow type)\n",icmpv6h->icmp6_type);
+			#endif			
+			return -1;
+		}				
+
+		#ifdef	DBG_ICMPv6			
+		printk("MCAST_IPV6Addr:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x \n",
+			icmpv6_McastAddr[0],icmpv6_McastAddr[1],icmpv6_McastAddr[2],icmpv6_McastAddr[3],
+			icmpv6_McastAddr[4],icmpv6_McastAddr[5],icmpv6_McastAddr[6],icmpv6_McastAddr[7],
+			icmpv6_McastAddr[8],icmpv6_McastAddr[9],icmpv6_McastAddr[10],icmpv6_McastAddr[11],
+			icmpv6_McastAddr[12],icmpv6_McastAddr[13],icmpv6_McastAddr[14],icmpv6_McastAddr[15]);
+		#endif
+
+		CIPV6toMac(icmpv6_McastAddr, gmac);
+		
+		#ifdef	DBG_ICMPv6					
+		printk("group_mac [%02x:%02x:%02x:%02x:%02x:%02x] \n",
+			gmac[0],gmac[1],gmac[2],
+			gmac[3],gmac[4],gmac[5]);
+		#endif
+			
+
+
+		if(icmpv6h->icmp6_type == 0x83){
+
+			return 1;//icmpv6 listener report (add)
+		}
+		else if(icmpv6h->icmp6_type == 0x8f){
+			return 1;//icmpv6 listener report v2 (add) 
+		}
+		else if(icmpv6h->icmp6_type == 0x84){
+			return 2;//icmpv6 Multicast listener done (del)
+		}
+	}		
+	else{
+		//printk("protoType[0] != 0x3a\n");		
+		return -1;//not icmpv6 type
+	}
+		
+	return -1;
+}
+
+#endif	//end of IPV6_MCAST_TO_UNICAST
+
+/*2008-01-15,for porting igmp snooping to linux kernel 2.6*/
+static void ConvertMulticatIPtoMacAddr(__u32 group, unsigned char *gmac)
+{
+	__u32 u32tmp, tmp;
+	int i;
+
+	u32tmp = group & 0x007FFFFF;
+	gmac[0]=0x01; gmac[1]=0x00; gmac[2]=0x5e;
+	for (i=5; i>=3; i--) {
+		tmp=u32tmp&0xFF;
+		gmac[i]=tmp;
+		u32tmp >>= 8;
+	}
+}
+static char igmp_type_check(struct sk_buff *skb, unsigned char *gmac,unsigned int *gIndex,unsigned int *moreFlag)
+{
+        struct iphdr *iph;
+	__u8 hdrlen;
+	struct igmphdr *igmph;
+	int i;
+	unsigned int groupAddr=0;// add  for fit igmp v3
+	*moreFlag=0;
+	/* check IP header information */
+	iph=(struct iphdr *)skb_network_header(skb);
+	hdrlen = iph->ihl << 2;
+	if ((iph->version != 4) &&  (hdrlen < 20))
+		return -1;
+	if (ip_fast_csum((u8 *)iph, iph->ihl) != 0)
+		return -1;
+	{ /* check the length */
+		__u32 len = ntohs(iph->tot_len);
+		if (skb->len < len || len < hdrlen)
+			return -1; 
+	}
+	/* parsing the igmp packet */
+	igmph = (struct igmphdr *)((u8*)iph+hdrlen);
+
+	
+	
+	if ((igmph->type==IGMP_HOST_MEMBERSHIP_REPORT) ||
+	    (igmph->type==IGMPV2_HOST_MEMBERSHIP_REPORT)) 
+	{
+		groupAddr = igmph->group;
+		if(!IN_MULTICAST(groupAddr))
+		{			
+				return -1;
+		}
+		
+		ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+		
+		return 1; /* report and add it */
+	}
+	else if (igmph->type==IGMPV3_HOST_MEMBERSHIP_REPORT)	{ 
+		
+	
+		/*for support igmp v3 ; plusWang add 2009-0311*/   	
+		struct igmpv3_report *igmpv3report=(struct igmpv3_report * )igmph;
+		struct igmpv3_grec	*igmpv3grec=NULL; 
+		//printk("%s:%d,*gIndex is %d,igmpv3report->ngrec is %d\n",__FUNCTION__,__LINE__,*gIndex,igmpv3report->ngrec);
+		if(*gIndex>=igmpv3report->ngrec)
+		{
+			*moreFlag=0;
+			return -1;
+		}
+	
+		for(i=0;i<igmpv3report->ngrec;i++)
+		{
+
+			if(i==0)
+			{
+				igmpv3grec = (struct igmpv3_grec *)(&(igmpv3report->grec)); /*first igmp group record*/
+			}
+			else
+			{
+				igmpv3grec=(struct igmpv3_grec *)((unsigned char*)igmpv3grec+8+igmpv3grec->grec_nsrcs*4+(igmpv3grec->grec_auxwords)*4);
+				
+				
+			}
+			
+			if(i!=*gIndex)
+			{	
+				
+				continue;
+			}
+			
+			if(i==(igmpv3report->ngrec-1))
+			{
+				/*last group record*/
+				*moreFlag=0;
+			}
+			else
+			{
+				*moreFlag=1;
+			}
+			
+			/*gIndex move to next group*/
+			*gIndex=*gIndex+1;	
+			
+			groupAddr=igmpv3grec->grec_mca;
+			//printk("%s:%d,groupAddr is %d.%d.%d.%d\n",__FUNCTION__,__LINE__,NIPQUAD(groupAddr));
+			if(!IN_MULTICAST(groupAddr))
+			{			
+				return -1;
+			}
+			
+			ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+			if(((igmpv3grec->grec_type == IGMPV3_CHANGE_TO_INCLUDE) || (igmpv3grec->grec_type == IGMPV3_MODE_IS_INCLUDE))&& (igmpv3grec->grec_nsrcs==0))
+			{	
+				return 2; /* leave and delete it */	
+			}
+			else if((igmpv3grec->grec_type == IGMPV3_CHANGE_TO_EXCLUDE) ||
+				(igmpv3grec->grec_type == IGMPV3_MODE_IS_EXCLUDE) ||
+				(igmpv3grec->grec_type == IGMPV3_ALLOW_NEW_SOURCES))
+			{
+				return 1;
+			}
+			else
+			{
+				/*ignore it*/
+			}
+			
+			return -1;
+		}
+		
+		/*avoid dead loop in case of initial gIndex is too big*/
+		if(i>=(igmpv3report->ngrec-1))
+		{
+			/*last group record*/
+			*moreFlag=0;
+			return -1;
+		}
+		
+	
+	}
+	else if (igmph->type==IGMP_HOST_LEAVE_MESSAGE){
+
+		groupAddr = igmph->group;
+		if(!IN_MULTICAST(groupAddr))
+		{			
+				return -1;
+		}
+		
+		ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+		return 2; /* leave and delete it */
+	}	
+	
+	
+	return -1;
+}
+
+extern int chk_igmp_ext_entry(struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac);
+extern void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb , unsigned char *srcMac , unsigned char portComeIn);
+extern void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+extern void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn );
+
+static void br_update_igmp_snoop_fdb(unsigned char op, struct net_bridge *br, struct net_bridge_port *p, unsigned char *dest 
+										,struct sk_buff *skb)
+{
+	struct net_bridge_fdb_entry *dst;
+	unsigned char *src;
+	unsigned short del_group_src=0;
+	unsigned char port_comein;
+	int tt1;
+
+#if defined (MCAST_TO_UNICAST)
+	struct net_device *dev; 
+	if(!dest)	return;
+	if( !MULTICAST_MAC(dest)
+#if defined (IPV6_MCAST_TO_UNICAST)
+		&& !IPV6_MULTICAST_MAC(dest)
+#endif	
+	   )
+	   { 
+	   	return; 
+	   }
+#endif
+
+#if defined( CONFIG_RTL_HARDWARE_MULTICAST) || defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+
+	if(skb->srcPort!=0xFFFF)
+	{
+		port_comein = 1<<skb->srcPort;
+	}
+	else
+	{
+		port_comein=0x80;
+	}
+	
+#else
+	if(p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_LAN_P0_DEV_NAME, 4))
+	{
+		port_comein = 0x01;
+	}
+	
+	if(p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4))
+	{
+		port_comein=0x80;
+	}
+	
+#endif
+//	src=(unsigned char*)(skb->mac.raw+ETH_ALEN);
+	src=(unsigned char*)(skb_mac_header(skb)+ETH_ALEN);
+	/* check whether entry exist */
+	dst = __br_fdb_get(br, dest);
+
+	if (op == 1) /* add */
+	{	
+	
+#if defined (MCAST_TO_UNICAST)
+		/*process wlan client join --- start*/
+		if (dst && p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4)) 
+		{ 
+			dst->portlist |= 0x80;
+			port_comein = 0x80;
+			//dev = __dev_get_by_name(&init_net,RTL_PS_WLAN0_DEV_NAME);	
+			dev=p->dev;
+			if (dev) 
+			{		
+				unsigned char StaMacAndGroup[20];
+				memcpy(StaMacAndGroup, dest, 6);
+				memcpy(StaMacAndGroup+6, src, 6);	
+			#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				if (dev->do_ioctl != NULL) 
+				{
+					dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B80);
+					DEBUG_PRINT("... add to wlan mcast table:  DA:%02x:%02x:%02x:%02x:%02x:%02x ; SA:%02x:%02x:%02x:%02x:%02x:%02x\n", 
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);					
+				}
+			#else
+				if (dev->netdev_ops->ndo_do_ioctl != NULL) 
+				{
+					dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B80);
+					DEBUG_PRINT("... add to wlan mcast table:  DA:%02x:%02x:%02x:%02x:%02x:%02x ; SA:%02x:%02x:%02x:%02x:%02x:%02x\n", 
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);	
+				}
+			#endif
+				
+														
+			}
+		}
+	/*process wlan client join --- end*/
+#endif
+
+			if (dst) 
+			{
+		        	dst->group_src = dst->group_src | (1 << p->port_no);
+
+				dst->ageing_timer = jiffies;
+
+				tt1 = chk_igmp_ext_entry(dst , src); 
+				if(tt1 == 0)
+				{
+					add_igmp_ext_entry(dst , src , port_comein);									
+				}
+				else
+				{
+					update_igmp_ext_entry(dst , src , port_comein);
+				}	
+			}
+			else
+			{
+				/* insert one fdb entry */
+				DEBUG_PRINT("insert one fdb entry\n");
+				br_fdb_insert(br, p, dest);
+				dst = __br_fdb_get(br, dest);
+				if(dst !=NULL)
+				{
+					dst->igmpFlag=1;
+					dst->is_local=0;
+					dst->portlist = port_comein; 
+					dst->group_src = dst->group_src | (1 << p->port_no);
+				}
+			}
+		
+	}
+	else if (op == 2 && dst) /* delete */
+	{
+		DEBUG_PRINT("dst->group_src = %x change to ",dst->group_src);		
+			del_group_src = ~(1 << p->port_no);
+			dst->group_src = dst->group_src & del_group_src;
+		DEBUG_PRINT(" %x ; p->port_no=%x \n",dst->group_src ,p->port_no);
+
+		/*process wlan client leave --- start*/
+		if (p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4)) 
+		{ 			
+			#ifdef	MCAST_TO_UNICAST
+			//struct net_device *dev = __dev_get_by_name(&init_net,RTL_PS_WLAN0_DEV_NAME);
+			struct net_device *dev=p->dev;
+			if (dev) 
+			{			
+				unsigned char StaMacAndGroup[12];
+				memcpy(StaMacAndGroup, dest , 6);
+				memcpy(StaMacAndGroup+6, src, 6);
+			#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				if (dev->do_ioctl != NULL) 
+				{
+					dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);									
+					DEBUG_PRINT("(del) wlan0 ioctl (del) M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+				}
+			#else
+				if (dev->netdev_ops->ndo_do_ioctl != NULL) 
+				{
+					dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);				
+					DEBUG_PRINT("(del) wlan0 ioctl (del) M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+				}
+			#endif	
+			
+			}
+			#endif	
+			//dst->portlist &= ~0x80;	// move to del_igmp_ext_entry
+			port_comein	= 0x80;
+		}
+		/*process wlan client leave --- end*/
+
+		/*process entry del , portlist update*/
+		del_igmp_ext_entry(dst , src ,port_comein);
+		
+		if (dst->portlist == 0)  // all joined sta are gone
+		{
+			DEBUG_PRINT("----all joined sta are gone,make it expired----\n");
+			dst->ageing_timer -=  300*HZ; // make it expired		
+		}
+		
+
+	}
+}
+
+#endif // CONFIG_RTL_IGMP_SNOOPING
+
--- linux-2.6.30.9/net/bridge/br_ioctl.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_ioctl.c	2013-05-02 01:47:59.219226613 +0300
@@ -20,6 +20,11 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
 /* called with RTNL */
 static int get_bridge_ifindices(struct net *net, int *indices, int num)
 {
@@ -260,6 +265,28 @@ static int old_dev_ioctl(struct net_devi
 			return -EPERM;
 
 		br_stp_set_enabled(br, args[1]);
+#if defined (CONFIG_RTL_STP)
+		{
+			int retval=0;
+			retval=rtl865x_setSpanningEnable(args[1]? TRUE:FALSE);
+
+			if(0==retval)
+				printk("RTL STP %s\n", args[1]?"enabled":"disabled");
+			else
+				printk("RTL STP set %s error=%d\n", args[1]?"enabled":"disabled", retval);
+		}		
+		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+		{
+			int retval=0;
+			retval=rtl865x_setSpanningEnable(args[1]? TRUE:FALSE);
+			if(0==retval)
+				printk("RTL STP %s\n", args[1]?"enabled":"disabled");
+			else
+				printk("RTL STP set %s error=%d", args[1]?"enabled":"disabled", retval);			
+		}
+#endif
 		return 0;
 
 	case BRCTL_SET_BRIDGE_PRIORITY:
@@ -315,6 +342,14 @@ static int old_dev_ioctl(struct net_devi
 	return -EOPNOTSUPP;
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+extern int br_set_igmpProxy_pid(int pid);
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+int br_set_meshpathsel_pid(int pid);
+#endif
+
 static int old_deviceless(struct net *net, void __user *uarg)
 {
 	unsigned long args[3];
@@ -364,6 +399,46 @@ static int old_deviceless(struct net *ne
 
 		return br_del_bridge(net, buf);
 	}
+
+#if defined (CONFIG_RTK_MESH)
+	//by brian, dynamic portal enable
+	case BRCTL_SET_MESH_PATHSELPID:
+	{
+		return br_set_meshpathsel_pid(args[1]);
+	}
+	/*
+	case BRCTL_GET_PORTSTAT:
+	{
+		struct net_bridge *br;
+		struct net_device *dev =NULL;
+		int ret=0;
+
+		dev = __dev_get_by_name(net, RTL_PS_BR0_DEV_NAME);
+		if (dev == NULL) 
+		{
+			return -1;
+
+		}	
+		else if (!(dev->priv_flags & IFF_EBRIDGE)) 
+		{
+			return -1;
+		}
+		else 
+		{
+			br = netdev_priv(dev);
+		}
+
+			return br->eth0_received;
+	}
+	*/
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	case BRCTL_SET_IGMPPROXY_PID:
+	{
+		return br_set_igmpProxy_pid(args[1]);
+	}
+#endif
 	}
 
 	return -EOPNOTSUPP;
--- linux-2.6.30.9/net/bridge/br_notify.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_notify.c	2013-05-02 01:47:59.220226613 +0300
@@ -66,6 +66,12 @@ static int br_device_event(struct notifi
 
 	case NETDEV_DOWN:
 		spin_lock_bh(&br->lock);
+#if 0
+#if defined (STP_DISABLE_ETH)
+			//Chris: stp+mesh
+			p->disable_by_mesh = 0;
+#endif
+#endif 
 		if (br->dev->flags & IFF_UP)
 			br_stp_disable_port(p);
 		spin_unlock_bh(&br->lock);
--- linux-2.6.30.9/net/bridge/br_private.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_private.h	2013-05-02 01:47:59.220226613 +0300
@@ -17,6 +17,48 @@
 #include <linux/if_bridge.h>
 #include <net/route.h>
 
+//#define DEBUG_PRINT(fmt, args...) printk(fmt, ## args)
+#define DEBUG_PRINT(fmt, args...)
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+#define MULTICAST_MAC(mac) 	   ((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define IPV6_MULTICAST_MAC(mac) ((mac[0]==0x33)&&(mac[1]==0x33) && mac[2]!=0xff)
+//#define CONFIG_BRIDGE_IGMPV3_SNOOPING
+
+#define MCAST_TO_UNICAST
+
+#define IGMP_EXPIRE_TIME (260*HZ)
+
+#if defined (MCAST_TO_UNICAST)
+#define IPV6_MCAST_TO_UNICAST
+#endif
+
+#define MLCST_FLTR_ENTRY	16
+#define MLCST_MAC_ENTRY		64
+
+extern int rtk_vlan_support_enable;
+// interface to set multicast bandwidth control
+//#define MULTICAST_BWCTRL
+
+// interface to enable MAC clone function
+//#define RTL_BRIDGE_MAC_CLONE
+//#define RTL_BRIDGE_DEBUG
+
+#define MCAST_QUERY_INTERVAL 30
+
+#endif
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2
+#define CONFIG_RTL865X_ETH
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtk_vlan.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
 
@@ -30,10 +72,40 @@
 /* Path to usermode spanning tree program */
 #define BR_STP_PROG	"/sbin/bridge-stp"
 
+#if defined (CONFIG_RTK_MESH)
+#define STP_ADDCOST_ETH
+
+#define MESH_PORTAL_EXPIRE 300 //seconds
+#if 0
+#ifdef STP_DISABLE_ETH
+//Chris: stp+mesh
+#define ETH_CHK_INTVL		(30*HZ)
+#endif
+#endif
+#endif
+
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#define FDB_IGMP_EXT_NUM 8
+struct fdb_igmp_ext_entry
+{
+	int valid;
+	unsigned long ageing_time;
+	unsigned char SrcMac[6];	
+	unsigned char port;
+
+};
+
+struct fdb_igmp_ext_array
+{
+	struct fdb_igmp_ext_entry igmp_fdb_arr[FDB_IGMP_EXT_NUM];
+};
+
+#endif
+
 struct bridge_id
 {
 	unsigned char	prio[2];
@@ -53,6 +125,15 @@ struct net_bridge_fdb_entry
 	struct rcu_head			rcu;
 	atomic_t			use_count;
 	unsigned long			ageing_timer;
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	unsigned short group_src;
+	unsigned char			igmpFlag;
+	unsigned char			portlist;
+	int 					portUsedNum[8];	// be used with portlist, for record each port has how many client
+	//struct fdb_igmp_ext_array	igmp_ext_array;
+	struct fdb_igmp_ext_entry igmp_fdb_arr[FDB_IGMP_EXT_NUM];
+#endif
+
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;
@@ -82,6 +163,16 @@ struct net_bridge_port
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
 	struct rcu_head			rcu;
+
+//Chris:  stp+mesh
+#if 0
+#ifdef STP_DISABLE_ETH
+//Chris:  stp+mesh
+	int	 				disable_by_mesh; 
+		//0: no, 1:eth port disabled because mesh entering blocking state
+	struct timer_list		eth_disable_timer;
+#endif
+#endif //CONFIG_RTK_MESH
 };
 
 struct net_bridge
@@ -128,6 +219,30 @@ struct net_bridge
 	struct timer_list		topology_change_timer;
 	struct timer_list		gc_timer;
 	struct kobject			*ifobj;
+#if defined (CONFIG_RTK_MESH)
+	//by brian, record pid for dynamic enable portal
+	int mesh_pathsel_pid;
+	int eth0_received;
+
+	int	eth0_monitor_interval;
+	struct timer_list	eth0_monitor_timer;
+
+#if 0
+#if defined (STP_DISABLE_ETH)
+	struct timer_list	eth0_autostp_timer;
+#endif
+#endif
+
+#if defined (STP_ADDCOST_ETH)
+	int is_cost_changed;
+#endif
+
+#endif //CONFIG_RTK_MESH
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	int igmpProxy_pid;
+	struct timer_list	mCastQuerytimer;
+#endif
 };
 
 extern struct notifier_block br_device_notifier;
@@ -176,6 +291,18 @@ extern int br_forward_finish(struct sk_b
 extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
 extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+void br_multicast_deliver(struct net_bridge *br,
+			unsigned int fwdPortMask, 
+			struct sk_buff *skb,
+			int clone);
+
+void br_multicast_forward(struct net_bridge *br,
+                        unsigned int fwdPortMask,
+                        struct sk_buff *skb,
+                        int clone);
+#endif
+
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);
 extern int br_add_bridge(struct net *net, const char *name);
@@ -188,6 +315,10 @@ extern int br_del_if(struct net_bridge *
 extern int br_min_mtu(const struct net_bridge *br);
 extern void br_features_recompute(struct net_bridge *br);
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+extern  int br_initial_port_cost(struct net_device *dev);
+#endif
+
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);
 extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
--- linux-2.6.30.9/net/bridge/br_private_stp.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_private_stp.h	2013-05-02 01:47:59.220226613 +0300
@@ -49,6 +49,14 @@ extern void br_transmit_config(struct ne
 extern void br_transmit_tcn(struct net_bridge *br);
 extern void br_topology_change_detection(struct net_bridge *br);
 
+#if defined (CONFIG_RTK_MESH)
+extern void br_signal_pathsel(struct net_bridge *br);
+#if defined (STP_ADDCOST_ETH)
+extern void br_reset_cost(struct net_bridge_port * p);
+#endif
+#endif
+
+
 /* br_stp_bpdu.c */
 extern void br_send_config_bpdu(struct net_bridge_port *, struct br_config_bpdu *);
 extern void br_send_tcn_bpdu(struct net_bridge_port *);
--- linux-2.6.30.9/net/bridge/br_stp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp.c	2013-05-02 01:47:59.220226613 +0300
@@ -16,6 +16,11 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
 /* since time values in bpdu are in jiffies and then scaled (1/256)
  * before sending, make sure that is at least one.
  */
@@ -323,8 +328,15 @@ void br_config_bpdu_generation(struct ne
 	list_for_each_entry(p, &br->port_list, list) {
 		if (p->state != BR_STATE_DISABLED &&
 		    br_is_designated_port(p))
+			{
+#if defined (CONFIG_RTL_STP)
+				// bpdu not tx at eth0, because bpdu tx at virtual device port0~3 mapping to physical port0~3
+				if(memcmp((void *)(p->dev->name), "eth0", 4)==0)
+					continue;
+#endif
 			br_transmit_config(p);
 	}
+	}
 }
 
 /* called under bridge lock */
@@ -356,15 +368,161 @@ void br_become_designated_port(struct ne
 /* called under bridge lock */
 static void br_make_blocking(struct net_bridge_port *p)
 {
+#if defined (CONFIG_RTK_MESH)
+#if defined (STP_ADDCOST_ETH) || defined (STP_DISABLE_ETH) 
+//Chris:  stp+mesh
+	struct net_bridge_port *tp,*n;
+#endif
+#endif //CONFIG_RTK_MESH
+
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	if (p->state != BR_STATE_DISABLED &&
 	    p->state != BR_STATE_BLOCKING) {
 		if (p->state == BR_STATE_FORWARDING ||
 		    p->state == BR_STATE_LEARNING)
 			br_topology_change_detection(p->br);
 
+#if defined (CONFIG_RTK_MESH)
+#if 0
+#if defined (STP_DISABLE_ETH)
+// Chris: stp+mesh. if the blocking port is mesh, we disable the eth0 to avoid isolated MP
+// 			NOTE: MUST resume the interface after loop disapeared
+		if (!strncmp(p->dev->name, "wlan0-msh0", 10)){
+			
+			list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+			{
+				if (!strncmp(tp->dev->name, "eth", 3) && (tp->state != BR_STATE_DISABLED))
+				{
+					tp->disable_by_mesh = 1;
+					br_stp_disable_port(tp);
+					printk(KERN_INFO "%s: port %i(%s) entering %s state\n",
+	  				    tp->br->dev->name, tp->port_no, tp->dev->name, "disabled if mesh blocked");
+				}
+	         
+			}
+	
+		}
+		else
+		{
+			p->state = BR_STATE_BLOCKING;
+			br_log_state(p);
+			del_timer(&p->forward_delay_timer);
+		}
+#endif
+#endif
+
+#if defined (STP_ADDCOST_ETH)
+// Chris:  stp+mesh. Add cost on eth to block it. 
+//		 NOTE: should set to default cost when topology changed
+		if (!strncmp(p->dev->name, "wlan0-msh0", 10)){
+			list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+			{
+				if (tp!=p && (tp->state != BR_STATE_DISABLED)){
+					br_stp_set_path_cost(tp, tp->path_cost+50);
+					printk(KERN_INFO "%s: port %i(%s) set path_cost %d \n",
+	  				    tp->br->dev->name, tp->port_no, tp->dev->name, tp->path_cost);
+					p->br->is_cost_changed = 1;
+				}
+			}
+		}else {
+			p->state = BR_STATE_BLOCKING;
+			br_log_state(p);
+			del_timer(&p->forward_delay_timer);
+		}
+		
+#endif
+#endif
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+
+		#ifdef CONFIG_RTK_MESH	
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port !=WLAN_MESH_PSEUDO_IF_INDEX) &&  (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_BLOCKING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_BLOCKING);
+		}
+		else if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH	
+		else if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+#if defined (CONFIG_RTK_MESH)		
+#else
 		p->state = BR_STATE_BLOCKING;
 		br_log_state(p);
 		del_timer(&p->forward_delay_timer);
+#endif		
 	}
 }
 
@@ -373,6 +531,16 @@ static void br_make_forwarding(struct ne
 {
 	struct net_bridge *br = p->br;
 
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	if (p->state != BR_STATE_BLOCKING)
 		return;
 
@@ -382,9 +550,159 @@ static void br_make_forwarding(struct ne
 		del_timer(&p->forward_delay_timer);
 	}
 	else if (p->br->stp_enabled == BR_KERNEL_STP)
+	{
 		p->state = BR_STATE_LISTENING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LISTENING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LISTENING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LISTENING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LISTENING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
 	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LISTENING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LISTENING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+	}
+	else
+	{
 		p->state = BR_STATE_LEARNING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];	
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LEARNING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LEARNING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+	}
 
 	br_log_state(p);
 
@@ -469,8 +787,31 @@ void br_received_tcn_bpdu(struct net_bri
 	if (br_is_designated_port(p)) {
 		pr_info("%s: received tcn bpdu on port %i(%s)\n",
 		       p->br->dev->name, p->port_no, p->dev->name);
-
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+		br_reset_cost(p);
+#endif
 		br_topology_change_detection(p->br);
 		br_topology_change_acknowledge(p);
 	}
 }
+
+
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+
+/* called under bridge lock */
+void br_reset_cost(struct net_bridge_port *p){
+	struct net_bridge_port *tp,*n;
+	
+	if (p->br->is_cost_changed) {
+		list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+		{
+			if (strncmp(tp->dev->name, "wlan0-msh0", 10)){
+				tp->path_cost = br_initial_port_cost(tp->dev);
+				printk(KERN_INFO "%s: port %i(%s) set default path_cost %d \n",
+					    tp->br->dev->name, tp->port_no, tp->dev->name, tp->path_cost);
+			}
+		}
+		p->br->is_cost_changed = 0;
+	}
+}
+#endif
--- linux-2.6.30.9/net/bridge/br_stp_if.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp_if.c	2013-05-02 01:47:59.221226613 +0300
@@ -18,6 +18,10 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
 
 /* Port id is composed of priority and port number.
  * NB: least significant bits of priority are dropped to
@@ -32,11 +36,111 @@ static inline port_id br_make_port_id(__
 /* called under bridge lock */
 void br_init_port(struct net_bridge_port *p)
 {
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	p->port_id = br_make_port_id(p->priority, p->port_no);
 	br_become_designated_port(p);
 	p->state = BR_STATE_BLOCKING;
+	
+#if defined (CONFIG_RTL_STP)
+	if(strncmp(p->dev->name,"port",4) == 0)
+	{
+
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#if defined (CONFIG_RTK_MESH)
+		if((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) &&(Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_BLOCKING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_BLOCKING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return ;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return ;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#endif
+		else if(Port == NO_MAPPING)
+		{
+			p->state = BR_STATE_DISABLED;
+		}
+	}
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+	
 	p->topology_change_ack = 0;
 	p->config_pending = 0;
+#if 0
+// Chris: stp+mesh
+#ifdef STP_DISABLE_ETH
+	p->disable_by_mesh = 0;
+	del_timer(&p->eth_disable_timer);
+	init_timer(&p->eth_disable_timer);
+#endif
+#endif
+
 }
 
 /* called under bridge lock */
@@ -66,7 +170,15 @@ void br_stp_disable_bridge(struct net_br
 	spin_lock_bh(&br->lock);
 	list_for_each_entry(p, &br->port_list, list) {
 		if (p->state != BR_STATE_DISABLED)
+	{
+	#if 0
+	#if defined (STP_DISABLE_ETH)
+	//Chris:  stp+mesh
+			p->disable_by_mesh = 0;
+	#endif
+	#endif 
 			br_stp_disable_port(p);
+}
 
 	}
 
@@ -92,8 +204,50 @@ void br_stp_disable_port(struct net_brid
 {
 	struct net_bridge *br;
 	int wasroot;
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
 
 	br = p->br;
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 	printk(KERN_INFO "%s: port %i(%s) entering %s state\n",
 	       br->dev->name, p->port_no, p->dev->name, "disabled");
 
@@ -109,6 +263,18 @@ void br_stp_disable_port(struct net_brid
 
 	br_fdb_delete_by_port(br, p, 0);
 
+#if 0
+#if defined (STP_DISABLE_ETH)
+	// Chris: stp+mesh
+	if (p->disable_by_mesh == 0)
+		del_timer(&p->eth_disable_timer);
+	else {
+		//printk("set disable timer\n");
+		mod_timer(&p->eth_disable_timer, jiffies+ETH_CHK_INTVL);
+	}
+#endif
+#endif
+
 	br_configuration_update(br);
 
 	br_port_state_selection(br);
--- linux-2.6.30.9/net/bridge/br_stp_timer.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp_timer.c	2013-05-02 01:47:59.221226613 +0300
@@ -17,6 +17,17 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+//static void br_eth_disable_timer_expired(unsigned long arg);
+static void br_eth0_monitor_timer_expired(unsigned long arg);
+//static void br_eth0_autostp_timer_expired(unsigned long arg);
+#endif	//CONFIG_RTK_MESH
+
 /* called under bridge lock */
 static int br_is_designated_for_some_port(const struct net_bridge *br)
 {
@@ -63,6 +74,10 @@ static void br_message_age_timer_expired
 		id->addr[3], id->addr[4], id->addr[5],
 		p->port_no, p->dev->name);
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+	br_reset_cost(p);
+#endif
+	
 	/*
 	 * According to the spec, the message age timer cannot be
 	 * running when we are the root bridge. So..  this was_root
@@ -87,15 +102,173 @@ static void br_forward_delay_timer_expir
 	struct net_bridge_port *p = (struct net_bridge_port *) arg;
 	struct net_bridge *br = p->br;
 
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	pr_debug("%s: %d(%s) forward delay timer\n",
 		 br->dev->name, p->port_no, p->dev->name);
 	spin_lock(&br->lock);
 	if (p->state == BR_STATE_LISTENING) {
 		p->state = BR_STATE_LEARNING;
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#if defined (CONFIG_RTK_MESH)
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LEARNING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LEARNING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 		mod_timer(&p->forward_delay_timer,
 			  jiffies + br->forward_delay);
 	} else if (p->state == BR_STATE_LEARNING) {
 		p->state = BR_STATE_FORWARDING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+
+		#if defined (CONFIG_RTK_MESH)
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) &&(Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_FORWARDING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_FORWARDING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_FORWARDING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_FORWARDING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_FORWARDING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_FORWARDING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 		if (br_is_designated_for_some_port(br))
 			br_topology_change_detection(br);
 	}
@@ -154,7 +327,65 @@ void br_stp_timer_init(struct net_bridge
 		      (unsigned long) br);
 
 	setup_timer(&br->gc_timer, br_fdb_cleanup, (unsigned long) br);
+
+	#if defined (CONFIG_RTK_MESH)
+	setup_timer(&br->eth0_monitor_timer,
+		      br_eth0_monitor_timer_expired,
+		      (unsigned long) br);
+	/*
+	#if defined (STP_DISABLE_ETH)
+	setup_timer(&br->eth0_autostp_timer,
+		      br_eth0_autostp_timer_expired,
+		      (unsigned long) br);
+	#endif
+	*/
+	#endif
+}
+
+#if defined (CONFIG_RTK_MESH)
+static void br_eth0_monitor_timer_expired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge *) arg;
+	br->eth0_received = 0;
+	br->stp_enabled = 0;
+	br_signal_pathsel(br);
+	printk("%d seconds never receive packet from eth0 \n",MESH_PORTAL_EXPIRE);
+	return;
+	
+}
+
+#if 0
+
+#if defined (STP_DISABLE_ETH)
+static void br_eth_disable_timer_expired(unsigned long arg)
+{
+
+//Chris: stp+mesh
+	struct net_bridge_port *p = (struct net_bridge_port *) arg;
+	printk(KERN_INFO "%s: enabled for MESH-STP configuration\n", p->br->dev->name);
+	if(p->disable_by_mesh == 1)
+	{
+		br_stp_enable_port(p);
+	}
+	p->disable_by_mesh=0;
+	return;
+	
 }
+#endif
+
+static void br_eth0_autostp_timer_expired(unsigned long arg)
+{
+
+//Chris: stp+mesh
+	struct net_bridge *br = (struct net_bridge *) arg;
+	mod_timer(&br->eth0_autostp_timer, jiffies+ br->eth0_monitor_interval);
+	br->stp_enabled = 0;
+
+	return;
+}
+#endif
+
+#endif	//CONFIG_RTK_MESH
 
 void br_stp_port_timer_init(struct net_bridge_port *p)
 {
@@ -166,6 +397,13 @@ void br_stp_port_timer_init(struct net_b
 
 	setup_timer(&p->hold_timer, br_hold_timer_expired,
 		      (unsigned long) p);
+
+	#if defined (CONFIG_RTK_MESH)
+	#if defined (STP_DISABLE_ETH)
+	setup_timer(&p->eth_disable_timer, br_eth_disable_timer_expired,
+		      (unsigned long) p);
+	#endif
+	#endif
 }
 
 /* Report ticks left (in USER_HZ) used for API */
--- linux-2.6.30.9/net/bridge/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/Kconfig	2013-05-02 01:47:59.216226614 +0300
@@ -31,3 +31,18 @@ config BRIDGE
 	  will be called bridge.
 
 	  If unsure, say N.
+config RTL_STP
+        bool "Enable RealTek STP"
+        default n
+        depends on BRIDGE
+
+config RTL_WLAN_BLOCK_RELAY
+	bool
+	default y
+	depends on BRIDGE
+
+config RTL_HW_STP
+        bool "Enable RealTek Hardware STP"
+        default n
+        depends on BRIDGE
+
--- linux-2.6.30.9/net/bridge/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/bridge/Makefile	2013-05-02 01:47:59.216226614 +0300
@@ -2,6 +2,10 @@
 # Makefile for the IEEE 802.1d ethernet bridging layer.
 #
 
+ifeq ($(CONFIG_RTL_MESH_SUPPORT),y)
+        EXTRA_CFLAGS += -DCONFIG_RTK_MESH
+endif
+
 obj-$(CONFIG_BRIDGE) += bridge.o
 
 bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o \
@@ -10,6 +14,16 @@ bridge-y	:= br.o br_device.o br_fdb.o br
 
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
+bridge-$(CONFIG_RTL865X_LANPORT_RESTRICTION) += ../rtl/features/lan_restrict.o
+
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
 
+obj-$(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) += pocket_filter.o
+ifeq ($(CONFIG_RTL_ULINKER),y)
+        obj-y += pocket_filter.o
+endif
+
 obj-$(CONFIG_BRIDGE_NF_EBTABLES) += netfilter/
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
+#EXTRA_CFLAGS += -I$(DIR_LINUX)/drivers/net/rtl819x/
--- linux-2.6.30.9/net/core/dev.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/dev.c	2013-05-02 01:47:59.231226613 +0300
@@ -127,8 +127,18 @@
 #include <linux/jhash.h>
 #include <linux/random.h>
 
+#include <net/rtl/rtl_types.h>
+#include <linux/inetdevice.h>
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+#include <net/rtl/rtl_nic.h>
+#endif
+
 #include "net-sysfs.h"
 
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+#include <net/rtl/features/rtl_ps_log.h>
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
 
@@ -1111,6 +1121,11 @@ int dev_open(struct net_device *dev)
 	return ret;
 }
 
+#if defined(CONFIG_RTL_FAST_PPPOE)
+int clear_pppoe_info(char *ppp_dev, char *wan_dev, unsigned short sid,
+								unsigned int our_ip,unsigned int	peer_ip,
+								unsigned char * our_mac, unsigned char *peer_mac);
+#endif
 /**
  *	dev_close - shutdown an interface.
  *	@dev: device to shutdown
@@ -1129,6 +1144,9 @@ int dev_close(struct net_device *dev)
 
 	if (!(dev->flags & IFF_UP))
 		return 0;
+#if defined(CONFIG_RTL_FAST_PPPOE)
+		clear_pppoe_info(dev->name,dev->name,0,0,0,NULL,NULL);
+#endif
 
 	/*
 	 *	Tell people we are going down, so that they can
@@ -1164,6 +1182,14 @@ int dev_close(struct net_device *dev)
 
 	dev->flags &= ~IFF_UP;
 
+#if defined(CONFIG_RTL_FASTBRIDGE)
+	/*
+	 *	Clear fast bridge related cache.
+	 */
+	printk("[%s] closed\n", dev->name);
+	rtl_fb_flush_by_dev(dev);
+#endif
+
 	/*
 	 * Tell people we are down
 	 */
@@ -1399,6 +1425,25 @@ void __netif_schedule(struct Qdisc *q)
 }
 EXPORT_SYMBOL(__netif_schedule);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
+__MIPS16 __IRAM_FWD  extern int is_rtl865x_eth_priv_buf(unsigned char *head);
+int get_cpu_completion_queue_num(void)
+{
+	int skbCnt = 0;
+	struct softnet_data *sd = &__get_cpu_var(softnet_data);
+	struct sk_buff *clist = sd->completion_queue;
+
+	while (clist)
+	{
+		if(is_rtl865x_eth_priv_buf(clist->head))
+			skbCnt++;
+		clist = clist->next;
+	}
+
+	return skbCnt;
+}
+#endif
+
 void dev_kfree_skb_irq(struct sk_buff *skb)
 {
 	if (atomic_dec_and_test(&skb->users)) {
@@ -1677,6 +1722,10 @@ int dev_hard_start_xmit(struct sk_buff *
 	const struct net_device_ops *ops = dev->netdev_ops;
 	int rc;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_dev_hard_start_xmit_hooks(skb, dev, txq);
+	#endif
+
 	if (likely(!skb->next)) {
 		if (!list_empty(&ptype_all))
 			dev_queue_xmit_nit(skb, dev);
@@ -1725,7 +1774,12 @@ gso:
 	skb->destructor = DEV_GSO_CB(skb)->destructor;
 
 out_kfree_skb:
+#if CONFIG_RTL_819X
+	dev_kfree_skb_any(skb);
+#else
 	kfree_skb(skb);
+#endif
+
 	return 0;
 }
 
@@ -1805,6 +1859,10 @@ int dev_queue_xmit(struct sk_buff *skb)
 	    __skb_linearize(skb))
 		goto out_kfree_skb;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_dev_queue_xmit_hooks(skb, dev);
+	#endif
+
 	/* Fragmented skb is linearized if device does not support SG,
 	 * or if at least one of fragments is in highmem and device
 	 * does not support DMA from it.
@@ -1846,7 +1904,14 @@ gso:
 			rc = NET_XMIT_DROP;
 		} else {
 			rc = qdisc_enqueue_root(skb, q);
+#ifdef CONFIG_NET_SCHED
+			if(gQosEnabled)
+				__netif_schedule(q);
+			else
+				qdisc_run(q);
+#else
 			qdisc_run(q);
+#endif
 		}
 		spin_unlock(root_lock);
 
@@ -1908,12 +1973,65 @@ out:
 			Receiver routines
   =======================================================================*/
 
-int netdev_max_backlog __read_mostly = 1000;
-int netdev_budget __read_mostly = 300;
-int weight_p __read_mostly = 64;            /* old backlog weight */
+int netdev_max_backlog __read_mostly = 512;	//1000;
+int netdev_budget __read_mostly = 128;	//300;
+int weight_p __read_mostly = 128;		//64;            /* old backlog weight */
 
 DEFINE_PER_CPU(struct netif_rx_stats, netdev_rx_stat) = { 0, };
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+extern int rtl865x_curOpMode;
+struct net_device *rtl865x_getBattleNetWanDev(void )
+{
+	struct net_device * wanDev=NULL;
 
+	if(rtl865x_curOpMode==GATEWAY_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"ppp0");
+		if(wanDev == NULL)
+			wanDev=__dev_get_by_name(&init_net,"eth1");
+	}
+	else if(rtl865x_curOpMode==WISP_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"wlan0");
+	}
+	else if(rtl865x_curOpMode==BRIDGE_MODE)
+	{
+		wanDev=__dev_get_by_name(&init_net,"br0");
+	}
+
+	return wanDev;
+}
+
+int rtl865x_getBattleNetDevIpAndNetmask(struct net_device * dev, unsigned int *ipAddr, unsigned int *netMask )
+{
+	struct in_device *in_dev;
+	struct in_ifaddr *ifap = NULL;
+
+	if((dev==NULL) || (ipAddr==NULL) || (netMask==NULL))
+	{
+		return FAILED;
+	}
+
+	*ipAddr=0;
+	*netMask=0;
+
+	in_dev=(struct net_device *)(dev->ip_ptr);
+	if (in_dev != NULL) {
+		for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+			if (strcmp(dev->name, ifap->ifa_label) == 0){
+				*ipAddr = ifap->ifa_address;
+				*netMask = ifap->ifa_mask;
+				return SUCCESS;
+			}
+		}
+
+	}
+
+	return FAILED;
+
+}
+
+#endif
 
 /**
  *	netif_rx	-	post buffer to the network code
@@ -2199,6 +2318,9 @@ void netif_nit_deliver(struct sk_buff *s
 	rcu_read_unlock();
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int rtl865x_ipMulticastFastFwd(struct sk_buff * skb);
+#endif
 /**
  *	netif_receive_skb - process receive buffer from network
  *	@skb: buffer to process
@@ -2222,6 +2344,25 @@ int netif_receive_skb(struct sk_buff *sk
 	int ret = NET_RX_DROP;
 	__be16 type;
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(rtl865x_localPublicRx(skb)==NET_RX_DROP)
+	{
+		return NET_RX_DROP;
+	}
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(rtl865x_ipMulticastFastFwd(skb)==0)
+	{
+		return NET_RX_SUCCESS;
+	}
+#endif
+
+	#if	defined(CONFIG_RTL_819X)
+	if (rtl_netif_receive_skb_hooks(&skb)==RTL_PS_HOOKS_RETURN)
+		return NET_RX_SUCCESS;
+	#endif
+
 	if (skb->vlan_tci && vlan_hwaccel_do_receive(skb))
 		return NET_RX_SUCCESS;
 
@@ -4786,6 +4927,9 @@ struct net_device *alloc_netdev_mq(int s
 
 	dev->gso_max_size = GSO_MAX_SIZE;
 
+	if (sizeof_priv)
+		dev->priv = netdev_priv(dev);
+
 	netdev_init_queues(dev);
 
 	INIT_LIST_HEAD(&dev->napi_list);
@@ -5219,6 +5363,10 @@ static int __init net_dev_init(void)
 {
 	int i, rc = -ENOMEM;
 
+	netdev_max_backlog = 512;	//1000;
+	netdev_budget = 128;	//300;
+	weight_p = 128;		//64;            /* old backlog weight */
+
 	BUG_ON(!dev_boot_phase);
 
 	if (dev_proc_init())
--- linux-2.6.30.9/net/core/dst.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/dst.c	2013-05-02 01:47:59.232226612 +0300
@@ -20,6 +20,8 @@
 
 #include <net/dst.h>
 
+#include <net/rtl/features/rtl_ps_hooks.h>
+
 /*
  * Theory of operations:
  * 1) We use a list, protected by a spinlock, to add
@@ -40,16 +42,18 @@ static atomic_t			 dst_total = ATOMIC_IN
  * to dirty as few cache lines as possible in __dst_free().
  * As this is not a very strong hint, we dont force an alignment on SMP.
  */
-static struct {
+/*struct dst_gc{
 	spinlock_t		lock;
 	struct dst_entry 	*list;
 	unsigned long		timer_inc;
 	unsigned long		timer_expires;
-} dst_garbage = {
+};
+*/
+struct dst_gc dst_garbage = {
 	.lock = __SPIN_LOCK_UNLOCKED(dst_garbage.lock),
 	.timer_inc = DST_GC_MAX,
 };
-static void dst_gc_task(struct work_struct *work);
+void dst_gc_task(struct work_struct *work);
 static void ___dst_free(struct dst_entry * dst);
 
 static DECLARE_DELAYED_WORK(dst_gc_work, dst_gc_task);
@@ -60,7 +64,7 @@ static DEFINE_MUTEX(dst_gc_mutex);
  */
 static struct dst_entry         *dst_busy_list;
 
-static void dst_gc_task(struct work_struct *work)
+void dst_gc_task(struct work_struct *work)
 {
 	int    delayed = 0;
 	int    work_performed = 0;
@@ -152,7 +156,34 @@ loop:
 		elapsed.tv_sec * USEC_PER_SEC + elapsed.tv_nsec / NSEC_PER_USEC);
 #endif
 }
+#if 0
+int hyking_print_busy_list(void)
+{
+	struct dst_entry *dst, *next;
+	struct rtable *rth;
+	int busy_cnt = 0;
+	
+	mutex_lock(&dst_gc_mutex);
+	next = dst_busy_list;
+
+	printk("busy_list entry info:\n");
+	while ((dst = next) != NULL) 
+	{
+		next = dst->next;
+		prefetch(&next->next);
 
+		busy_cnt++;		
+		rth = (struct rtable*)dst;
+		printk("sip(%u.%u.%u.%u),dip(%u.%u.%u.%u),rt_genid(%d),dst->ops(0x%x),dst->hy1(0x%x),dst->refcnt(%d)\n",NIPQUAD(rth->rt_src),NIPQUAD(rth->rt_dst),rth->rt_genid,
+				rth->u.dst.ops,rth->u.dst.hyking_test1,atomic_read(&rth->u.dst.__refcnt));		
+	}
+	mutex_unlock(&dst_gc_mutex);
+	
+	printk("=====%s(%d), busy_cnt(%d)\n",__FUNCTION__,__LINE__,busy_cnt);
+
+	return 0;
+}
+#endif
 int dst_discard(struct sk_buff *skb)
 {
 	kfree_skb(skb);
@@ -160,17 +191,32 @@ int dst_discard(struct sk_buff *skb)
 }
 EXPORT_SYMBOL(dst_discard);
 
+extern int ip_rt_max_size;
 void * dst_alloc(struct dst_ops * ops)
 {
 	struct dst_entry * dst;
 
 	if (ops->gc && atomic_read(&ops->entries) > ops->gc_thresh) {
-		if (ops->gc(ops))
+
+		if(rtl_dst_alloc_gc_pre_check_hooks(ops) == RTL_PS_HOOKS_RETURN)
 			return NULL;
+		
+		if (ops->gc(ops)){
+			rtl_dst_alloc_gc_post_check1_hooks(ops);
+			
+			return NULL;
+		}
 	}
+
+//hyking:so .....	
+	if(atomic_read(&ops->entries) > ip_rt_max_size){
+		return NULL;
+	}
+	
 	dst = kmem_cache_zalloc(ops->kmem_cachep, GFP_ATOMIC);
-	if (!dst)
+	if (!dst){
 		return NULL;
+	}
 	atomic_set(&dst->__refcnt, 0);
 	dst->ops = ops;
 	dst->lastuse = jiffies;
@@ -180,6 +226,8 @@ void * dst_alloc(struct dst_ops * ops)
 	atomic_inc(&dst_total);
 #endif
 	atomic_inc(&ops->entries);
+
+	rtl_dst_alloc_gc_post_check2_hooks(ops, dst);
 	return dst;
 }
 
--- linux-2.6.30.9/net/core/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/Makefile	2013-05-02 01:47:59.229226613 +0300
@@ -20,3 +20,7 @@ obj-$(CONFIG_FIB_RULES) += fib_rules.o
 obj-$(CONFIG_TRACEPOINTS) += net-traces.o
 obj-$(CONFIG_NET_DROP_MONITOR) += drop_monitor.o
 
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x/
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/wireless/rtl8190/
+
--- linux-2.6.30.9/net/core/neighbour.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/neighbour.c	2013-05-02 01:47:59.236226612 +0300
@@ -36,6 +36,21 @@
 #include <linux/string.h>
 #include <linux/log2.h>
 
+#include <net/rtl/rtl_types.h>
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#include <net/rtl/rtl865x_ppp.h>
+#include <net/rtl/rtl865x_route_api.h>
+#include <net/rtl/rtl865x_arp_api.h>
+#endif
+
+#if defined(CONFIG_RTL_MULTIPLE_WAN)
+#include <net/arp.h>
+#endif
+
+#if defined (CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -149,6 +166,11 @@ static int neigh_forced_gc(struct neigh_
 				*np	= n->next;
 				n->dead = 1;
 				shrunk	= 1;
+				#if defined(CONFIG_RTL_819X)
+				/*delete asic arp entry*/
+				rtl_neigh_forced_gc_hooks(tbl, n);
+				#endif
+
 				write_unlock(&n->lock);
 				neigh_cleanup_and_release(n);
 				continue;
@@ -222,10 +244,16 @@ static void neigh_flush_dev(struct neigh
 				   we must kill timers etc. and move
 				   it to safe state.
 				 */
+				#if defined(CONFIG_RTL_819X)
+				/*delete asic arp entry*/
+				rtl_neigh_flush_dev_hooks(tbl, dev, n);
+				#endif
 				skb_queue_purge(&n->arp_queue);
 				n->output = neigh_blackhole;
 				if (n->nud_state & NUD_VALID)
+				{
 					n->nud_state = NUD_NOARP;
+				}
 				else
 					n->nud_state = NUD_NONE;
 				NEIGH_PRINTK2("neigh %p is stray.\n", n);
@@ -623,6 +651,11 @@ void neigh_destroy(struct neighbour *nei
 {
 	struct hh_cache *hh;
 
+	#if defined(CONFIG_RTL_819X)
+	/*delete asic arp entry*/
+	rtl_neigh_destroy_hooks(neigh);
+	#endif
+
 	NEIGH_CACHE_STAT_INC(neigh->tbl, destroys);
 
 	if (!neigh->dead) {
@@ -685,6 +718,9 @@ static void neigh_connect(struct neighbo
 	struct hh_cache *hh;
 
 	NEIGH_PRINTK2("neigh %p is connected.\n", neigh);
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_connect_hooks(neigh);
+	#endif
 
 	neigh->output = neigh->ops->connected_output;
 
@@ -734,8 +770,22 @@ static void neigh_periodic_timer(unsigne
 		if (atomic_read(&n->refcnt) == 1 &&
 		    (state == NUD_FAILED ||
 		     time_after(now, n->used + n->parms->gc_staletime))) {
+
+			#if defined(CONFIG_RTL_819X)
+			if (RTL_PS_HOOKS_BREAK==rtl_neigh_periodic_timer_hooks(n, 0)) {
+				write_unlock(&n->lock);
+				goto next_elt;
+			}
+
+			#if 0
+			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x,n->nud_state is 0x%x,tval is %d\n",
+			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)n->primary_key))), n->ha[0], n->ha[1],
+			n->ha[2], n->ha[3], n->ha[4], n->ha[5],n->nud_state,tval);
+			#endif
+			#endif
 			*np = n->next;
 			n->dead = 1;
+
 			write_unlock(&n->lock);
 			neigh_cleanup_and_release(n);
 			continue;
@@ -793,6 +843,11 @@ static void neigh_timer_handler(unsigned
 		goto out;
 	}
 
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_pre_update_hooks(neigh, state);
+	#endif
+
 	if (state & NUD_REACHABLE) {
 		if (time_before_eq(now,
 				   neigh->confirmed + neigh->parms->reachable_time)) {
@@ -833,6 +888,10 @@ static void neigh_timer_handler(unsigned
 		next = now + neigh->parms->retrans_time;
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_during_update_hooks(neigh, state);
+	#endif
+
 	if ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
 	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
 		struct sk_buff *skb;
@@ -880,6 +938,10 @@ out:
 	if (notify)
 		neigh_update_notify(neigh);
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_post_update_hooks(neigh, state);
+	#endif
+
 	neigh_release(neigh);
 }
 
@@ -896,6 +958,10 @@ int __neigh_event_send(struct neighbour
 
 	now = jiffies;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl___neigh_event_send_pre_hooks(neigh, skb);
+	#endif
+
 	if (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh->parms->mcast_probes + neigh->parms->app_probes) {
 			atomic_set(&neigh->probes, neigh->parms->ucast_probes);
@@ -918,6 +984,10 @@ int __neigh_event_send(struct neighbour
 				jiffies + neigh->parms->delay_probe_time);
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	rtl___neigh_event_send_post_hooks(neigh, skb);
+	#endif
+
 	if (neigh->nud_state == NUD_INCOMPLETE) {
 		if (skb) {
 			if (skb_queue_len(&neigh->arp_queue) >=
@@ -1071,6 +1142,12 @@ int neigh_update(struct neighbour *neigh
 			neigh->confirmed = jiffies -
 				      (neigh->parms->base_reachable_time << 1);
 		notify = 1;
+
+		#if defined(CONFIG_RTL_819X)
+		/*careful:should put these code after "memcpy(&neigh->ha, lladdr, dev->addr_len);"*/
+		/*different mac address, and add new arp mapping entry*/
+		rtl_neigh_update_hooks(neigh, lladdr, old);
+		#endif
 	}
 	if (new == old)
 		goto out;
@@ -1101,6 +1178,13 @@ out:
 			(neigh->flags | NTF_ROUTER) :
 			(neigh->flags & ~NTF_ROUTER);
 	}
+
+	#if defined(CONFIG_RTL_819X)
+	/*careful:should put these code after "memcpy(&neigh->ha, lladdr, dev->addr_len);"*/
+	/*different mac address, and add new arp mapping entry*/
+	rtl_neigh_update_post_hooks(neigh, lladdr, old);
+	#endif
+
 	write_unlock_bh(&neigh->lock);
 
 	if (notify)
@@ -2820,6 +2904,10 @@ static int __init neigh_init(void)
 	rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info);
 	rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL);
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_init_hooks();
+	#endif
+
 	return 0;
 }
 
--- linux-2.6.30.9/net/core/skbuff.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/skbuff.c	2013-05-02 01:47:59.241226612 +0300
@@ -68,6 +68,14 @@
 #include <trace/skb.h>
 
 #include "kmap_skb.h"
+#if defined(CONFIG_RTL_ETH_PRIV_SKB)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+#ifdef CONFIG_RTL8190_PRIV_SKB
+extern int is_rtl8190_priv_buf(unsigned char *head);
+extern void free_rtl8190_priv_buf(unsigned char *head);
+#endif
 
 static struct kmem_cache *skbuff_head_cache __read_mostly;
 static struct kmem_cache *skbuff_fclone_cache __read_mostly;
@@ -183,7 +191,12 @@ struct sk_buff *__alloc_skb(unsigned int
 	if (!skb)
 		goto out;
 
+#if defined(CONFIG_RTL_819X) || defined(CONFIG_RTL8192CD) || defined(CONFIG_RTL8190) || defined(CONFIG_RTL8192SE)
+	size = SKB_DATA_ALIGN(size+RTL_PRIV_DATA_SIZE);
+#else
 	size = SKB_DATA_ALIGN(size);
+#endif
+
 	data = kmalloc_node_track_caller(size + sizeof(struct skb_shared_info),
 			gfp_mask, node);
 	if (!data)
@@ -201,6 +214,36 @@ struct sk_buff *__alloc_skb(unsigned int
 	skb->data = data;
 	skb_reset_tail_pointer(skb);
 	skb->end = skb->tail + size;
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	skb->srcPort=0xFFFF;
+	skb->srcVlanId=0;
+#endif
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	skb->srcVlanPriority=0;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)|| defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) ||defined(CONFIG_RTL_MAC_FILTER_CARE_INPORT)
+	skb->srcPhyPort=0xFF;
+	skb->dstPhyPort=0xFF;
+#endif
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	skb->tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = NULL;
+#endif
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	skb->srcLocalPublicIp=0;
+	skb->fromLocalPublic=0;
+	skb->toLocalPublic=0;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	skb->inDev=NULL;
+#endif
+
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
 	atomic_set(&shinfo->dataref, 1);
@@ -231,6 +274,90 @@ nodata:
 }
 EXPORT_SYMBOL(__alloc_skb);
 
+#if defined(CONFIG_RTL8190_PRIV_SKB) || defined(CONFIG_RTL_ETH_PRIV_SKB)
+struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size)
+{
+        struct sk_buff *skb;
+	struct skb_shared_info *shinfo;
+
+ 	struct kmem_cache *cache;
+ 	cache = skbuff_head_cache;
+	/* Get the HEAD */
+        skb = kmem_cache_alloc(cache, GFP_ATOMIC & ~__GFP_DMA);
+        if (!skb)
+                goto out;
+
+        memset(skb, 0, offsetof(struct sk_buff, truesize));
+        atomic_set(&skb->users, 1);
+        skb->head = data;
+        skb->data = data;
+        skb->tail = data;
+
+	size = SKB_DATA_ALIGN(size+RTL_PRIV_DATA_SIZE+NET_SKB_PAD);
+
+        skb->end  = data + size;
+        skb->truesize = size + sizeof(struct sk_buff);
+
+        /* make sure we initialize shinfo sequentially */
+        shinfo = skb_shinfo(skb);
+        atomic_set(&shinfo->dataref, 1);
+        shinfo->nr_frags  = 0;
+        shinfo->gso_size = 0;
+        shinfo->gso_segs = 0;
+        shinfo->gso_type = 0;
+        shinfo->ip6_frag_id = 0;
+        shinfo->frag_list = NULL;
+
+#ifdef CONFIG_RTK_VOIP_VLAN_ID
+        skb->rx_vlan = 0;
+        skb->rx_wlan = 0;
+        skb->priority = 0;
+#endif
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	skb->srcPort=0xFFFF;
+	skb->srcVlanId=0;
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	skb->srcVlanPriority=0;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) ||defined(CONFIG_RTL_MAC_FILTER_CARE_INPORT)
+	skb->srcPhyPort=0xFF;
+	skb->dstPhyPort=0xFF;
+#endif
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	skb->tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = NULL;
+#endif
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	skb->srcLocalPublicIp=0;
+	skb->fromLocalPublic=0;
+	skb->toLocalPublic=0;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	skb->inDev=NULL;
+#endif
+
+#ifdef CONFIG_RTK_VOIP_VLAN_ID
+	skb_reserve(skb, RTL_PRIV_DATA_SIZE+4); // for VLAN TAG insertion
+#else
+	skb_reserve(skb, RTL_PRIV_DATA_SIZE);
+#endif
+
+        return skb;
+
+out:
+        return NULL;
+}
+#endif // CONFIG_RTL8190_PRIV_SKB
+
 /**
  *	__netdev_alloc_skb - allocate an skbuff for rx on a specific device
  *	@dev: network device to receive on
@@ -341,8 +468,23 @@ static void skb_release_data(struct sk_b
 		if (skb_shinfo(skb)->frag_list)
 			skb_drop_fraglist(skb);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB)
+		if (is_rtl865x_eth_priv_buf(skb->head)) {
+			free_rtl865x_eth_priv_buf(skb->head);
+		}
+		else
+#endif
+#ifdef CONFIG_RTL8190_PRIV_SKB
+		if (is_rtl8190_priv_buf(skb->head))
+		{
+			free_rtl8190_priv_buf(skb->head);
+		}
+		else
+#endif
+		{
 		kfree(skb->head);
 	}
+	}
 }
 
 /*
@@ -543,6 +685,25 @@ static void __copy_skb_header(struct sk_
     defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)
 	new->nf_trace		= old->nf_trace;
 #endif
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	new->srcPort=old->srcPort;
+	new->srcVlanId=old->srcPort;
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	new->srcVlanPriority=old->srcVlanPriority;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) ||defined(CONFIG_RTL_MAC_FILTER_CARE_INPORT)
+	new->srcPhyPort=old->srcPhyPort;
+	new->dstPhyPort=old->dstPhyPort;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	new->inDev=old->inDev;
+#endif
+
 #ifdef CONFIG_NET_SCHED
 	new->tc_index		= old->tc_index;
 #ifdef CONFIG_NET_CLS_ACT
@@ -575,6 +736,25 @@ static struct sk_buff *__skb_clone(struc
 	C(head);
 	C(data);
 	C(truesize);
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	C(srcPort);
+	C(srcVlanId);
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	C(srcVlanPriority);
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) ||defined(CONFIG_RTL_MAC_FILTER_CARE_INPORT)
+	C(srcPhyPort);
+	C(dstPhyPort);
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	C(inDev);
+#endif
+
 #if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
 	C(do_not_encrypt);
 	C(requeue);
@@ -636,11 +816,28 @@ struct sk_buff *skb_clone(struct sk_buff
 		n->fclone = SKB_FCLONE_UNAVAILABLE;
 	}
 
+//#define C(x) n->x = skb->x
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	//C(tag.v);
+	n->tag.v = skb->tag.v;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	n->src_info = skb->src_info;
+#endif
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	n->srcLocalPublicIp = skb->srcLocalPublicIp;
+	n->fromLocalPublic = skb->fromLocalPublic;
+	n->toLocalPublic = skb->toLocalPublic;
+#endif
 	return __skb_clone(n, skb);
 }
 EXPORT_SYMBOL(skb_clone);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB) || defined(CONFIG_NET_WIRELESS_AGN) || defined(CONFIG_NET_WIRELESS_AG) || defined(CONFIG_WIRELESS)
+void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
+#else
 static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
+#endif
 {
 #ifndef NET_SKBUFF_DATA_USES_OFFSET
 	/*
@@ -657,6 +854,17 @@ static void copy_skb_header(struct sk_bu
 	new->network_header   += offset;
 	new->mac_header	      += offset;
 #endif
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	new->tag.v = old->tag.v;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	new->src_info = old->src_info;
+#endif
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	new->srcLocalPublicIp=old->srcLocalPublicIp;
+	new->fromLocalPublic=old->fromLocalPublic;
+	new->toLocalPublic=old->toLocalPublic;
+#endif
 	skb_shinfo(new)->gso_size = skb_shinfo(old)->gso_size;
 	skb_shinfo(new)->gso_segs = skb_shinfo(old)->gso_segs;
 	skb_shinfo(new)->gso_type = skb_shinfo(old)->gso_type;
--- linux-2.6.30.9/net/core/sock.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/core/sock.c	2013-05-02 01:47:59.241226612 +0300
@@ -267,7 +267,90 @@ static void sock_disable_timestamp(struc
 	}
 }
 
+#if defined (CONFIG_RTL_SOCK_DEBUG)
 
+int dump_inet_sock(char *buf, struct inet_sock * inet)
+{
+	int len=0;
+	
+	if(buf==NULL)
+	{
+		return 0;
+	}
+	
+	if(inet==NULL)
+	{
+		return 0;
+	}
+	
+	len+=sprintf(buf+len,"daddr:0x%x,rcv_saddr:0x%x,dport:%d,num:%d,saddr:0x%x,uc_ttl:%d,sport:%d,id:%d,tos:%d,mc_ttl:%d,mc_index:%d,mc_addr:0x%x\n",
+		inet->daddr, inet->rcv_saddr,inet->dport,inet->num,inet->saddr,inet->uc_ttl,inet->sport,inet->id,inet->tos,inet->mc_ttl,inet->mc_index,inet->mc_addr);
+	
+	return len;
+
+}
+
+int dump_inet_timewait_sock(char *buf, struct inet_timewait_sock * inet_tw)
+{
+	int len=0;
+
+	if(buf==NULL)
+	{
+		return 0;
+	}
+	
+	if(inet_tw==NULL)
+	{
+		return 0;
+	}
+	
+	len+=sprintf(buf+len,"tw_sport:%d,tw_daddr:0x%x,tw_rcv_saddr:0x%x,tw_dport:%d,tw_num:%d\n",
+		inet_tw->tw_sport, inet_tw->tw_daddr,inet_tw->tw_rcv_saddr,inet_tw->tw_dport,inet_tw->tw_num);
+	
+	return len;
+
+}
+	
+int dump_sock_skb_info(char *buf, struct sock * sk)
+{
+	struct sk_buff *list=NULL;
+	unsigned int skbCnt=0;
+	
+	int len=0;
+
+	if(buf==NULL)
+	{
+		return 0;
+	}
+	
+	if(sk==NULL)
+	{
+		return 0;
+	}
+
+	//dump_inet_sock(inet_sk(sk));
+
+	list=(struct sk_buff *)(&sk->sk_receive_queue)->next;
+	while((list!=NULL) && (list!=(struct sk_buff *)(&sk->sk_receive_queue)))
+	{
+		//printk(".");
+		skbCnt++;
+		list= list->next;
+	}
+
+	list=sk->sk_backlog.head;
+	while((list!=NULL) && (list != sk->sk_backlog.head))
+	{
+		//printk(".");
+		skbCnt++;
+		list= list->next;
+	}
+	len+=sprintf(buf+len,"queued pkt num is %d\n",skbCnt);	
+	
+	return len;
+}
+
+#endif
 int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)
 {
 	int err = 0;
--- linux-2.6.30.9/net/ethernet/eth.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ethernet/eth.c	2013-05-02 01:47:59.263226610 +0300
@@ -346,7 +346,11 @@ void ether_setup(struct net_device *dev)
 	dev->hard_header_len 	= ETH_HLEN;
 	dev->mtu		= ETH_DATA_LEN;
 	dev->addr_len		= ETH_ALEN;
+#if defined(CONFIG_RTL_819X)
+	dev->tx_queue_len	= 0;	/* reduce queue size for max free sdram	*/
+#else
 	dev->tx_queue_len	= 1000;	/* Ethernet wants good queues */
+#endif
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 
 	memset(dev->broadcast, 0xFF, ETH_ALEN);
--- linux-2.6.30.9/net/ipv4/arp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/arp.c	2013-05-02 01:47:59.266226610 +0300
@@ -121,6 +121,51 @@ struct neigh_table *clip_tbl_hook;
 
 #include <linux/netfilter_arp.h>
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_localPublic.h>
+#endif
+
+#if defined(CONFIG_RTL8186_KB)
+#define	CACHE_GRATUITOUS_PERIOD		4
+#define	CACHE_MAC_LEN					6
+static unsigned long cache_gratuitous_jiffies = 0;
+static int	cache_gratuitous_cnt = 0;
+static __be32	cache_gratuitous_ip = 0;
+static u8 cache_gratuitous_mac[CACHE_MAC_LEN] = {0};
+static u8 cache_gratuitous_mac_peer[CACHE_MAC_LEN] = {0};
+static struct timer_list 	gratuitous_timer;
+
+static void rtl865x_recover_wired_led(unsigned long arg)
+{
+	rtl865x_wireCompSolidBlue();
+	cache_gratuitous_ip = 0;
+	cache_gratuitous_cnt = 0;
+	cache_gratuitous_jiffies = 0;
+	del_timer_sync(&gratuitous_timer);
+}
+
+static void rtl865x_check_ip_collision(unsigned long arg)
+{
+	if (time_after(jiffies, cache_gratuitous_jiffies+CACHE_GRATUITOUS_PERIOD*HZ))
+	{
+		if (cache_gratuitous_cnt<3)
+		{
+			rtl865x_wireCompBlinkAmber();
+			del_timer_sync(&gratuitous_timer);
+			init_timer(&gratuitous_timer);
+			gratuitous_timer.function = rtl865x_recover_wired_led;
+			gratuitous_timer.expires = jiffies + (HZ<<7);
+			add_timer(&gratuitous_timer);
+		}
+	}
+	else
+	{
+		mod_timer(&gratuitous_timer, jiffies + (HZ));
+	}
+}
+#endif
 /*
  *	Interface to generic neighbour cache.
  */
@@ -130,6 +175,22 @@ static void arp_solicit(struct neighbour
 static void arp_error_report(struct neighbour *neigh, struct sk_buff *skb);
 static void parp_redo(struct sk_buff *skb);
 
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	#include <net/rtl/rtk_vlan.h>
+	static struct vlan_tag arp_tag;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	static struct vlan_info *arp_info;
+#endif
+#endif
+
+//20120529 Disalbe for Native VLAN and Bridge mode
+#undef CONFIG_RTK_VOIP_QOS
+#undef CONFIG_RTK_VLAN_WAN_TAG_SUPPORT
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+static int arp_rx_port;
+#endif
+
 static struct neigh_ops arp_generic_ops = {
 	.family =		AF_INET,
 	.solicit =		arp_solicit,
@@ -374,8 +435,31 @@ static void arp_solicit(struct neighbour
 		return;
 	}
 
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	if (skb){
+		arp_tag = skb->tag;
+	#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		arp_info = skb->src_info;
+	#endif
+	}
+#endif
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	if(skb)
+		arp_rx_port = skb->srcPhyPort;
+#endif		
 	arp_send(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,
 		 dst_ha, dev->dev_addr, NULL);
+
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	arp_tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)	 
+	arp_rx_port = 0;
+#endif
 	if (dst_ha)
 		read_unlock_bh(&neigh->lock);
 }
@@ -578,6 +662,16 @@ struct sk_buff *arp_create(int type, int
 	arp = (struct arphdr *) skb_put(skb, arp_hdr_len(dev));
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_ARP);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	skb->tag = arp_tag;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	skb->src_info = arp_info;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)	
+	skb->srcPhyPort = arp_rx_port;
+#endif
 	if (src_hw == NULL)
 		src_hw = dev->dev_addr;
 	if (dest_hw == NULL)
@@ -691,11 +785,98 @@ void arp_send(int type, int ptype, __be3
 
 	arp_xmit(skb);
 }
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+struct timer_list lpArpProxyTimer;
+#define LOACL_PUBLIC_PROBE_PERIOD (30*HZ)
+
+static void rtl865x_lpArpProxyHandler(unsigned long arg)
+{
+	int i,j;
+	int lpCnt=0;
+	int dupGw=0;
+	struct rtl865x_localPublic lpArray[MAX_LOCAL_PUBLIC_NUM];
+	struct net_device * lanDev=NULL;
+	struct net_device * wanDev=NULL;
+	unsigned int lanIpAddr, lanNetMask;
+	unsigned char zeroMac[6]={0,0,0,0,0,0};
+
+	if(rtl865x_localPublicEnabled()==0)
+	{
+		goto end_of_handler;
+	}
+
+	lanDev=rtl865x_getLanDev();
+	wanDev=rtl865x_getWanDev();
+	lpCnt=rtl865x_getAllLocalPublic(lpArray, MAX_LOCAL_PUBLIC_NUM);
+	if(lanDev!=NULL)
+	{
+		rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
+
+		for(i=0; i<lpCnt; i++)
+		{
+			if(memcmp(lpArray[i].mac, zeroMac, 6)==0)
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, lpArray[i].ipAddr, lanDev, lanIpAddr, NULL, lanDev->dev_addr, NULL);
+			}
+		}
+	}
+
+	if(wanDev!=NULL)
+	{
+		for(i=0; i<lpCnt; i++)
+		{
+			if(lpArray[i].hw==0)
+			{
+				continue;
+			}
+
+			dupGw=0;
+			for(j=0; j<i; j++)
+			{
+				/*hardware local public need to get default gateway mac  for route redirection*/
+				if((lpArray[j].hw == lpArray[i].hw) && (lpArray[j].defGateway==lpArray[i].defGateway))
+				{
+					dupGw=1;
+					break;
+				}
+
+			}
+
+			if(dupGw==0)
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, lpArray[i].defGateway, wanDev, 0, NULL, wanDev->dev_addr, NULL);
+			}
+		}
+	}
+
+	if(lanDev)
+		dev_put(lanDev);
+
+	if(wanDev)
+		dev_put(wanDev);
+
+end_of_handler:
+	mod_timer(&lpArpProxyTimer, jiffies +LOACL_PUBLIC_PROBE_PERIOD);
+}
+
+void rtl865x_lpArpProxyInit(void)
+{
+	init_timer(&lpArpProxyTimer);
+	lpArpProxyTimer.function = rtl865x_lpArpProxyHandler;
+	lpArpProxyTimer.data	  = (unsigned long)(&lpArpProxyTimer);
+	lpArpProxyTimer.expires = jiffies +LOACL_PUBLIC_PROBE_PERIOD;
+	add_timer(&lpArpProxyTimer);
+	return;
+}
+
+#endif
 
 /*
  *	Process an arp request.
  */
-
+#if defined(CONFIG_RTL_LOCAL_PUBLIC)
+extern int rtl865x_checkMacAddrLocation(unsigned char *addr, unsigned int *isElanMac, unsigned int *isWlanMac);
+#endif
 static int arp_process(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
@@ -708,8 +889,34 @@ static int arp_process(struct sk_buff *s
 	u16 dev_type = dev->type;
 	int addr_type;
 	struct neighbour *n;
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	struct neighbour *dst_n;
+#endif
 	struct net *net = dev_net(dev);
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	unsigned int rxFromLan=0;
+	unsigned int rxFromWan=0;
+	unsigned char fromLocalPublic;
+	unsigned char toLocalPublic;
+	unsigned char localPublicMac[6];
+
+	struct rtl865x_localPublic srcLocalPubicInfo;
+	struct rtl865x_localPublic dstLocalPublicInfo;
+	struct net_device * wanDev=NULL;
+	struct net_device * lanDev=NULL;
+	unsigned int lanIpAddr, lanNetMask;
+	unsigned int wanIpAddr, wanNetMask;
+	unsigned char zeroMac[6]={0,0,0,0,0,0};
+	unsigned int srcIsElanMac=0;
+	unsigned int srcIsWlanMac=0;
+	int ret;
+	//unsigned int curPolicy ;
+	//char defInAclStart;
+	//char defInAclEnd;
+	//char defOutAclStart;
+	//char defOutAclEnd;
+#endif
 	/* arp_rcv below verifies the ARP header and verifies the device
 	 * is ARP'able.
 	 */
@@ -756,7 +963,15 @@ static int arp_process(struct sk_buff *s
 	}
 
 	/* Understand only these message types */
-
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+//reject arp request for AP
+extern int br_hackMac_enable;
+	if(br_hackMac_enable)
+	{
+        if(arp->ar_op == htons(ARPOP_REQUEST))
+                goto out;
+	}
+#endif
 	if (arp->ar_op != htons(ARPOP_REPLY) &&
 	    arp->ar_op != htons(ARPOP_REQUEST))
 		goto out;
@@ -800,7 +1015,19 @@ static int arp_process(struct sk_buff *s
  *  and in the case of requests for us we add the requester to the arp
  *  cache.
  */
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	if (skb){
+		arp_tag = skb->tag;
+	#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+		arp_info = skb->src_info;
+	#endif
+	}
+#endif
 
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT) 
+	if(skb)
+		arp_rx_port = skb->srcPhyPort;
+#endif
 	/* Special case: IPv4 duplicate address detection packet (RFC2131) */
 	if (sip == 0) {
 		if (arp->ar_op == htons(ARPOP_REQUEST) &&
@@ -811,6 +1038,351 @@ static int arp_process(struct sk_buff *s
 		goto out;
 	}
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(rtl865x_localPublicEnabled()==0)
+	{
+		goto	common_arp_process;
+	}
+
+	if(arp->ar_op == htons(ARPOP_REQUEST))
+	{
+		if(sip==tip)
+		{
+			/*gratuitous arp*/
+			goto common_arp_process;
+		}
+
+		fromLocalPublic=rtl865x_isLocalPublicIp(sip);
+		toLocalPublic=rtl865x_isLocalPublicIp(tip);
+		rtl865x_attainDevType(dev->name, &rxFromLan, &rxFromWan);
+
+ 		//rtl865x_getNetDecisionPolicy(&curPolicy);
+		//rtl865x_getDefACLForNetDecisionMiss(&defInAclStart, &defInAclEnd,&defOutAclStart,&defOutAclEnd);
+		ret=rtl865x_checkMacAddrLocation(sha, &srcIsElanMac, &srcIsWlanMac);
+		//printk("%s:%d,dev->name is %s,rxFromLan is %d, rxFromWan is %d\n",__FUNCTION__,__LINE__,dev->name,rxFromLan,rxFromWan);
+		//printk("%s:%d,fromLocalPublic is %d,toLocalPublic is %d\n",__FUNCTION__,__LINE__,fromLocalPublic, toLocalPublic);
+
+		if(rxFromLan)
+		{
+			lanDev=rtl865x_getLanDev();
+			rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
+			wanDev=rtl865x_getWanDev();
+			rtl865x_getDevIpAndNetmask(wanDev,&wanIpAddr,&wanNetMask);
+
+			if(fromLocalPublic && (!toLocalPublic))
+			{
+				//printk("%s:%d,sip is 0x%x,tip is 0x%x\n",__FUNCTION__,__LINE__,sip,tip);
+				ret=rtl865x_getLocalPublicInfo(sip, &srcLocalPubicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+
+				/*send out this arp request to wan*/
+				if((sip & srcLocalPubicInfo.netMask) == (tip & srcLocalPubicInfo.netMask))
+				{
+					if(wanDev)
+					{
+						//printk("%s:%d,lanIpAddr is %d.%d.%d.%d, lanNetMask is %d.%d.%d.%d\n",__FUNCTION__,__LINE__,NIPQUAD(lanIpAddr),NIPQUAD(lanNetMask));
+						if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+						{
+							/*target is not at lan*/
+							//arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+							if((tip & wanNetMask) == (wanIpAddr & wanNetMask))
+							{
+								dst_n = __neigh_lookup(&arp_tbl,&tip,wanDev,1);
+								arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, wanIpAddr, NULL, wanDev->dev_addr, NULL);
+								if(dst_n)
+									neigh_release(dst_n);
+							}
+							else
+							{
+								dst_n = __neigh_lookup(&arp_tbl,&srcLocalPubicInfo.defGateway,wanDev,1);
+								arp_send(ARPOP_REQUEST, ETH_P_ARP, srcLocalPubicInfo.defGateway, wanDev, wanIpAddr, NULL, wanDev->dev_addr, NULL);
+								if(dst_n)
+									neigh_release(dst_n);
+							}
+						}
+						#if 0
+						else if((tip & srcLocalPubicInfo.netMask) == (sip & srcLocalPubicInfo.netMask))
+						{
+							/*target in the same subnet as local public, but not local public*/
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+						}
+						else if ((tip & srcLocalPubicInfo.netMask) != (sip & srcLocalPubicInfo.netMask))
+						{
+							/*impossible: local public should not send this arp request, instead, it should ask its default gateway arp*/
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+						}
+						else
+						{
+							/*ignore it*/
+						}
+						#endif
+						else
+						{
+							//target in lan
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, lanIpAddr, NULL, lanDev->dev_addr, NULL);
+						}
+
+					}
+				}
+
+
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+				#if 0
+				if(tip==srcLocalPubicInfo.defGateway)
+				{
+					/*target is local public's default gateway*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+				{
+					/*target is not at lan*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else if((tip & srcLocalPubicInfo.netMask) == (sip & srcLocalPubicInfo.netMask))
+				{
+					/*target in the same subnet as local public, include  default gw, but not local public*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else if ((tip & srcLocalPubicInfo.netMask) != (sip & srcLocalPubicInfo.netMask))
+				{
+					/*impossible: local public should not send this arp request, it should ask its default gateway arp*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				#endif
+				#if 1
+				//software local public
+				if(srcLocalPubicInfo.hw == 0)
+				{
+					if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+					{
+						if(tip==wanIpAddr)
+						{
+							/*patch sw local public ping gateway wan ip fail when sw local public and gateway wan at the same subnet*/
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+						}
+						else
+						{
+							if((tip & wanNetMask) == (wanIpAddr & wanNetMask))
+							{
+								if((wanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&tip,wanDev))!=NULL)
+								{
+									if(memcmp(dst_n->ha,zeroMac,6) != 0)
+									{
+										arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+									}
+									neigh_release(dst_n);
+								}
+					}
+					else
+					{
+								if((wanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&srcLocalPubicInfo.defGateway,wanDev))!=NULL)
+							{
+								if(memcmp(dst_n->ha,zeroMac,6) != 0)
+								{
+									arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+								}
+								neigh_release(dst_n);
+							}
+						}
+					}
+					}
+					else
+					{
+						//target in lan
+						if((lanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&tip,lanDev))!=NULL)
+						{
+							if(memcmp(dst_n->ha,zeroMac,6) != 0)
+							{
+								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+							}
+							neigh_release(dst_n);
+						}
+					}
+
+				}
+				else
+				{
+					//hardware local public
+#if defined(CONFIG_RTL_PUBLIC_SSID)
+					//when hw local public access public ssid entry
+					if( rtl865x_is_public_ssid_entry(tip))
+					{
+						if((wanDev!=NULL)&&((dst_n=neigh_lookup(&arp_tbl,&tip,wanDev))!=NULL))
+						{
+							if(memcmp(dst_n->ha,zeroMac,6) != 0)
+							{
+								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+							}
+							neigh_release(dst_n);
+						}
+					}
+					else
+#endif
+					{
+						//when hw local public access wan public ip
+						arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+					}
+				}
+				#else
+				{
+					struct neighbour *dst_n;
+					dst_n = neigh_lookup(&arp_tbl,&tip,wanDev);
+					printk("=======%s(%d)\n",__FUNCTION__,__LINE__);
+					if(dst_n)
+					{
+						printk("=======%s(%d)\n",__FUNCTION__,__LINE__);
+						/*send arp reply*/
+						arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+						neigh_release(dst_n);
+					}
+					//hyking:don't reply,until dst_n is found....
+				}
+				#endif
+
+
+				if (n)
+				{
+					neigh_release(n);
+				}
+				goto out;
+
+			}
+			else if((!fromLocalPublic) && toLocalPublic)
+			{
+				goto common_arp_process;
+
+			}
+			else if(fromLocalPublic && toLocalPublic)
+			{
+				/*both local public belong to the same network*/
+				ret=rtl865x_getLocalPublicInfo(sip, &srcLocalPubicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+
+				ret=rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+
+				#if 0
+				if((srcLocalPubicInfo.ipAddr & srcLocalPubicInfo.netMask) != (tip & srcLocalPubicInfo.netMask))
+				{
+					/*impossible, it shouldn't send out this arp request*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else
+				{
+					/*locate in the same subnet*/
+					if((srcLocalPubicInfo.hw==1) && (dstLocalPublicInfo.hw==1))
+					{
+						/*hw local public to hw local public, tell them each other's mac address directly*/
+						/*Be careful, this is necessary*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+					else if((srcLocalPubicInfo.hw==1) && (dstLocalPublicInfo.hw==0))
+					{
+						/*dip==localPublicIp and  dmac==local public mac will be trapped to cpu*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+					else if((srcLocalPubicInfo.hw==0) && (dstLocalPublicInfo.hw==1))
+					{
+						/*due to arp reply(dip==sw localPublicIp and  dmac==sw local public mac) will be trapped to cpu*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+
+					}
+					else if ((srcLocalPubicInfo.hw==0) && (dstLocalPublicInfo.hw==0))
+					{
+						/*default acl permit, do l2 forwarding*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+
+				}
+				#endif
+				if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+				{
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+				}
+
+				if (n)
+				{
+					neigh_release(n);
+				}
+				goto out;
+			}
+			else if ((!fromLocalPublic) && (!toLocalPublic))
+			{
+				goto common_arp_process;
+			}
+
+		}
+		else if (rxFromWan)
+		{
+			 if((!fromLocalPublic) && toLocalPublic)
+			{
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+
+				#if 0
+				rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);
+				if((sip & dstLocalPublicInfo.netMask) == (tip & dstLocalPublicInfo.netMask))
+				{
+					lanDev=rtl865x_getLanDev();
+					if(lanDev)
+					{
+						arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, sip, NULL, lanDev->dev_addr, NULL);
+					}
+				}
+				#endif
+
+				if(rtl865x_getLocalPublicMac(tip, localPublicMac)==0)
+				{
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,localPublicMac,sha);
+				}
+
+				if (n)
+				{
+					neigh_release(n);
+				}
+				goto out;
+			}
+			 else if((!fromLocalPublic) && (!toLocalPublic))
+			 {
+				/*do common arp process*/
+			 }
+			 else if((fromLocalPublic) && (toLocalPublic))
+			 {
+				/*impossible, should be dropped at dev rx*/
+			 }
+			 else if((fromLocalPublic) && (!toLocalPublic))
+			 {
+				/*impossible, should be dropped at dev rx*/
+			 }
+
+		}
+
+	}
+
+common_arp_process:
+#endif
 	if (arp->ar_op == htons(ARPOP_REQUEST) &&
 	    ip_route_input(skb, tip, sip, 0, dev) == 0) {
 
@@ -890,9 +1462,25 @@ static int arp_process(struct sk_buff *s
 	}
 
 out:
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(lanDev)
+		dev_put(lanDev);
+	if(wanDev)
+		dev_put(wanDev);
+#endif
 	if (in_dev)
 		in_dev_put(in_dev);
 	consume_skb(skb);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	arp_tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	arp_rx_port = 0;
+#endif
 	return 0;
 }
 
@@ -1054,11 +1642,19 @@ static unsigned arp_state_to_flags(struc
  *	Get an ARP cache entry.
  */
 
+#if defined (CONFIG_RTL_819X)
+extern int get_dev_ip_mask(const char * name,unsigned int * ip,unsigned int * mask);
+#endif
 static int arp_req_get(struct arpreq *r, struct net_device *dev)
 {
 	__be32 ip = ((struct sockaddr_in *) &r->arp_pa)->sin_addr.s_addr;
 	struct neighbour *neigh;
 	int err = -ENXIO;
+#if defined (CONFIG_RTL_819X)
+	unsigned int dev_ip, dev_mask;
+	unsigned char zero_ha[ALIGN(MAX_ADDR_LEN, sizeof(unsigned long))];
+	int ret=-1;
+#endif
 
 	neigh = neigh_lookup(&arp_tbl, &ip, dev);
 	if (neigh) {
@@ -1071,6 +1667,41 @@ static int arp_req_get(struct arpreq *r,
 		neigh_release(neigh);
 		err = 0;
 	}
+#if defined (CONFIG_RTL_819X)
+	if (neigh) 
+	{
+		memset(zero_ha, 0 , sizeof(zero_ha));
+		if( (memcmp(neigh->ha, zero_ha , dev->addr_len)==0) &&
+			((dev!=NULL) && (strncmp(dev->name, "br0",3)==0)))
+		{			
+			ret=get_dev_ip_mask(dev->name, &dev_ip, &dev_mask); 
+			if((ret==0) && (dev_ip !=0) && (dev_mask!=0) && (ip!= dev_ip) && ((ip & dev_mask) == (dev_ip & dev_mask)))
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, ip, dev, dev_ip,NULL, dev->dev_addr, NULL);
+			}
+		}
+
+	}
+	else
+	{
+		if((dev!=NULL) && (strncmp(dev->name, "br0",3)==0))
+		{
+			
+			ret=get_dev_ip_mask(dev->name, &dev_ip, &dev_mask);
+			if((ret==0) && (dev_ip !=0) && (dev_mask!=0) && (ip!= dev_ip) && ((ip & dev_mask) == (dev_ip & dev_mask)))
+			{
+				neigh = __neigh_lookup(&arp_tbl,&ip, dev,1);	
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, ip, dev, dev_ip,NULL, dev->dev_addr, NULL);
+				if(neigh)
+					neigh_release(neigh);
+				//printk("%s:%d,neigh->refcnt is %d\n",__FUNCTION__,__LINE__,atomic_read(&neigh->refcnt));
+				
+				
+			}
+		}
+		
+	}
+#endif
 	return err;
 }
 
@@ -1243,6 +1874,21 @@ void __init arp_init(void)
 			      NET_IPV4_NEIGH, "ipv4", NULL, NULL);
 #endif
 	register_netdevice_notifier(&arp_netdev_notifier);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	arp_tag.v = 0;
+#if defined(CONFIG_RTK_VLAN_NEW_FEATURE)
+	arp_info = NULL;
+#endif
+#endif
+
+#if defined(CONFIG_RTK_VOIP_QOS) || defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT)
+	arp_rx_port = 0;
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	rtl865x_lpArpProxyInit();
+#endif
+
 }
 
 #ifdef CONFIG_PROC_FS
--- linux-2.6.30.9/net/ipv4/fib_hash.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/fib_hash.c	2013-05-02 01:47:59.268226610 +0300
@@ -43,6 +43,11 @@
 
 #include "fib_lookup.h"
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+
 static struct kmem_cache *fn_hash_kmem __read_mostly;
 static struct kmem_cache *fn_alias_kmem __read_mostly;
 
@@ -460,6 +465,11 @@ static int fn_hash_insert(struct fib_tab
 					err = 0;
 				goto out;
 			}
+
+			#if defined(CONFIG_RTL_819X)
+			rtl_fn_hash_replace_hooks(tb, cfg, fi);
+			#endif
+
 			write_lock_bh(&fib_hash_lock);
 			fi_drop = fa->fa_info;
 			fa->fa_info = fi;
@@ -536,6 +545,12 @@ static int fn_hash_insert(struct fib_tab
 
 	rtmsg_fib(RTM_NEWROUTE, key, new_fa, cfg->fc_dst_len, tb->tb_id,
 		  &cfg->fc_nlinfo, 0);
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_fn_hash_insert_hooks(tb, cfg, fi);
+	#endif
+
+	
 	return 0;
 
 out:
@@ -599,6 +614,10 @@ static int fn_hash_delete(struct fib_tab
 	if (fa_to_delete) {
 		int kill_fn;
 
+		#if defined(CONFIG_RTL_819X)
+		rtl_fn_hash_delete_hooks(tb, cfg);
+		#endif
+
 		fa = fa_to_delete;
 		rtmsg_fib(RTM_DELROUTE, key, fa, cfg->fc_dst_len,
 			  tb->tb_id, &cfg->fc_nlinfo, 0);
@@ -626,7 +645,12 @@ static int fn_hash_delete(struct fib_tab
 	return -ESRCH;
 }
 
+#if defined(CONFIG_RTL_819X)
+/*2007-12-19*/
+static int fn_flush_list(struct fn_zone *fz, int idx, u32 tb_id)
+#else
 static int fn_flush_list(struct fn_zone *fz, int idx)
+#endif
 {
 	struct hlist_head *head = &fz->fz_hash[idx];
 	struct hlist_node *node, *n;
@@ -642,6 +666,11 @@ static int fn_flush_list(struct fn_zone
 			struct fib_info *fi = fa->fa_info;
 
 			if (fi && (fi->fib_flags&RTNH_F_DEAD)) {
+
+				#if defined(CONFIG_RTL_819X)
+				rtl_fn_flush_list_hooks(fz->fz_order, idx, tb_id , f->fn_key);
+				#endif
+
 				write_lock_bh(&fib_hash_lock);
 				list_del(&fa->fa_list);
 				if (list_empty(&f->fn_alias)) {
@@ -673,7 +702,11 @@ static int fn_hash_flush(struct fib_tabl
 		int i;
 
 		for (i = fz->fz_divisor - 1; i >= 0; i--)
+#if defined(CONFIG_RTL_819X)		
+			found += fn_flush_list(fz, i, tb->tb_id);		
+#else
 			found += fn_flush_list(fz, i);
+#endif
 	}
 	return found;
 }
--- linux-2.6.30.9/net/ipv4/ip_forward.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_forward.c	2013-05-02 01:47:59.275226609 +0300
@@ -95,6 +95,15 @@ int ip_forward(struct sk_buff *skb)
 	}
 
 	/* We are about to mangle packet. Copy it! */
+#if 0
+	if( (LL_RESERVED_SPACE(rt->u.dst.dev)+rt->u.dst.header_len) > skb_headroom(skb))
+	{
+		printk("=========%s(%d),dst.dev(%s),reserved(%d),header_len(%d),hard_header_len(%d),needed_headroom(%d)\n",__FUNCTION__,__LINE__,rt->u.dst.dev->name,LL_RESERVED_SPACE(rt->u.dst.dev),
+rt->u.dst.header_len,rt->u.dst.dev->hard_header_len,rt->u.dst.dev->needed_headroom);
+		printk("======%s(%d),skb->headroom(%d)\n",__FUNCTION__,__LINE__,skb_headroom(skb));
+	}
+#endif
+
 	if (skb_cow(skb, LL_RESERVED_SPACE(rt->u.dst.dev)+rt->u.dst.header_len))
 		goto drop;
 	iph = ip_hdr(skb);
--- linux-2.6.30.9/net/ipv4/ip_input.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_input.c	2013-05-02 01:47:59.277226609 +0300
@@ -144,6 +144,88 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
+unsigned int _lan_ip=0xC0A801FE;
+unsigned int _lan_mask=0xFFFFFF00;
+#define USBIP_PORT_NUM 445
+#define USBIP_PORT_NUM_1 139
+#define HTTP_PORT_NUM 80
+#define UWIFI_PORT_NUM 2379
+
+enum netfilter_hooks {
+	_PRE_ROUTING,
+	_LOCAL_IN,
+	_FORWARD,
+	_LOCAL_OUT,
+	_POST_ROUTING,
+	_NUMHOOKS
+};
+int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction)
+{
+	struct iphdr *iph;
+	struct tcphdr *th;
+	int ret=0;	
+	struct net_device       *Indev;
+	struct net_device       *Outdev;
+
+	Indev = skb->dev;
+	iph = ip_hdr(skb);
+	if (iph->frag_off & 0x3fff) /* Ignore fragment */
+		 return 0;	
+	if(iph->protocol ==IPPROTO_TCP){
+		th=(void *) iph + iph->ihl*4;
+		if(hooknum==	_POST_ROUTING){
+			Outdev = skb->dst->dev;
+			if(strcmp(Indev->name , Outdev->name)){
+				return 0;
+			}
+		}
+		if(hooknum==	_PRE_ROUTING){
+			if(iph->daddr != _lan_ip){
+				return 0;	
+			}
+		}
+#if !defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)			
+		if(direction==0){ //rx we check dest port
+			if(_lan_ip != 0 && th->dest==USBIP_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->dest==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->dest==UWIFI_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;	
+
+		}
+		if(direction==1){ //tx we check src port
+			if(_lan_ip != 0 && th->source==USBIP_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->source==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->source==UWIFI_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;	
+
+		}
+#else
+		if(direction==0){ //rx we check dest port
+			if(_lan_ip != 0 && (th->dest==USBIP_PORT_NUM || th->dest==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && (th->dest==USBIP_PORT_NUM_1 || th->dest==UWIFI_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
+		}
+		if(direction==1){ //tx we check src port
+			if(_lan_ip != 0 && (th->source==USBIP_PORT_NUM || th->source==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && (th->source==USBIP_PORT_NUM_1 || th->source==UWIFI_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;	
+		}
+#endif
+	}
+	
+	return ret;
+}
+#endif
+
+
 /*
  *	Process Router Attention IP option
  */
@@ -264,9 +346,17 @@ int ip_local_deliver(struct sk_buff *skb
 		if (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
 			return 0;
 	}
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	if(isUsbIp_Reserved(skb,NF_INET_LOCAL_IN, 0)==0){
+		return NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb->dev, NULL, ip_local_deliver_finish);
+	}else{
+		return ip_local_deliver_finish(skb);
+	}
 
+#else
 	return NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
 		       ip_local_deliver_finish);
+#endif
 }
 
 static inline int ip_rcv_options(struct sk_buff *skb)
@@ -342,7 +432,26 @@ static int ip_rcv_finish(struct sk_buff
 			goto drop;
 		}
 	}
+#if defined (CONFIG_RTL_819X)
+	/*to fix guest can access local web ui*/
+	#include <linux/udp.h>
+        if (skb->dst->input == &ip_local_deliver) {
+                if (skb->__unused == 0xe5 && iph->protocol== IPPROTO_UDP) {
+                        struct udphdr *hdr = (struct udphdr *)((u_int32_t *)iph + iph->ihl);
+                        if (hdr->dest == 53 || hdr->dest == 67) // DNS Domain or dhcp
+                                skb->__unused = 0;
+                }
+
+                if (skb->__unused == 0xe5 && iph->protocol== IPPROTO_TCP) {
+                        struct udphdr *hdr = (struct udphdr *)((u_int32_t *)iph + iph->ihl);
+                        if (hdr->dest == 52869) // IGD port
+                                skb->__unused = 0;
+                }
 
+                if (skb->__unused == 0xe5)
+                        goto drop;
+        }
+#endif
 #ifdef CONFIG_NET_CLS_ROUTE
 	if (unlikely(skb->dst->tclassid)) {
 		struct ip_rt_acct *st = per_cpu_ptr(ip_rt_acct, smp_processor_id());
@@ -439,9 +548,20 @@ int ip_rcv(struct sk_buff *skb, struct n
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
-
+	#if defined(CONFIG_RTL_DSCP_IPTABLE_CHECK)
+		skb->original_dscp = ip_hdr(skb)->tos >> 2;
+	#endif
+
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	if(isUsbIp_Reserved(skb,NF_INET_PRE_ROUTING, 0)==0){
+		return NF_HOOK(PF_INET, NF_INET_PRE_ROUTING, skb, dev, NULL,ip_rcv_finish);
+	}else{
+		return ip_rcv_finish(skb);
+	}
+#else
 	return NF_HOOK(PF_INET, NF_INET_PRE_ROUTING, skb, dev, NULL,
 		       ip_rcv_finish);
+#endif
 
 inhdr_error:
 	IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);
--- linux-2.6.30.9/net/ipv4/ipmr.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/ipmr.c	2013-05-02 01:47:59.280226609 +0300
@@ -66,6 +66,11 @@
 #if defined(CONFIG_IP_PIMSM_V1) || defined(CONFIG_IP_PIMSM_V2)
 #define CONFIG_IP_PIMSM	1
 #endif
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+
+static int ipmr_find_vif(struct net_device *dev);
+
+#endif
 
 /* Big lock, protecting vif table, mrt cache and mroute socket state.
    Note that the changes are semaphored via rtnl_lock.
@@ -404,6 +409,11 @@ out:
 	spin_unlock(&mfc_unres_lock);
 }
 
+
+static struct mfc_cache *ipmr_cache_find(struct net *net,
+					 __be32 origin,
+					 __be32 mcastgrp);
+
 /* Fill oifs list. It is called under write locked mrt_lock. */
 
 static void ipmr_update_thresholds(struct mfc_cache *cache, unsigned char *ttls)
@@ -528,12 +538,65 @@ static struct mfc_cache *ipmr_cache_find
 	struct mfc_cache *c;
 
 	for (c = net->ipv4.mfc_cache_array[line]; c; c = c->next) {
-		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
+		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp){
 			break;
 	}
+	}
+#if 0		
+#if defined (CONFIG_RTL_IGMP_PROXY)
+	// Casey, for IGMP v2
+	if(c == NULL) {
+		origin = 0;
+		line=MFC_HASH(mcastgrp,origin);
+		for (c= net->ipv4.mfc_cache_array[line]; c; c = c->next) {
+			if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp) {
+				break;
+			}
+		}
+	}
+#endif
+#endif
 	return c;
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#if	defined (CONFIG_RTL_IGMP_PROXY)
+int rtl865x_checkMfcCache(struct net *net,struct net_device *dev,__be32 origin,__be32 mcastgrp)
+{
+	struct mfc_cache *mfc=NULL;
+	int vif_index;
+	__be32 origin_temp=0;
+	
+	mfc=ipmr_cache_find(net,origin,mcastgrp);
+	
+	if(mfc==NULL)
+	{
+		vif_index = ipmr_find_vif(dev);
+		origin_temp = vif_index;
+		mfc = ipmr_cache_find(net, origin_temp, mcastgrp);
+	}
+	
+	if(mfc!=NULL)
+	{
+		return 0;
+	}
+	else
+	{
+		mfc = mfc_unres_queue;
+		while (mfc)
+		{
+			if(mfc->mfc_mcastgrp==mcastgrp)
+			{
+				return 0;
+			}
+			mfc = mfc->next;
+		}
+	}
+	return -1;
+}
+#endif
+#endif
+
 /*
  *	Allocate a multicast cache entry
  */
@@ -651,6 +714,7 @@ static int ipmr_cache_report(struct net
 	ip_hdr(skb)->protocol = 0;			/* Flag to the kernel this is a route add */
 	msg = (struct igmpmsg *)skb_network_header(skb);
 	msg->im_vif = vifi;
+	dst_release(skb->dst);
 	skb->dst = dst_clone(pkt->dst);
 
 	/*
@@ -701,7 +765,19 @@ ipmr_cache_unresolved(struct net *net, v
 		    c->mfc_origin == iph->saddr)
 			break;
 	}
-
+#if defined (CONFIG_RTL_IGMP_PROXY)
+//Casey, for IGMP V2 proxy
+#if 0
+/*2008-01-14,for porting igmp proxy to linux kernel 2.6*/
+	if (c == NULL) {
+		for (c=mfc_unres_queue; c; c=c->next) {
+			if (c->mfc_mcastgrp == skb->nh.iph->daddr &&
+		    	c->mfc_origin == 0)
+				break;
+		}
+	}
+#endif
+#endif
 	if (c == NULL) {
 		/*
 		 *	Create a new entry if allowable
@@ -789,7 +865,11 @@ static int ipmr_mfc_add(struct net *net,
 {
 	int line;
 	struct mfc_cache *uc, *c, **cp;
-
+	#if defined (CONFIG_RTL_IGMP_PROXY)
+	/*
+	mfc->mfcc_origin.s_addr = 0;
+	*/
+	#endif
 	line = MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
 
 	for (cp = &net->ipv4.mfc_cache_array[line];
@@ -1431,6 +1511,12 @@ int ip_mr_input(struct sk_buff *skb)
 	struct mfc_cache *cache;
 	struct net *net = dev_net(skb->dev);
 	int local = skb->rtable->rt_flags&RTCF_LOCAL;
+#if defined (CONFIG_RTL_IGMP_PROXY)
+	cache=NULL;
+	struct net_device *dev=skb->dev;
+	int vif_index;
+	__be32 origin_temp=0;
+#endif
 
 	/* Packet is looped back after forward, it should not be
 	   forwarded second time, but still can be delivered locally.
@@ -1461,8 +1547,19 @@ int ip_mr_input(struct sk_buff *skb)
 	}
 
 	read_lock(&mrt_lock);
+	
+	
+#if defined (CONFIG_RTL_IGMP_PROXY)
+	vif_index=ipmr_find_vif(dev);
+	origin_temp = vif_index;
+	cache = ipmr_cache_find(net, origin_temp, ip_hdr(skb)->daddr);
+	if (cache==NULL){
+		cache = ipmr_cache_find(net, ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);
+	}
+#else
 	cache = ipmr_cache_find(net, ip_hdr(skb)->saddr, ip_hdr(skb)->daddr);
 
+#endif
 	/*
 	 *	No usable cache entry
 	 */
--- linux-2.6.30.9/net/ipv4/ip_output.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_output.c	2013-05-02 01:47:59.278226609 +0300
@@ -80,6 +80,13 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+#include <net/rtl/features/rtl_ps_log.h>
+
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+extern int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
+#endif
+
+
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 
 /* Generate a checksum for an outgoing IP datagram. */
@@ -95,8 +102,17 @@ int __ip_local_out(struct sk_buff *skb)
 
 	iph->tot_len = htons(skb->len);
 	ip_send_check(iph);
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
+	if(isUsbIp_Reserved(skb, NF_INET_LOCAL_OUT, 1)==0){
+		return nf_hook(PF_INET, NF_INET_LOCAL_OUT, skb, NULL, skb->dst->dev,dst_output);
+	}else{
+		return dst_output(skb);
+	}
+	
+	#else
 	return nf_hook(PF_INET, NF_INET_LOCAL_OUT, skb, NULL, skb->dst->dev,
 		       dst_output);
+	#endif	       
 }
 
 int ip_local_out(struct sk_buff *skb)
@@ -192,6 +208,7 @@ static inline int ip_finish_output2(stru
 
 		skb2 = skb_realloc_headroom(skb, LL_RESERVED_SPACE(dev));
 		if (skb2 == NULL) {
+			//LOG_MEM_ERROR("%s skb realloc headroom failed\n", __FUNCTION__);
 			kfree_skb(skb);
 			return -ENOMEM;
 		}
@@ -277,6 +294,7 @@ int ip_mc_output(struct sk_buff *skb)
 		/* Multicasts with ttl 0 must not go beyond the host */
 
 		if (ip_hdr(skb)->ttl == 0) {
+			//LOG_SKB_ERROR("%s drop Multicast pkt for ttl 0\n", __FUNCTION__);
 			kfree_skb(skb);
 			return 0;
 		}
@@ -302,10 +320,21 @@ int ip_output(struct sk_buff *skb)
 
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT) || defined(CONFIG_RTL_USB_UWIFI_HOST_SPEEDUP)
 
+	if(isUsbIp_Reserved(skb, NF_INET_POST_ROUTING, 1)==0){
 	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
 			    ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+	}else{
+		return ip_finish_output(skb);
+	}
+	
+	#else
+	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
+			    ip_finish_output,
+			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+	#endif
 }
 
 int ip_queue_xmit(struct sk_buff *skb, int ipfragok)
@@ -324,7 +353,9 @@ int ip_queue_xmit(struct sk_buff *skb, i
 		goto packet_routed;
 
 	/* Make sure we can route this packet. */
-	rt = (struct rtable *)__sk_dst_check(sk, 0);
+	//hyking:since bt testing maybe crash, don't use sock's dst cache now...
+	//why did the cache dst entry wrong? DO debug after release 2.6.30 
+	//rt = (struct rtable *)__sk_dst_check(sk, 0);	
 	if (rt == NULL) {
 		__be32 daddr;
 
@@ -409,6 +440,10 @@ static void ip_copy_metadata(struct sk_b
 	/* Copy the flags to each fragment. */
 	IPCB(to)->flags = IPCB(from)->flags;
 
+#if (defined(CONFIG_RTL_QOS_PATCH) || defined(CONFIG_RTK_VOIP_QOS)|| defined(CONFIG_RTK_VLAN_WAN_TAG_SUPPORT))&& defined(CONFIG_RTL_819X) 
+        to->srcPhyPort = from->srcPhyPort;
+#endif
+
 #ifdef CONFIG_NET_SCHED
 	to->tc_index = from->tc_index;
 #endif
--- linux-2.6.30.9/net/ipv4/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/Kconfig	2013-05-02 01:47:59.264226610 +0300
@@ -91,6 +91,22 @@ endchoice
 config IP_FIB_HASH
 	def_bool ASK_IP_FIB_HASH || !IP_ADVANCED_ROUTER
 
+config RTL_IPTABLES_FAST_PATH
+        tristate "Realtek IPTables Fast Path"
+        default y
+
+config RTL_FAST_PPPOE
+        tristate "Realtek Fast PPPOE support"
+        default y
+config FAST_PATH_SPI_ENABLED
+        bool "Realtek Fastpath SPI(stateful packet inspection) support"
+        depends on RTL_IPTABLES_FAST_PATH
+        default n
+
+config RTL_FASTBRIDGE
+        tristate "Realtek fast bridge"
+        default n
+
 config IP_FIB_TRIE_STATS
 	bool "FIB TRIE statistics"
 	depends on IP_FIB_TRIE
--- linux-2.6.30.9/net/ipv4/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/Makefile	2013-05-02 01:47:59.264226610 +0300
@@ -52,3 +52,6 @@ obj-$(CONFIG_NETLABEL) += cipso_ipv4.o
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
--- linux-2.6.30.9/net/ipv4/netfilter/iptable_mangle.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/iptable_mangle.c	2013-05-02 01:47:59.286226608 +0300
@@ -64,7 +64,10 @@ static struct
 	.term = IPT_ERROR_INIT,			/* ERROR */
 };
 
-static struct xt_table packet_mangler = {
+#if !defined(CONFIG_NET_SCHED)
+static 
+#endif
+struct xt_table packet_mangler = {
 	.name		= "mangle",
 	.valid_hooks	= MANGLE_VALID_HOOKS,
 	.me		= THIS_MODULE,
--- linux-2.6.30.9/net/ipv4/netfilter/ip_tables.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/ip_tables.c	2013-05-02 01:47:59.283226608 +0300
@@ -28,10 +28,46 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <net/netfilter/nf_log.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#define	RTL865X_QOS_TABLE_NAME		"mangle"
+#define	RTL865X_QOS_TABLE_LEN			6
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+typedef struct xt_rule_to_acl_s
+{
+	struct list_head list;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	rtl865x_AclRule_t *aclRule;
+} xt_rule_to_acl_t;
+
+LIST_HEAD(rtl865x_iptRule2Acl_tbl_list);
+LIST_HEAD(rtl865x_iptRule2Acl_def_rule_list);
+
+static unsigned int in_def_action = RTL865X_ACL_PERMIT;
+static unsigned int out_def_action = RTL865X_ACL_PERMIT;
+int establish_rule_permit = 0;
+
+extern int get_hookNum(struct ipt_entry *e, unsigned char *base, const unsigned int valid_hooks,const unsigned int *hook_entries);
+
+#endif
+
 /*#define DEBUG_IP_FIREWALL*/
 /*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
 /*#define DEBUG_IP_FIREWALL_USER*/
@@ -59,11 +95,7 @@ do {								\
 #define IP_NF_ASSERT(x)
 #endif
 
-#if 0
-/* All the better to debug you with... */
-#define static
-#define inline
-#endif
+
 
 /*
    We keep a set of rules for each CPU, so we can avoid write-locking
@@ -203,8 +235,10 @@ unconditional(const struct ipt_ip *ip)
 #undef FWINV
 }
 
+#define CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL 1
 #if defined(CONFIG_NETFILTER_XT_TARGET_TRACE) || \
-    defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)
+    defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE) || \
+    defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
 static const char *const hooknames[] = {
 	[NF_INET_PRE_ROUTING]		= "PREROUTING",
 	[NF_INET_LOCAL_IN]		= "INPUT",
@@ -213,6 +247,14 @@ static const char *const hooknames[] = {
 	[NF_INET_POST_ROUTING]		= "POSTROUTING",
 };
 
+static const char *const chainnames[] = {
+	[NF_INET_PRE_ROUTING]		= "PREROUTING",
+	[NF_INET_LOCAL_IN]		= "INPUT",
+	[NF_INET_FORWARD]		= "FORWARD",
+	[NF_INET_LOCAL_OUT]		= "OUTPUT",
+	[NF_INET_POST_ROUTING]		= "POSTROUTING",
+};
+
 enum nf_ip_trace_comments {
 	NF_IP_TRACE_COMMENT_RULE,
 	NF_IP_TRACE_COMMENT_RETURN,
@@ -295,6 +337,32 @@ static void trace_packet(struct sk_buff
 		      "TRACE: %s:%s:%s:%u ",
 		      tablename, chainname, comment, rulenum);
 }
+
+#if defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
+static void rtl_getChainName(unsigned int hook,
+			 const char *tablename,
+			 struct xt_table_info *private,
+			 struct ipt_entry *e,
+			 char **chainName)
+{
+	void *table_base;
+	const struct ipt_entry *root;
+	char *hookname, *comment;
+	unsigned int rulenum = 0;
+
+	table_base = (void *)private->entries[smp_processor_id()];
+	root = get_entry(table_base, private->hook_entry[hook]);
+
+	hookname = (char *)hooknames[hook];
+	*chainName = (char *)chainnames[hook];
+	comment = (char *)comments[NF_IP_TRACE_COMMENT_RULE];
+
+	IPT_ENTRY_ITERATE(root,
+			  private->size - private->hook_entry[hook],
+			  get_chainname_rulenum,
+			  e, hookname, chainName, &comment, &rulenum);
+}
+#endif
 #endif
 
 /* Returns one of the generic firewall policies, like NF_ACCEPT. */
@@ -347,9 +415,22 @@ ipt_do_table(struct sk_buff *skb,
 	/* For return from builtin chain */
 	back = get_entry(table_base, private->underflow[hook]);
 
+	if(ip == NULL)
+	{
+		//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
+		return NF_DROP;
+	}
+
 	do {
 		IP_NF_ASSERT(e);
 		IP_NF_ASSERT(back);
+
+		if(e == NULL)
+		{
+			//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
+			return NF_DROP;
+		}
+
 		if (ip_packet_match(ip, indev, outdev,
 		    &e->ip, mtpar.fragoff)) {
 			struct ipt_entry_target *t;
@@ -454,6 +535,12 @@ mark_source_chains(struct xt_table_info
 {
 	unsigned int hook;
 
+#if 0 //def CONFIG_RTL_HARDWARE_NAT
+	/*2007-12-19*/
+	unsigned int masqif_set = 0;
+#endif
+
+
 	/* No recursion; use packet counter to save back ptrs (reset
 	   to 0 as we leave), and comefrom to save source hook bitmask */
 	for (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {
@@ -546,6 +633,72 @@ mark_source_chains(struct xt_table_info
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
 				}
+
+
+#if 0 // defined(CONFIG_RTL_HARDWARE_NAT)
+				/*2007-12-19*/
+#ifdef CONFIG_HARDWARE_NAT_DEBUG
+				{
+					printk("**************************************\n");
+					printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+					printk("%s:%d:hook is %d\n",__FUNCTION__,__LINE__,hook);
+					printk("%s:%d:t->target.u.user.name is %s\n",__FUNCTION__,__LINE__,t->target.u.user.name);
+					//printk("%s:%d:t->target.u.kernel.target->name is %s\n",__FUNCTION__,__LINE__,t->target.u.kernel.target->name);
+					printk("%s:%d:e->src(%u.%u.%u.%u),e->dst(%u.%u.%u.%u)\n",__FUNCTION__,
+						__LINE__,NIPQUAD(e->ip.src.s_addr),NIPQUAD(e->ip.dst.s_addr));
+
+				}
+#endif
+				if ((masq_if[0] == '\0') && (hook == NF_INET_POST_ROUTING) &&
+					((strcmp(t->target.u.user.name, "MASQUERADE") == 0)	))
+				{
+					struct net_device *dev;
+					struct in_ifaddr *ina;
+					int rc;
+					masqif_set = 1;
+					memcpy(masq_if, e->ip.outiface, IFNAMSIZ);
+					dev = __dev_get_by_name(&init_net, masq_if);
+
+					#ifdef CONFIG_HARDWARE_NAT_DEBUG
+					/*2007-12-19*/
+					printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+					#endif
+
+					if ((dev)&&(dev->ip_ptr)) {
+
+						ina=(struct in_ifaddr *)(((struct in_device *)(dev->ip_ptr))->ifa_list);
+						if (ina!=NULL)
+						{
+							if (hw_napt_ip) {
+								rc = 0;
+			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+								rc = rtl865x_delIp(hw_napt_ip);
+			#endif
+								#ifdef CONFIG_HARDWARE_NAT_DEBUG
+								printk("LR(%s): 0x%x, errno=%d\n", "del_natip2", hw_napt_ip, rc);
+								#endif
+								if (rc == SUCCESS)
+									hw_napt_ip = 0;
+							}
+							rc = 0;
+			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+							//printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+							//printk("---------------ip(%u.%u.%u.%u)\n",NIPQUAD((u32)(ina->ifa_local)));
+							rc = rtl865x_addIp(0,(u32)(ina->ifa_local),IP_TYPE_NAPT);
+			#endif
+
+							if (rc == SUCCESS)
+								hw_napt_ip = ina->ifa_local;
+							#ifdef CONFIG_HARDWARE_NAT_DEBUG
+							/*2007-12-19*/
+							printk("%s:%d:(%s): %u.%u.%u.%u, errno=%d\n", __FUNCTION__,__LINE__,"add_natip",NIPQUAD((u32)(ina->ifa_local)), rc);
+							#endif
+						}
+					}
+				}
+
+#endif
+
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
@@ -554,6 +707,13 @@ mark_source_chains(struct xt_table_info
 		}
 		next:
 		duprintf("Finished chain %u\n", hook);
+#if 0 //def CONFIG_RTL_HARDWARE_NAT
+		/*2007-12-19*/
+		if (masqif_set == 0 && masq_if[0] != '\0' && hook==NF_INET_POST_ROUTING) {
+			masq_if[0] = '\0';
+		}
+#endif
+
 	}
 	return 1;
 }
@@ -580,89 +740,1169 @@ check_entry(struct ipt_entry *e, const c
 {
 	struct ipt_entry_target *t;
 
-	if (!ip_checkentry(&e->ip)) {
-		duprintf("ip_tables: ip check failed %p %s.\n", e, name);
-		return -EINVAL;
+	if (!ip_checkentry(&e->ip)) {
+		duprintf("ip_tables: ip check failed %p %s.\n", e, name);
+		return -EINVAL;
+	}
+
+	if (e->target_offset + sizeof(struct ipt_entry_target) >
+	    e->next_offset)
+		return -EINVAL;
+
+	t = ipt_get_target(e);
+	if (e->target_offset + t->u.target_size > e->next_offset)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
+	    unsigned int *i)
+{
+	const struct ipt_ip *ip = par->entryinfo;
+	int ret;
+
+	par->match     = m->u.kernel.match;
+	par->matchinfo = m->data;
+
+	ret = xt_check_match(par, m->u.match_size - sizeof(*m),
+	      ip->proto, ip->invflags & IPT_INV_PROTO);
+	if (ret < 0) {
+		duprintf("ip_tables: check failed for `%s'.\n",
+			 par.match->name);
+		return ret;
+	}
+	++*i;
+	return 0;
+}
+
+static int
+find_check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
+		 unsigned int *i)
+{
+	struct xt_match *match;
+	int ret;
+
+	match = try_then_request_module(xt_find_match(AF_INET, m->u.user.name,
+						      m->u.user.revision),
+					"ipt_%s", m->u.user.name);
+	if (IS_ERR(match) || !match) {
+		duprintf("find_check_match: `%s' not found\n", m->u.user.name);
+		return match ? PTR_ERR(match) : -ENOENT;
+	}
+	m->u.kernel.match = match;
+
+	ret = check_match(m, par, i);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	module_put(m->u.kernel.match->me);
+	return ret;
+}
+
+static int check_target(struct ipt_entry *e, const char *name)
+{
+	struct ipt_entry_target *t = ipt_get_target(e);
+	struct xt_tgchk_param par = {
+		.table     = name,
+		.entryinfo = e,
+		.target    = t->u.kernel.target,
+		.targinfo  = t->data,
+		.hook_mask = e->comefrom,
+		.family    = NFPROTO_IPV4,
+	};
+	int ret;
+
+	ret = xt_check_target(&par, t->u.target_size - sizeof(*t),
+	      e->ip.proto, e->ip.invflags & IPT_INV_PROTO);
+	if (ret < 0) {
+		duprintf("ip_tables: check failed for `%s'.\n",
+			 t->u.kernel.target->name);
+		return ret;
+	}
+	return 0;
+}
+
+static int
+find_check_entry(struct ipt_entry *e, const char *name, unsigned int size,
+		 unsigned int *i)
+{
+	struct ipt_entry_target *t;
+	struct xt_target *target;
+	int ret;
+	unsigned int j;
+	struct xt_mtchk_param mtpar;
+
+	ret = check_entry(e, name);
+	if (ret)
+		return ret;
+
+	j = 0;
+	mtpar.table     = name;
+	mtpar.entryinfo = &e->ip;
+	mtpar.hook_mask = e->comefrom;
+	mtpar.family    = NFPROTO_IPV4;
+	ret = IPT_MATCH_ITERATE(e, find_check_match, &mtpar, &j);
+	if (ret != 0)
+		goto cleanup_matches;
+
+	t = ipt_get_target(e);
+	target = try_then_request_module(xt_find_target(AF_INET,
+							t->u.user.name,
+							t->u.user.revision),
+					 "ipt_%s", t->u.user.name);
+	if (IS_ERR(target) || !target) {
+		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
+		ret = target ? PTR_ERR(target) : -ENOENT;
+		goto cleanup_matches;
+	}
+	t->u.kernel.target = target;
+
+	ret = check_target(e, name);
+	if (ret)
+		goto err;
+
+	(*i)++;
+	return 0;
+ err:
+	module_put(t->u.kernel.target->me);
+ cleanup_matches:
+	IPT_MATCH_ITERATE(e, cleanup_match, &j);
+	return ret;
+}
+
+static int
+check_entry_size_and_hooks(struct ipt_entry *e,
+			   struct xt_table_info *newinfo,
+			   unsigned char *base,
+			   unsigned char *limit,
+			   const unsigned int *hook_entries,
+			   const unsigned int *underflows,
+			   unsigned int *i)
+{
+	unsigned int h;
+
+	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0
+	    || (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
+		duprintf("Bad offset %p\n", e);
+		return -EINVAL;
+	}
+
+	if (e->next_offset
+	    < sizeof(struct ipt_entry) + sizeof(struct ipt_entry_target)) {
+		duprintf("checking: element %p size %u\n",
+			 e, e->next_offset);
+		return -EINVAL;
+	}
+
+	/* Check hooks & underflows */
+	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
+		if ((unsigned char *)e - base == hook_entries[h])
+			newinfo->hook_entry[h] = hook_entries[h];
+		if ((unsigned char *)e - base == underflows[h])
+			newinfo->underflow[h] = underflows[h];
+	}
+
+	/* FIXME: underflows must be unconditional, standard verdicts
+	   < 0 (not IPT_RETURN). --RR */
+
+	/* Clear counters and comefrom */
+	e->counters = ((struct xt_counters) { 0, 0 });
+	e->comefrom = 0;
+
+	(*i)++;
+	return 0;
+}
+
+static int
+cleanup_entry(struct ipt_entry *e, unsigned int *i)
+{
+	struct xt_tgdtor_param par;
+	struct ipt_entry_target *t;
+
+	if (i && (*i)-- == 0)
+		return 1;
+
+	/* Cleanup all matches */
+	IPT_MATCH_ITERATE(e, cleanup_match, NULL);
+	t = ipt_get_target(e);
+
+	par.target   = t->u.kernel.target;
+	par.targinfo = t->data;
+	par.family   = NFPROTO_IPV4;
+	if (par.target->destroy != NULL)
+		par.target->destroy(&par);
+	module_put(par.target->me);
+	return 0;
+}
+
+
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static struct xt_target ipt_standard_target;
+static struct xt_target ipt_error_target;
+
+static void rtl865x_print_iptRule2Acl_tbl(void)
+{
+	rtl865x_iptRule2Acl_tbl *listNode;
+	xt_rule_to_acl_t *match2acl;
+	int i ;
+	printk("=======================================\n");
+	list_for_each_entry(listNode,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		printk("list->tblName(%s),list->priority(%d)\n",listNode->tblName,listNode->priority);
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			printk("%d\n",i);
+			list_for_each_entry(match2acl,&listNode->chainList[i],list)
+			{
+				printk("  inIf(%s) outIn(%s) aclType(0x%x) aclAction(0x%x),direction(%d)\n",match2acl->iniface,match2acl->outiface,match2acl->aclRule->ruleType_,match2acl->aclRule->actionType_,match2acl->aclRule->direction_);
+			}
+		}
+
+	}
+	printk("=======================================\n");
+}
+
+static rtl865x_iptRule2Acl_tbl* rtl865x_get_ipt2Acl_tbl(const char *name)
+{
+	rtl865x_iptRule2Acl_tbl *listNode,*retEntry;
+	retEntry = NULL;
+
+	list_for_each_entry(listNode,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		if(memcmp(listNode->tblName,name,strlen(name)) == 0)
+		{
+			retEntry = listNode;
+			break;
+		}
+	}
+
+	return retEntry;
+}
+
+/*translate iptables ip rule to acl*/
+static int ipt_ip2Acl(struct ipt_entry *e, rtl865x_AclRule_t *acl, int *all_match)
+{
+
+	if(e == NULL || acl == NULL)
+		return -1;
+
+
+	acl->ruleType_ = RTL865X_ACL_IP;
+
+	/*proto 0=ANY */
+	if(e->ip.proto == 0)
+		acl->ipProtoMask_ = 0x0;
+	else
+		acl->ipProtoMask_ = 0xff;
+
+	acl->srcIpAddr_ 		= e->ip.src.s_addr;
+	acl->srcIpAddrMask_	= e->ip.smsk.s_addr;
+	acl->dstIpAddr_		= e->ip.dst.s_addr;
+	acl->dstIpAddrMask_	= e->ip.dmsk.s_addr;
+	acl->ipProto_			= e->ip.proto;
+
+	if((e->ip.flags & IPT_F_FRAG) && ((e->ip.invflags & IPT_INV_FRAG) == 0) )
+	{
+		acl->ipFOP_ = 1;
+		acl->ipFOM_ = 1;
+	}
+
+	if(e->ip.smsk.s_addr == 0 && e->ip.dmsk.s_addr == 0 && e->ip.proto == 0)
+	{
+		/*all packet match this rule... so, this rule should be add to tail...*/
+		if(all_match)
+			*all_match = 1;
+		/*
+		*hyking:
+		*when all packet match this rule, we change acl->ruleType to ether type
+		*2008-12-16
+		*/
+		acl->ruleType_ = RTL865X_ACL_MAC;
+	}
+
+	return 0;
+}
+
+static int standard_target2Acl(struct ipt_entry_target *t,rtl865x_AclRule_t *rule)
+{
+	switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+	{
+		case NF_DROP:
+			rule->actionType_ = RTL865X_ACL_DROP;
+			break;
+		case NF_ACCEPT:
+			rule->actionType_  = RTL865X_ACL_PERMIT;
+			break;
+		case NF_QUEUE:
+		case NF_REPEAT:
+		case NF_STOP:
+		case NF_STOLEN:
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+			break;
+		default:
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+			break;
+
+	}
+	return 0;
+}
+
+/*translate iptables rule to ACL*/
+static int translate_rule2Acl(struct ipt_entry *e,
+unsigned char *base,const char *name,unsigned int size,
+const unsigned int valid_hooks,const unsigned int *hook_entries
+#if defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
+,struct xt_table_info *private
+#endif
+)
+{
+	int match_cnt = 0;
+	int hook_num = -1;
+	int nxt_hookNum = -1;
+	struct ipt_entry_match *__match;
+	struct ipt_entry_target *t,*nxt_target;
+	struct ipt_target *target;
+	rtl865x_AclRule_t *rule = NULL;
+	xt_rule_to_acl_t *list_node = NULL;
+	struct ipt_entry *nxt_entry;
+	rtl865x_iptRule2Acl_tbl *ipt2AclTbl;
+	int retval;
+	unsigned int last_entry = 0;
+	unsigned int invflags = 0;
+	int allMatch = 0;
+	void	*data = NULL;
+	unsigned int default_action = RTL865X_ACL_PERMIT;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	char	qosIfName[IFNAMSIZ];
+#endif
+#if defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
+	char *chainName;
+#endif
+
+	t = ipt_get_target(e);
+	if(t == NULL || (t->u.kernel.target  == &ipt_error_target) )
+		goto next;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	memset(qosIfName, 0, IFNAMSIZ);
+#endif
+
+	hook_num = get_hookNum(e,base,valid_hooks,hook_entries);
+
+	#if defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
+	rtl_getChainName(hook_num, name, private, e, &chainName);
+
+	//if(chainName)
+		//printk("chainName is %s\n", chainName);
+	
+	if(chainName&&
+		memcmp(chainName, "PREROUTING", strlen("PREROUTING"))&&
+		memcmp(chainName, "INPUT", strlen("INPUT"))&&
+		memcmp(chainName, "FORWARD", strlen("FORWARD"))&&
+		memcmp(chainName, "OUTPUT", strlen("OUTPUT"))&&
+		memcmp(chainName, "POSTROUTING", strlen("POSTROUTING"))){
+		//printk("This rule is belong to %s, it will not add to acl!\n", chainName);
+		return 0;
+	}
+	#endif
+
+	/*last entry of this hooknum??*/
+	last_entry = 0;
+	if(((void *) e - (void *)base + e->next_offset) >= size)
+		last_entry = 1;
+
+	if(last_entry == 0)
+	{
+		nxt_entry = (struct ipt_entry *)((void *)e + e->next_offset);
+		nxt_hookNum = get_hookNum(nxt_entry,base,valid_hooks,hook_entries);
+		if(nxt_hookNum != hook_num)
+			last_entry = 1;
+
+		/*there are error rule at the end of the table...*/
+		nxt_target = ipt_get_target(nxt_entry);
+		if(nxt_target->u.kernel.target  == &ipt_error_target)
+		{
+			last_entry = 1;
+		}
+	}
+
+	if(hook_num < 0 || hook_num >= NF_INET_NUMHOOKS)
+	{
+		printk("!!!!BUG!!!!%s(%d)\n",__FUNCTION__,__LINE__);
+		goto next;
+	}
+
+	/*if this entry is the last entry of filter table INPUT chain or output chain*/
+	if(last_entry)
+	{
+		if(t->u.kernel.target == &ipt_standard_target)
+		{
+			switch((-((struct ipt_standard_target *)t)->verdict) -1)
+			{
+				case NF_DROP:
+					 default_action = RTL865X_ACL_DROP;
+					break;
+				case NF_ACCEPT:
+					 default_action = RTL865X_ACL_PERMIT;
+					break;
+				case NF_QUEUE:
+				case NF_REPEAT:
+				case NF_STOP:
+				case NF_STOLEN:
+					 default_action = RTL865X_ACL_TOCPU;
+					break;
+				default:
+					 default_action = RTL865X_ACL_TOCPU;
+					break;
+
+			}
+
+			if(hook_num == NF_INET_LOCAL_IN)
+				in_def_action = default_action;
+			else if(hook_num == NF_INET_LOCAL_OUT)
+				out_def_action = default_action;
+
+		}
+	}
+
+	///*only translate input&forward chain rule*/
+	//translate all chains for filter table now...
+	#if 0
+	if(	(hook_num >= NF_INET_LOCAL_OUT
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		&& memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN)
+#endif
+		) || (last_entry)	)
+		goto next;
+	#else
+	if(last_entry)
+		goto next;
+
+	#endif
+
+	list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
+	if(!list_node)
+	{
+		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+		goto next;
+	}
+
+	rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+	if(!rule)
+	{
+		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+		goto next;
+	}
+
+
+	memset(rule, 0,sizeof(rtl865x_AclRule_t));
+	//default: all packet to cpu
+	rule->actionType_ = RTL865X_ACL_TOCPU;
+	rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+	/*invert interface flag*/
+	if(e->ip.invflags & IPT_INV_VIA_IN)
+		rule->inv_flag = RTL865X_INVERT_IN_NETIF;
+
+	else if(e->ip.invflags & IPT_INV_VIA_OUT)
+		rule->inv_flag = RTL865X_INVERT_OUT_NETIF;
+
+	target = t->u.kernel.target;
+	match_cnt = IPT_MATCH_NUMBER(e);
+	retval = -1;
+	if(match_cnt == 0)
+	{
+		/*only ipt_ip & target information in iptables rule, no match rule*/
+		/*ip rule...*/
+		retval = ipt_ip2Acl(e,rule,&allMatch);
+
+		if(retval != 0)
+			printk("%s(%d) BUG!!!!\n",__FUNCTION__,__LINE__);
+
+		/*acl action....*/
+		if(t->u.kernel.target == &ipt_standard_target)
+		{
+			/*standard target*/
+			standard_target2Acl(t,rule);
+		}
+		else if (t->u.kernel.target->target2acl)
+		{
+			retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+			if(retval != 0)
+			{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+				/* Add the following conditions for pathing qos rules */
+				if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+					e->ip.outiface[0]=='\0' &&
+					retval == RTL_QOSFINDSPECIALNETIF)
+				{
+					memcpy(qosIfName, data, strlen(data));
+					qosIfName[strlen(data)] = '\0';
+					kfree(data);
+				}
+				else if (retval == RTL865X_SKIP_THIS_RULE)
+				{
+					goto next;
+				}
+				else
+#endif
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+			}
+		}
+		else
+		{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+			goto next;
+#endif
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+		}
+
+		/*deal with invert flags...*/
+		if(e->ip.invflags & (IPT_INV_SRCIP|IPT_INV_DSTIP | IPT_INV_PROTO))
+		{
+			if(rule->actionType_ == RTL865X_ACL_PERMIT)
+				rule->actionType_ = RTL865X_ACL_DROP;
+			else if (rule->actionType_ == RTL865X_ACL_DROP)
+				rule->actionType_ = RTL865X_ACL_PERMIT;
+		}
+	}
+	else if(match_cnt == 1)
+	{
+		__match = (void *)(e) + sizeof(struct ipt_entry);
+
+		/*translate match to ACL rule...*/
+		if(__match->u.kernel.match && __match->u.kernel.match->match2acl)
+		{
+			retval = __match->u.kernel.match->match2acl(name, &e->ip, __match->u.kernel.match, __match->data,rule,&invflags);
+			if(retval == 0)
+			{
+				/*translate target to ACL action*/
+				if(t->u.kernel.target == &ipt_standard_target)
+				{
+					/*standard target*/
+					standard_target2Acl(t,rule);
+					#if 0
+					switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+					{
+						case NF_DROP:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+							else
+								rule->actionType_ = RTL865X_ACL_DROP;
+							break;
+						case NF_ACCEPT:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else
+								rule->actionType_  = RTL865X_ACL_PERMIT;
+							break;
+						case NF_QUEUE:
+						case NF_REPEAT:
+						case NF_STOP:
+						case NF_STOLEN:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						default:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+
+					}
+					#endif
+				}
+				else if (t->u.kernel.target->target2acl)
+				{
+					retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+					if(retval != 0)
+					{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+						/* Add the following conditions for pathing qos rules */
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+							e->ip.outiface[0]=='\0' &&
+							retval == RTL_QOSFINDSPECIALNETIF)
+						{
+							memcpy(qosIfName, data, strlen(data));
+							qosIfName[strlen(data)] = '\0';
+							kfree(data);
+						}
+						else if (retval == RTL865X_SKIP_THIS_RULE)
+						{
+							goto next;
+						}
+						else
+#endif
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+					}
+					#if 0
+					else
+					{
+						if(invflags)
+						{
+							if(rule->actionType_ == RTL865X_ACL_PERMIT)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else if(rule->actionType_ == RTL865X_ACL_DROP)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+						}
+					}
+					#endif
+				}
+				else
+				{
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+
+				/*invert interface flag*/
+				if(invflags)
+				{
+					if(rule->actionType_ == RTL865X_ACL_PERMIT)
+						rule->actionType_ = RTL865X_ACL_DROP;
+					else if(rule->actionType_ == RTL865X_ACL_DROP)
+						rule->actionType_ = RTL865X_ACL_PERMIT;
+				}
+			}
+			else if (retval == RTL865X_ESTABLISH_RULE)
+			{
+				/*translate target to ACL action*/
+				if(t->u.kernel.target == &ipt_standard_target)
+				{
+					/*standard target*/
+					standard_target2Acl(t,rule);
+					#if 0
+					switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+					{
+						case NF_DROP:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+							else
+								rule->actionType_ = RTL865X_ACL_DROP;
+							break;
+						case NF_ACCEPT:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else
+								rule->actionType_  = RTL865X_ACL_PERMIT;
+							break;
+						case NF_QUEUE:
+						case NF_REPEAT:
+						case NF_STOP:
+						case NF_STOLEN:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						default:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+
+					}
+					#endif
+				}
+				else if (t->u.kernel.target->target2acl)
+				{
+					retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+					if(retval != 0)
+					{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+						/* Add the following conditions for pathing qos rules */
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+							e->ip.outiface[0]=='\0' &&
+							retval == RTL_QOSFINDSPECIALNETIF)
+						{
+							memcpy(qosIfName, data, strlen(data));
+							qosIfName[strlen(data)] = '\0';
+							kfree(data);
+						}
+						else if (retval == RTL865X_SKIP_THIS_RULE)
+						{
+							goto next;
+						}
+						else
+#endif
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+					}
+					#if 0
+					else
+					{
+						if(invflags)
+						{
+							if(rule->actionType_ == RTL865X_ACL_PERMIT)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else if(rule->actionType_ == RTL865X_ACL_DROP)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+						}
+					}
+					#endif
+				}
+				else
+				{
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+
+				/*invert interface flag*/
+				if(invflags)
+				{
+					if(rule->actionType_ == RTL865X_ACL_PERMIT)
+						rule->actionType_ = RTL865X_ACL_DROP;
+					else if(rule->actionType_ == RTL865X_ACL_DROP)
+						rule->actionType_ = RTL865X_ACL_PERMIT;
+				}
+
+				if(rule->actionType_ == RTL865X_ACL_PERMIT)
+					establish_rule_permit = 1;
+
+				goto next;
+			}
+			else if(retval == RTL865X_SKIP_THIS_RULE)
+			{
+				goto next;
+			}
+			else
+			{
+				rule->ruleType_		= RTL865X_ACL_MAC;
+				rule->actionType_	= RTL865X_ACL_TOCPU;
+				rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+			}
+		}
+		else
+		{
+			rule->ruleType_		= RTL865X_ACL_MAC;
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+		}
+	}
+	else if(match_cnt > 1)
+	{
+		int		len;
+		int		hasNoSpt = FALSE;
+
+		len = 0;
+		while(match_cnt>0)
+		{
+			__match = (void *)(e) + sizeof(struct ipt_entry) + len;
+
+			if(__match->u.kernel.match && __match->u.kernel.match->match2acl)
+			{
+				retval = __match->u.kernel.match->match2acl(name, &e->ip, __match->u.kernel.match, __match->data,rule,&invflags);
+
+				if(retval == 0)
+				{
+					len += __match->u.match_size;
+					match_cnt--;
+				}
+				else
+					break;
+			}
+			else
+			{
+				hasNoSpt = TRUE;
+				match_cnt--;
+//				retval = RTL865X_MATCH_NOT_SUPPORTED;
+//				break;
+			}
+		}
+
+		if (hasNoSpt==TRUE)
+			retval = RTL865X_MATCH_NOT_SUPPORTED;
+
+		if(retval == 0)
+		{
+
+			/*translate target to ACL action*/
+			if(t->u.kernel.target == &ipt_standard_target)
+			{
+				/*standard target*/
+				standard_target2Acl(t,rule);
+				#if 0
+				switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+				{
+					case NF_DROP:
+						if(invflags)
+							rule->actionType_ = RTL865X_ACL_PERMIT;
+						else
+							rule->actionType_ = RTL865X_ACL_DROP;
+						break;
+					case NF_ACCEPT:
+						if(invflags)
+							rule->actionType_ = RTL865X_ACL_DROP;
+						else
+							rule->actionType_  = RTL865X_ACL_PERMIT;
+						break;
+					case NF_QUEUE:
+					case NF_REPEAT:
+					case NF_STOP:
+					case NF_STOLEN:
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+						break;
+					default:
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+						break;
+
+				}
+				#endif
+			}
+			else if (t->u.kernel.target->target2acl)
+			{
+				retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+				if(retval != 0)
+				{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+					/* Add the following conditions for pathing qos rules */
+					if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) &&
+						e->ip.outiface[0]=='\0' &&
+						retval == RTL_QOSFINDSPECIALNETIF)
+					{
+						memcpy(qosIfName, data, strlen(data));
+						qosIfName[strlen(data)] = '\0';
+						kfree(data);
+					}
+					else if (retval == RTL865X_SKIP_THIS_RULE)
+					{
+						goto next;
+					}
+					else
+#endif
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+				else
+				{
+					if(invflags)
+					{
+						if(rule->actionType_ == RTL865X_ACL_PERMIT)
+							rule->actionType_ = RTL865X_ACL_DROP;
+						else if(rule->actionType_ == RTL865X_ACL_DROP)
+							rule->actionType_ = RTL865X_ACL_PERMIT;
+					}
+				}
+			}
+			else
+			{
+				rule->actionType_ = RTL865X_ACL_TOCPU;
+			}
+
+			/*invert interface flag*/
+			if(invflags)
+			{
+				if(rule->actionType_ == RTL865X_ACL_PERMIT)
+					rule->actionType_ = RTL865X_ACL_DROP;
+				else if(rule->actionType_ == RTL865X_ACL_DROP)
+					rule->actionType_ = RTL865X_ACL_PERMIT;
+			}
+
+		}
+		else if(retval == RTL865X_SKIP_THIS_RULE)
+		{
+			goto next;
+		}
+		else
+		{
+			/*add ACL trap all packet to CPU*/
+#if 0
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_		= RTL865X_ACL_MAC;
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+#else
+			/* For some un-support type rules, only trap the special kinds of pkt instead of trap all */
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+#endif
+		}
+	}
+	else
+		goto next;
+
+	/*add xt_rule_to_acl to list*/
+	/*
+	  *	Since we do the acl check actually in PREROUTING chain
+	  *	Some toCpu pkt maybe mis-decided by FORWARD chain rules
+	  *	So, we do the following patch.
+	  */
+	if(hook_num == NF_INET_FORWARD)
+	{
+		if(rule->actionType_ != RTL865X_ACL_PERMIT)
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+
+		rule->pktOpApp_ = RTL865X_ACL_L3_AND_L4;
+	}
+
+	if(hook_num <NF_INET_LOCAL_OUT)
+		rule->direction_ = RTL865X_ACL_INGRESS;
+	else
+		rule->direction_ = RTL865X_ACL_EGRESS;
+
+	list_node->aclRule = rule;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	if (qosIfName[0]!='\0')
+	{
+		memcpy(&list_node->iniface,qosIfName,strlen(qosIfName));
+		list_node->iniface[strlen(qosIfName)] = '\0';
+	}
+	else
+#endif
+	{
+		memcpy(&list_node->iniface,&e->ip.iniface,strlen(e->ip.iniface)+1);
+		list_node->iniface[strlen(e->ip.iniface)] = '\0';
+	}
+
+	{
+		memcpy(&list_node->outiface,&e->ip.outiface,strlen(e->ip.outiface)+1);
+		list_node->outiface[strlen(e->ip.outiface)] = '\0';
+	}
+
+	/*now, add this rule to releated chain*/
+
+	ipt2AclTbl = rtl865x_get_ipt2Acl_tbl(name);
+	if(ipt2AclTbl == NULL)
+		goto next;
+
+	if((allMatch == 1) && (!memcmp(name,"filter",strlen("filter"))))
+		list_add_tail(&list_node->list,&rtl865x_iptRule2Acl_def_rule_list);
+	else
+		list_add_tail(&list_node->list, &ipt2AclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_0]);
+
+	return 0;
+
+next:
+
+	/*free memory and return*/
+	if(rule)
+		kfree(rule);
+
+	if(list_node)
+		kfree(list_node);
+
+	return 0;
+
+}
+
+static int translate_ipTblRules2Acl(const char *name,
+		unsigned int valid_hooks,
+		struct xt_table_info *newinfo,
+		void *entry0,
+		unsigned int size,
+		unsigned int number,
+		const unsigned int *hook_entries,
+		const unsigned int *underflows)
+{
+	int	ret;
+	rtl865x_AclRule_t *rule;
+	xt_rule_to_acl_t *list_node,*nxt;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl;
+
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#else
+	if(memcmp(name,"filter",strlen("filter")) != 0)
+		return 0;
+#endif
+
+	ipt2aclTbl = rtl865x_get_ipt2Acl_tbl(name);
+
+	if(!ipt2aclTbl)
+	{
+		return 0;
+	}
+
+	#if defined(CONFIG_RTL_AVOID_UPNP_RULE_TO_ACL)
+	ret = IPT_ENTRY_ITERATE(entry0, size,translate_rule2Acl, entry0,name,size,valid_hooks,hook_entries, newinfo);
+	#else
+	ret = IPT_ENTRY_ITERATE(entry0, size,translate_rule2Acl, entry0,name,size,valid_hooks,hook_entries);
+	#endif
+	
+	/*merge def_rule_list to match_to_acl_rule_list*/
+	if (!memcmp(name,"filter",strlen("filter")))
+	{
+		list_for_each_entry_safe(list_node,nxt,&rtl865x_iptRule2Acl_def_rule_list,list)
+		{
+			list_del(&list_node->list);
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
+		}
+
+	/*hyking:
+		iptables rule can't deal with packets whose action is layer2 switch,
+		so, patch this case when def_action is drop...
+	*/
+//	if((def_action == RTL865X_ACL_DROP) && !memcmp(name,"filter",strlen("filter")))
+		if(establish_rule_permit == 1)
+			in_def_action = RTL865X_ACL_PERMIT;
+
+		if((in_def_action == RTL865X_ACL_DROP))
+		{
+			/*deal with the permit multicast acl...*/
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
+			if(!list_node)
+			{
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+
+			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+			if(!rule)
+			{
+				if(list_node)
+					kfree(list_node);
+
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+
+			/*permit all multicast packet...*/
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_ = RTL865X_ACL_MAC;
+			rule->actionType_ = RTL865X_ACL_PERMIT;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+			rule->dstMac_.octet[0] = 0x01;
+			rule->dstMacMask_.octet[0] = 0x01;
+
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
+
+			/*permit all arp packet*/
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
+			if(!list_node)
+			{
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+
+			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+			if(!rule)
+			{
+				if(list_node)
+					kfree(list_node);
+
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+
+			/*permit all arp packet...*/
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_ = RTL865X_ACL_MAC;
+			rule->actionType_ = RTL865X_ACL_PERMIT;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+			rule->typeLen_ = 0x0806;
+			rule->typeLenMask_ = 0xffff;
+
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
+
+		}
+
+		//in bound
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
+		if(!list_node)
+		{
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
+		}
+
+		rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+		if(!rule)
+		{
+			if(list_node)
+				kfree(list_node);
+
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
+		}
+
+		memset(rule, 0,sizeof(rtl865x_AclRule_t));
+
+
+		{
+			rule->ruleType_	= RTL865X_ACL_MAC;
+			rule->actionType_	= in_def_action;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+			rule->direction_ = RTL865X_ACL_INGRESS;
+
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
+		}
+
+		//outbound
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);
+		if(!list_node)
+		{
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
 	}
 
-	if (e->target_offset + sizeof(struct ipt_entry_target) >
-	    e->next_offset)
-		return -EINVAL;
+		rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+		if(!rule)
+		{
+			if(list_node)
+				kfree(list_node);
 
-	t = ipt_get_target(e);
-	if (e->target_offset + t->u.target_size > e->next_offset)
-		return -EINVAL;
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
+		}
 
-	return 0;
-}
+		memset(rule, 0,sizeof(rtl865x_AclRule_t));
 
-static int
-check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
-	    unsigned int *i)
-{
-	const struct ipt_ip *ip = par->entryinfo;
-	int ret;
 
-	par->match     = m->u.kernel.match;
-	par->matchinfo = m->data;
+		{
+			rule->ruleType_	= RTL865X_ACL_MAC;
+			rule->actionType_	= out_def_action;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+			rule->direction_ = RTL865X_ACL_EGRESS;
 
-	ret = xt_check_match(par, m->u.match_size - sizeof(*m),
-	      ip->proto, ip->invflags & IPT_INV_PROTO);
-	if (ret < 0) {
-		duprintf("ip_tables: check failed for `%s'.\n",
-			 par.match->name);
-		return ret;
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
 	}
-	++*i;
+	}
+
 	return 0;
+
+next:
+	return ret;
 }
 
-static int
-find_check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
-		 unsigned int *i)
+static int rtl865x_free_chain_inIpt2Acl_tbl(struct list_head *listHead)
 {
-	struct xt_match *match;
-	int ret;
-
-	match = try_then_request_module(xt_find_match(AF_INET, m->u.user.name,
-						      m->u.user.revision),
-					"ipt_%s", m->u.user.name);
-	if (IS_ERR(match) || !match) {
-		duprintf("find_check_match: `%s' not found\n", m->u.user.name);
-		return match ? PTR_ERR(match) : -ENOENT;
+	/*free all xtmatch rule*/
+	xt_rule_to_acl_t *match2acl,*nxt;
+	list_for_each_entry_safe(match2acl,nxt,listHead,list)
+	{
+		list_del(&match2acl->list);
+		kfree(match2acl->aclRule);
+		kfree(match2acl);
 	}
-	m->u.kernel.match = match;
-
-	ret = check_match(m, par, i);
-	if (ret)
-		goto err;
 
 	return 0;
-err:
-	module_put(m->u.kernel.match->me);
-	return ret;
 }
 
-static int check_target(struct ipt_entry *e, const char *name)
+static int rtl865x_free_allchains_inIpt2Acl_tbl(char *name)
 {
-	struct ipt_entry_target *t = ipt_get_target(e);
-	struct xt_tgchk_param par = {
-		.table     = name,
-		.entryinfo = e,
-		.target    = t->u.kernel.target,
-		.targinfo  = t->data,
-		.hook_mask = e->comefrom,
-		.family    = NFPROTO_IPV4,
-	};
-	int ret;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl = NULL;
+	int i;
 
-	ret = xt_check_target(&par, t->u.target_size - sizeof(*t),
-	      e->ip.proto, e->ip.invflags & IPT_INV_PROTO);
-	if (ret < 0) {
-		duprintf("ip_tables: check failed for `%s'.\n",
-			 t->u.kernel.target->name);
-		return ret;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN))
+	{
+		rtl865x_qosFlushMarkRule();
+	}
+#endif
+
+	ipt2aclTbl = rtl865x_get_ipt2Acl_tbl(name);
+
+	if(!ipt2aclTbl)
+		return -1;
+
+	for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+	{
+		rtl865x_free_chain_inIpt2Acl_tbl(&ipt2aclTbl->chainList[i]);
 	}
+
 	return 0;
 }
 
@@ -666,118 +1906,114 @@ static int check_target(struct ipt_entry
 	return 0;
 }
 
-static int
-find_check_entry(struct ipt_entry *e, const char *name, unsigned int size,
-		 unsigned int *i)
+void rtl865x_rearrange_ipt2Acl_tbl(char *name)
 {
-	struct ipt_entry_target *t;
-	struct xt_target *target;
-	int ret;
-	unsigned int j;
-	struct xt_mtchk_param mtpar;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl;
+	xt_rule_to_acl_t *match2acl;
+	int i,retval;
+#if defined(CONFIG_RTL_IPTABLES2ACL_PATCH)
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		rtl865x_flush_allAcl_sw_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_INGRESS);
+		rtl865x_flush_allAcl_sw_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_EGRESS);
+	}
 
-	ret = check_entry(e, name);
-	if (ret)
-		return ret;
+	//_rtl865x_synAclwithAsicTbl();
 
-	j = 0;
-	mtpar.table     = name;
-	mtpar.entryinfo = &e->ip;
-	mtpar.hook_mask = e->comefrom;
-	mtpar.family    = NFPROTO_IPV4;
-	ret = IPT_MATCH_ITERATE(e, find_check_match, &mtpar, &j);
-	if (ret != 0)
-		goto cleanup_matches;
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			list_for_each_entry(match2acl,&ipt2aclTbl->chainList[i],list)
+			{
+				retval = rtl865x_add_sw_acl(match2acl->aclRule, match2acl->iniface, ipt2aclTbl->priority);
+			}
+		}
 
-	t = ipt_get_target(e);
-	target = try_then_request_module(xt_find_target(AF_INET,
-							t->u.user.name,
-							t->u.user.revision),
-					 "ipt_%s", t->u.user.name);
-	if (IS_ERR(target) || !target) {
-		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
-		ret = target ? PTR_ERR(target) : -ENOENT;
-		goto cleanup_matches;
 	}
-	t->u.kernel.target = target;
 
-	ret = check_target(e, name);
-	if (ret)
-		goto err;
+	_rtl865x_synAclwithAsicTbl();
+#else
+	//hyking:since default permit before rearrange rules to acl table,don't add permit acl now.
+	//rtl865x_add_def_permit_acl();
 
-	(*i)++;
-	return 0;
- err:
-	module_put(t->u.kernel.target->me);
- cleanup_matches:
-	IPT_MATCH_ITERATE(e, cleanup_match, &j);
-	return ret;
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		/*firstly, remove all acl which is add by user...*/
+		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_INGRESS);
+		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_EGRESS);
+
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			list_for_each_entry(match2acl,&ipt2aclTbl->chainList[i],list)
+			{
+				retval = rtl865x_add_acl(match2acl->aclRule, match2acl->iniface, ipt2aclTbl->priority);
+			}
+		}
+	}
+
+	//rtl865x_del_def_permit_acl();
+#endif
 }
 
-static int
-check_entry_size_and_hooks(struct ipt_entry *e,
-			   struct xt_table_info *newinfo,
-			   unsigned char *base,
-			   unsigned char *limit,
-			   const unsigned int *hook_entries,
-			   const unsigned int *underflows,
-			   unsigned int *i)
+
+/*
+	tbl->priority: the minimum has highest priority
+*/
+int rtl865x_register_ipt2Acl_tbl(rtl865x_iptRule2Acl_tbl *tbl)
 {
-	unsigned int h;
+	rtl865x_iptRule2Acl_tbl *node,*insPos;
 
-	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0
-	    || (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
-		duprintf("Bad offset %p\n", e);
-		return -EINVAL;
-	}
+	insPos = NULL;
+	node = NULL;
 
-	if (e->next_offset
-	    < sizeof(struct ipt_entry) + sizeof(struct ipt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
-		return -EINVAL;
-	}
+	node = rtl865x_get_ipt2Acl_tbl(tbl->tblName);
+	if(node != NULL)
+		return -1;
 
-	/* Check hooks & underflows */
-	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
-		if ((unsigned char *)e - base == hook_entries[h])
-			newinfo->hook_entry[h] = hook_entries[h];
-		if ((unsigned char *)e - base == underflows[h])
-			newinfo->underflow[h] = underflows[h];
+	list_for_each_entry(node,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		if(node->priority > tbl->priority)
+		{
+			insPos = node;
+			break;
+		}
 	}
 
-	/* FIXME: underflows must be unconditional, standard verdicts
-	   < 0 (not IPT_RETURN). --RR */
-
-	/* Clear counters and comefrom */
-	e->counters = ((struct xt_counters) { 0, 0 });
-	e->comefrom = 0;
+	/*now, insert before the insPos*/
+	if(insPos)
+	{
+		list_add(&tbl->list, insPos->list.prev);
+	}
+	else
+	{
+		list_add_tail(&tbl->list, &rtl865x_iptRule2Acl_tbl_list);
+	}
 
-	(*i)++;
 	return 0;
 }
 
-static int
-cleanup_entry(struct ipt_entry *e, unsigned int *i)
+int rtl865x_unregister_ipt2Acl_tbl(char *tblName)
 {
-	struct xt_tgdtor_param par;
-	struct ipt_entry_target *t;
+	rtl865x_iptRule2Acl_tbl *listNode,*nxt;
+	int i;
+	list_for_each_entry_safe(listNode, nxt, &rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		if(memcmp(listNode->tblName,tblName,strlen(tblName)) == 0)
+		{
+			list_del(&listNode->list);
+			for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+				rtl865x_free_chain_inIpt2Acl_tbl(&listNode->chainList[i]);
+			kfree(listNode);
+			return 0;
+		}
+	}
 
-	if (i && (*i)-- == 0)
-		return 1;
+	return -1;
+}
 
-	/* Cleanup all matches */
-	IPT_MATCH_ITERATE(e, cleanup_match, NULL);
-	t = ipt_get_target(e);
+#endif
 
-	par.target   = t->u.kernel.target;
-	par.targinfo = t->data;
-	par.family   = NFPROTO_IPV4;
-	if (par.target->destroy != NULL)
-		par.target->destroy(&par);
-	module_put(par.target->me);
-	return 0;
-}
 
 /* Checks and translates the user-supplied table segment (held in
    newinfo) */
@@ -851,7 +2081,51 @@ translate_table(const char *name,
 				cleanup_entry, &i);
 		return ret;
 	}
+	#if defined(CONFIG_RTL_819X)
+	rtl_translate_table_hooks(name,valid_hooks,newinfo,entry0,size,number,hook_entries,underflows);
+	#endif
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	{
+		rtl865x_iptRule2Acl_tbl *tbl;
+		int i,ret;
+		int32_t priority;
+
+		if(memcmp(name,"filter",strlen("filter")) == 0)
+			priority = RTL865X_ACL_USER_USED;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		else if(memcmp(name,RTL865X_QOS_TABLE_NAME,RTL865X_QOS_TABLE_LEN) == 0)
+			priority = RTL865X_ACL_QOS_USED2;
+#endif
+		else
+			priority = 1024;
+
+		if(priority < 1024)
+		{
+			tbl = kmalloc(sizeof(rtl865x_iptRule2Acl_tbl), GFP_KERNEL);
+			if(!tbl)
+				return 0;
+			memset(tbl, 0, sizeof(rtl865x_iptRule2Acl_tbl));
+			for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+			{
+				INIT_LIST_HEAD(&tbl->chainList[i]);
+			}
+			tbl->priority = priority;
+			memcpy(tbl->tblName,name,strlen(name));
+			tbl->tblName[strlen(name)] = '\0';
+
+			ret = rtl865x_register_ipt2Acl_tbl(tbl);
 
+			if(ret != 0)
+			{
+				kfree(tbl);
+			}
+		}
+	}
+#endif
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	translate_ipTblRules2Acl(name,valid_hooks,newinfo,entry0,size,number,hook_entries,underflows);
+#endif
 	/* And one copy for every other CPU */
 	for_each_possible_cpu(i) {
 		if (newinfo->entries[i] && newinfo->entries[i] != entry0)
@@ -1286,7 +2559,11 @@ do_replace(struct net *net, void __user
 		ret = -EFAULT;
 		goto free_newinfo;
 	}
-
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	/*firstly, free all iptblAcl which added last time*/
+	establish_rule_permit = 0;
+	rtl865x_free_allchains_inIpt2Acl_tbl(tmp.name);
+#endif
 	ret = translate_table(tmp.name, tmp.valid_hooks,
 			      newinfo, loc_cpu_entry, tmp.size, tmp.num_entries,
 			      tmp.hook_entry, tmp.underflow);
@@ -1299,11 +2576,23 @@ do_replace(struct net *net, void __user
 			   tmp.num_counters, tmp.counters);
 	if (ret)
 		goto free_newinfo_untrans;
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	//rtl865x_rearrange_iptblAcl();
+	//rtl865x_print_iptRule2Acl_tbl();
+	rtl865x_rearrange_ipt2Acl_tbl(tmp.name);
+#endif
+
 	return 0;
 
  free_newinfo_untrans:
 	IPT_ENTRY_ITERATE(loc_cpu_entry, newinfo->size, cleanup_entry, NULL);
  free_newinfo:
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	rtl865x_free_allchains_inIpt2Acl_tbl(tmp.name);
+#endif
+
 	xt_free_table_info(newinfo);
 	return ret;
 }
@@ -2154,6 +3443,50 @@ static bool icmp_checkentry(const struct
 	return !(icmpinfo->invflags & ~IPT_ICMP_INV);
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int icmp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct ipt_icmp *icmpinfo = matchinfo;
+	unsigned int code_range = 0;
+	int i = 0;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_ICMP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->icmpType_ 	= icmpinfo->type;
+	rule->icmpTypeMask_ 	= 0xff;
+	//rule->icmpCode_	= icmpinfo->code;
+	code_range = icmpinfo->code[1] - icmpinfo->code[0];
+	for(i = 0; i <8 ; i++)
+	{
+		if(code_range >> i)
+			continue;
+		break;
+	}
+	rule->icmpCode_	= icmpinfo->code[0];
+	rule->icmpCodeMask_ = 0xff << i;
+
+	if(icmpinfo->invflags & IPT_ICMP_INV)
+		if(invflags)
+			*invflags = 1;
+
+	return 0;
+}
+#endif
 /* The built-in targets: standard (NULL) and error. */
 static struct xt_target ipt_standard_target __read_mostly = {
 	.name		= IPT_STANDARD_TARGET,
@@ -2197,6 +3530,9 @@ static struct xt_match icmp_matchstruct
 	.checkentry	= icmp_checkentry,
 	.proto		= IPPROTO_ICMP,
 	.family		= AF_INET,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	.match2acl	= icmp_match2acl,
+#endif
 };
 
 static int __net_init ip_tables_net_init(struct net *net)
@@ -2238,6 +3574,14 @@ static int __init ip_tables_init(void)
 	if (ret < 0)
 		goto err5;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_ip_tables_init_hooks();
+	#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+		IgmpRxFilter_Hook = ipt_do_table;
+#endif
+
 	printk(KERN_INFO "ip_tables: (C) 2000-2006 Netfilter Core Team\n");
 	return 0;
 
@@ -2262,6 +3606,10 @@ static void __exit ip_tables_fini(void)
 	xt_unregister_target(&ipt_standard_target);
 
 	unregister_pernet_subsys(&ip_tables_net_ops);
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+	IgmpRxFilter_Hook = NULL;
+#endif
 }
 
 EXPORT_SYMBOL(ipt_register_table);
--- linux-2.6.30.9/net/ipv4/netfilter/ipt_MASQUERADE.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/ipt_MASQUERADE.c	2013-05-02 01:47:59.284226608 +0300
@@ -23,6 +23,14 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter/x_tables.h>
 
+#if defined (CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#include <net/rtl/rtl865x_localPublic.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: automatic-address SNAT");
@@ -56,6 +64,10 @@ masquerade_tg(struct sk_buff *skb, const
 	const struct nf_nat_multi_range_compat *mr;
 	const struct rtable *rt;
 	__be32 newsrc;
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+	extern unsigned int conenat_type;
+	unsigned int ret;
+#endif
 
 	NF_CT_ASSERT(par->hooknum == NF_INET_POST_ROUTING);
 
@@ -73,16 +85,46 @@ masquerade_tg(struct sk_buff *skb, const
 
 	mr = par->targinfo;
 	rt = skb->rtable;
+#if 0
 	newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
 	if (!newsrc) {
 		printk("MASQUERADE: %s ate my IP address\n", par->out->name);
 		return NF_DROP;
 	}
-
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(skb->srcLocalPublicIp!=0)
+	{
+		newsrc=skb->srcLocalPublicIp;
+	}
+	else
+	{
+		newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
+		if (!newsrc) {
+			printk("MASQUERADE: %s ate my IP address\n", par->out->name);
+			return NF_DROP;
+		}
+	}
+#else
+	newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
+	if (!newsrc) {
+		printk("MASQUERADE: %s ate my IP address\n", par->out->name);
+		return NF_DROP;
+	}
+#endif
 	write_lock_bh(&masq_lock);
 	nat->masq_index = par->out->ifindex;
 	write_unlock_bh(&masq_lock);
 
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+	if ((conenat_type >=1) && (conenat_type <= 3) &&
+	     (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_UDP))
+	{
+	       extern unsigned int rtl_find_appropriate_newrange(struct nf_conn *ct, __be32 newsrc, const struct nf_nat_multi_range_compat *mr);
+		ret = rtl_find_appropriate_newrange(ct, newsrc, mr);
+		return ret;
+	}
+#endif
 	/* Transfer from original range. */
 	newrange = ((struct nf_nat_range)
 		{ mr->range[0].flags | IP_NAT_RANGE_MAP_IPS,
@@ -125,6 +167,9 @@ static int masq_device_event(struct noti
 		nf_ct_iterate_cleanup(net, device_cmp,
 				      (void *)(long)dev->ifindex);
 	}
+	#if defined (CONFIG_RTL_819X)
+	rtl_masq_device_event_hooks(this, dev,event);
+	#endif
 
 	return NOTIFY_DONE;
 }
@@ -134,7 +179,16 @@ static int masq_inet_event(struct notifi
 			   void *ptr)
 {
 	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
-	return masq_device_event(this, event, dev);
+
+	if(event == NETDEV_DOWN)
+		masq_device_event(this, event, dev);
+
+	#if defined (CONFIG_RTL_819X)
+	rtl_masq_inet_event_hooks(this, event,  ptr);
+	#endif
+
+	return NOTIFY_DONE;
+
 }
 
 static struct notifier_block masq_dev_notifier = {
--- linux-2.6.30.9/net/ipv4/netfilter/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/Kconfig	2013-05-02 01:47:59.281226608 +0300
@@ -181,6 +181,23 @@ config IP_NF_TARGET_MASQUERADE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config IP_NF_TARGET_CONENAT
+        tristate "CONENAT target support"
+        depends on NF_NAT
+	depends on IP_NF_TARGET_MASQUERADE
+        default m if NETFILTER_ADVANCED=n
+        help
+          It is a FULL CONE NAT(see RFC 3489), you can use it instead of MASQUERADE.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
+config IP_NF_TARGET_TRIGGER
+        tristate "TRIGGER port target support"
+        depends on NF_NAT
+        default m if NETFILTER_ADVANCED=n
+        help
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config IP_NF_TARGET_NETMAP
 	tristate "NETMAP target support"
 	depends on NF_NAT
@@ -283,6 +302,22 @@ config NF_NAT_SIP
 	depends on NF_CONNTRACK && NF_NAT
 	default NF_NAT && NF_CONNTRACK_SIP
 
+#
+# Desc:add ip sec for alg
+#
+config NF_NAT_IPSEC
+        tristate
+        depends on NF_CONNTRACK && NF_NAT
+        default NF_NAT && NF_CONNTRACK_IPSEC
+
+#
+# Desc:add rtsp for alg
+#
+config NF_NAT_RTSP
+        tristate
+        depends on NF_CONNTRACK && NF_NAT
+        default NF_NAT && NF_CONNTRACK_RTSP
+
 # mangle + specific targets
 config IP_NF_MANGLE
 	tristate "Packet mangling"
--- linux-2.6.30.9/net/ipv4/netfilter/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/Makefile	2013-05-02 01:47:59.281226608 +0300
@@ -30,7 +30,8 @@ obj-$(CONFIG_NF_NAT_PPTP) += nf_nat_pptp
 obj-$(CONFIG_NF_NAT_SIP) += nf_nat_sip.o
 obj-$(CONFIG_NF_NAT_SNMP_BASIC) += nf_nat_snmp_basic.o
 obj-$(CONFIG_NF_NAT_TFTP) += nf_nat_tftp.o
-
+obj-$(CONFIG_NF_NAT_IPSEC) += nf_nat_ipsec.o
+obj-$(CONFIG_NF_NAT_RTSP) += nf_nat_rtsp.o
 # NAT protocols (nf_nat)
 obj-$(CONFIG_NF_NAT_PROTO_DCCP) += nf_nat_proto_dccp.o
 obj-$(CONFIG_NF_NAT_PROTO_GRE) += nf_nat_proto_gre.o
@@ -61,7 +62,8 @@ obj-$(CONFIG_IP_NF_TARGET_NETMAP) += ipt
 obj-$(CONFIG_IP_NF_TARGET_REDIRECT) += ipt_REDIRECT.o
 obj-$(CONFIG_IP_NF_TARGET_REJECT) += ipt_REJECT.o
 obj-$(CONFIG_IP_NF_TARGET_ULOG) += ipt_ULOG.o
-
+obj-$(CONFIG_IP_NF_TARGET_CONENAT) += ipt_CONENAT.o
+obj-$(CONFIG_IP_NF_TARGET_TRIGGER) += ipt_TRIGGER.o
 # generic ARP tables
 obj-$(CONFIG_IP_NF_ARPTABLES) += arp_tables.o
 obj-$(CONFIG_IP_NF_ARP_MANGLE) += arpt_mangle.o
@@ -70,4 +72,6 @@ obj-$(CONFIG_IP_NF_ARP_MANGLE) += arpt_m
 obj-$(CONFIG_IP_NF_ARPFILTER) += arptable_filter.o
 
 obj-$(CONFIG_IP_NF_QUEUE) += ip_queue.o
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
 
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
--- linux-2.6.30.9/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2013-05-02 01:47:59.287226608 +0300
@@ -186,6 +186,12 @@ static struct nf_hook_ops ipv4_conntrack
 };
 
 #if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+extern int conntrack_dointvec(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+#endif
+
 static int log_invalid_proto_min = 0;
 static int log_invalid_proto_max = 255;
 
@@ -196,7 +202,11 @@ static ctl_table ip_ct_sysctl_table[] =
 		.data		= &nf_conntrack_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		.proc_handler	= &conntrack_dointvec,
+#else
 		.proc_handler	= proc_dointvec,
+#endif
 	},
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_COUNT,
--- linux-2.6.30.9/net/ipv4/netfilter/nf_nat_core.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_core.c	2013-05-02 01:47:59.288226608 +0300
@@ -31,6 +31,16 @@
 #include <net/netfilter/nf_conntrack_l3proto.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
 
+#include <linux/inetdevice.h>
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+#include <net/rtl/features/rtl_ps_log.h>
+
 static DEFINE_SPINLOCK(nf_nat_lock);
 
 static struct nf_conntrack_l3proto *l3proto __read_mostly;
@@ -265,13 +275,51 @@ get_unique_tuple(struct nf_conntrack_tup
 		proto->unique_tuple(tuple, range, maniptype, ct);
 		goto out;
 	}
+#if defined (CONFIG_RTL_HARDWARE_NAT)	&& defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+	/* Only bother mapping if it's not already in range and unique */
+	if ((!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED) ||
+	     proto->in_range(tuple, maniptype, &range->min, &range->max)) &&
+	    !nf_nat_used_tuple(tuple, ct)) {
+		if(	(gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC) &&
+			((orig_tuple->dst.protonum==IPPROTO_TCP) ||(orig_tuple->dst.protonum==IPPROTO_UDP)))
+		{
+			unsigned int asicNaptHashScore=0;
+			rtl865x_napt_entry rtl865xNaptEntry;
+			
+			rtl865xNaptEntry.protocol = (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum==IPPROTO_TCP)? 1: 0;
+		
+			rtl865xNaptEntry.intIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+			rtl865xNaptEntry.remIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+			rtl865xNaptEntry.extIp = tuple->src.u3.ip;
+			rtl865xNaptEntry.intPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+			rtl865xNaptEntry.remPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.udp.port;
+			rtl865xNaptEntry.extPort = rtl865xNaptEntry.protocol?tuple->src.u.tcp.port:tuple->src.u.udp.port;
+			
+			rtl865x_getAsicNaptHashScore(&rtl865xNaptEntry, &asicNaptHashScore);
+			/*
+			printk("%s:%d:maniptype is %d,%s (%u.%u.%u.%u:%u ->  %u.%u.%u.%u:%u ->%u.%u.%u.%u:%u),asicNaptHashScore is %d\n\n\n",
+				__FUNCTION__,__LINE__,maniptype, proto?"tcp":"udp", 
+				NIPQUAD(sip), sp, NIPQUAD(gip), gp, NIPQUAD(dip), dp,asicNaptHashScore);	
+			*/
+			if(asicNaptHashScore==100)
+			{
+				rtl865x_preReserveConn(&rtl865xNaptEntry);
+				goto out;
+			}
 
+		}
+		else
+		{
+			goto out;
+		}
+	}
+#else
 	/* Only bother mapping if it's not already in range and unique */
 	if ((!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED) ||
 	     proto->in_range(tuple, maniptype, &range->min, &range->max)) &&
 	    !nf_nat_used_tuple(tuple, ct))
 		goto out;
-
+#endif	
 	/* Last change: get protocol to try to obtain unique tuple. */
 	proto->unique_tuple(tuple, range, maniptype, ct);
 out:
@@ -286,6 +334,12 @@ nf_nat_setup_info(struct nf_conn *ct,
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_tuple curr_tuple, new_tuple;
 	struct nf_conn_nat *nat;
+	#if defined(CONFIG_RTL_BATTLENET_ALG)
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct_temp = NULL;
+	int flag_ori;
+	#endif
 	int have_to_hash = !(ct->status & IPS_NAT_DONE_MASK);
 
 	/* nat helper or nfctnetlink also setup binding */
@@ -319,6 +372,25 @@ nf_nat_setup_info(struct nf_conn *ct,
 		nf_ct_invert_tuplepr(&reply, &new_tuple);
 		nf_conntrack_alter_reply(ct, &reply);
 
+		#if defined(CONFIG_RTL_BATTLENET_ALG)
+		if((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum == IPPROTO_UDP) &&
+		    (ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all) == BATTLENET_PORT) &&
+		    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+		    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)))
+		{
+			spin_lock_bh(&nf_conntrack_lock);
+
+			ct_temp = rtl_find_ct_by_tuple_src(&(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple), &flag_ori);
+
+			if((flag_ori == 1) && (ct_temp != NULL))
+			{
+				if((ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all) != (ct_temp->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all))
+					ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all  = ct_temp->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+			}
+
+			spin_unlock_bh(&nf_conntrack_lock);
+		}
+		#endif
 		/* Non-atomic: we own this at the moment. */
 		if (maniptype == IP_NAT_MANIP_SRC)
 			ct->status |= IPS_SRC_NAT;
@@ -384,7 +456,32 @@ manip_pkt(u_int16_t proto,
 	}
 	return true;
 }
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+static void rtl_set_nat_status(struct nf_conn *ct, struct sk_buff *skb, enum nf_nat_manip_type mtype)
+{
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+
+	if((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
+	  (ntohs(ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all) == BATTLENET_PORT) &&
+	  ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip == wan_ip)&&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip != ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip) &&
+	  (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip != ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip))
+	  {
+		if (mtype == IP_NAT_MANIP_SRC)
+			ct->status |= IPS_SRC_NAT;
+		else
+			ct->status |= IPS_DST_NAT;
 
+		/* It's done. */
+		if (mtype == IP_NAT_MANIP_DST)
+			set_bit(IPS_DST_NAT_DONE_BIT, &ct->status);
+		else
+			set_bit(IPS_SRC_NAT_DONE_BIT, &ct->status);
+	  }
+}
+#endif
 /* Do packet manipulations according to nf_nat_setup_info. */
 unsigned int nf_nat_packet(struct nf_conn *ct,
 			   enum ip_conntrack_info ctinfo,
@@ -394,6 +491,12 @@ unsigned int nf_nat_packet(struct nf_con
 	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 	unsigned long statusbit;
 	enum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
+	#if defined(CONFIG_RTL_BATTLENET_ALG)
+	rtl_set_nat_status(ct, skb, mtype);
+	#endif
 
 	if (mtype == IP_NAT_MANIP_SRC)
 		statusbit = IPS_SRC_NAT;
@@ -413,6 +516,14 @@ unsigned int nf_nat_packet(struct nf_con
 
 		if (!manip_pkt(target.dst.protonum, skb, 0, &target, mtype))
 			return NF_DROP;
+
+		#if defined(CONFIG_RTL_819X)
+		conn_info.ct = ct;
+		conn_info.skb = skb;
+		conn_info.hooknum = hooknum;
+		conn_info.ctinfo = ctinfo;
+		rtl_nf_nat_packet_hooks(&conn_info);
+		#endif
 	}
 	return NF_ACCEPT;
 }
@@ -750,6 +861,11 @@ static int __init nf_nat_init(void)
 	BUG_ON(nfnetlink_parse_nat_setup_hook != NULL);
 	rcu_assign_pointer(nfnetlink_parse_nat_setup_hook,
 			   nfnetlink_parse_nat_setup);
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_nat_init_hooks();
+	#endif
+
 	return 0;
 
  cleanup_extend:
@@ -759,6 +875,11 @@ static int __init nf_nat_init(void)
 
 static void __exit nf_nat_cleanup(void)
 {
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_nat_cleanup_hooks();
+	#endif
+
 	unregister_pernet_subsys(&nf_nat_net_ops);
 	nf_ct_l3proto_put(l3proto);
 	nf_ct_extend_unregister(&nat_extend);
--- linux-2.6.30.9/net/ipv4/netfilter/nf_nat_proto_common.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_proto_common.c	2013-05-02 01:47:59.290226608 +0300
@@ -17,6 +17,13 @@
 #include <net/netfilter/nf_nat_rule.h>
 #include <net/netfilter/nf_nat_protocol.h>
 
+#if defined (CONFIG_RTL_LAYERED_DRIVER) && defined (CONFIG_RTL_LAYERED_DRIVER_L4) && defined (CONFIG_RTL_HARDWARE_NAT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_nat.h>
+#endif
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
+extern __DRAM_GEN int gHwNatEnabled;
+#endif
 bool nf_nat_proto_in_range(const struct nf_conntrack_tuple *tuple,
 			   enum nf_nat_manip_type maniptype,
 			   const union nf_conntrack_man_proto *min,
@@ -43,6 +50,15 @@ bool nf_nat_proto_unique_tuple(struct nf
 	unsigned int range_size, min, i;
 	__be16 *portptr;
 	u_int16_t off;
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
+	unsigned int tryCnt=0;
+	rtl865x_napt_entry rtl865xNaptEntry;
+	unsigned int asicNaptHashScore=0;
+	unsigned int highestScore=0;
+	unsigned int lowestScore=0;
+	__be16 bestCandidatePort=0;
+	__be16 newOff=0;
+#endif
 
 	if (maniptype == IP_NAT_MANIP_SRC)
 		portptr = &tuple->src.u.all;
@@ -81,6 +97,8 @@ bool nf_nat_proto_unique_tuple(struct nf
 	else
 		off = *rover;
 
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)
+if(ct->master || (ct->status & IPS_EXPECTED)){
 	for (i = 0; i < range_size; i++, off++) {
 		*portptr = htons(min + off % range_size);
 		if (nf_nat_used_tuple(tuple, ct))
@@ -89,6 +107,97 @@ bool nf_nat_proto_unique_tuple(struct nf
 			*rover = off;
 		return true;
 	}
+}else
+{
+	for (i = 0; i < range_size; i++) {
+		if((gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC))
+		{
+			rtl865x_optimizeExtPort(off++, range_size, &newOff);
+			*portptr = htons(min + newOff % range_size);
+		}
+		else
+		{
+			*portptr = htons(min + off % range_size);
+			off++;
+		}
+
+		if (nf_nat_used_tuple(tuple, ct))
+			continue;
+
+		if((gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC))
+		{
+			/* outbound flow */
+			rtl865xNaptEntry.protocol = (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum==IPPROTO_TCP)? 1: 0;
+			rtl865xNaptEntry.intIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+			rtl865xNaptEntry.remIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+			rtl865xNaptEntry.extIp = tuple->src.u3.ip;
+			rtl865xNaptEntry.intPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+			rtl865xNaptEntry.remPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.udp.port;
+			rtl865xNaptEntry.extPort= rtl865xNaptEntry.protocol?tuple->src.u.tcp.port:tuple->src.u.udp.port;
+
+			rtl865x_getAsicNaptHashScore(&rtl865xNaptEntry,&asicNaptHashScore);
+
+			if(asicNaptHashScore==100)
+			{
+				highestScore=asicNaptHashScore;
+				lowestScore=asicNaptHashScore;
+				bestCandidatePort=*portptr;
+			}
+			else
+			{
+				/*otherwise use the best cadidate port*/
+				if(bestCandidatePort==0)
+				{
+					bestCandidatePort=*portptr;
+					highestScore=asicNaptHashScore;
+					lowestScore=asicNaptHashScore;
+				}
+
+				if(asicNaptHashScore>highestScore)
+				{
+					highestScore=asicNaptHashScore;
+					bestCandidatePort=*portptr;
+				}
+
+				if(asicNaptHashScore<lowestScore)
+				{
+					lowestScore=asicNaptHashScore;
+				}
+
+				if(tryCnt++<=MAX_EXTPORT_TRY_CNT)
+				{
+					continue;
+				}
+				else
+				{
+					*portptr=bestCandidatePort;
+				}
+			}
+
+			rtl865xNaptEntry.extPort=*portptr;
+			rtl865x_preReserveConn(&rtl865xNaptEntry);
+		}
+/*
+			printk("%s:%d:maniptype is %d, %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) ,lowestScore is %d,highestScore is %d\n\n\n",
+			__FUNCTION__,__LINE__,maniptype, rtl865xNaptEntry.protocol?"tcp":"udp",
+			NIPQUAD(rtl865xNaptEntry.intIp), rtl865xNaptEntry.intPort, NIPQUAD(rtl865xNaptEntry.extIp), rtl865xNaptEntry.extPort, NIPQUAD(rtl865xNaptEntry.remIp), rtl865xNaptEntry.remPort,lowestScore, highestScore);
+*/
+
+		if (!(range->flags & IP_NAT_RANGE_PROTO_RANDOM))
+			*rover = off;
+		return true;
+	}
+}
+#else
+	for (i = 0; i < range_size; i++, off++) {
+		*portptr = htons(min + off % range_size);
+		if (nf_nat_used_tuple(tuple, ct))
+			continue;
+		if (!(range->flags & IP_NAT_RANGE_PROTO_RANDOM))
+			*rover = off;
+		return true;
+	}
+#endif
 	return false;
 }
 EXPORT_SYMBOL_GPL(nf_nat_proto_unique_tuple);
--- linux-2.6.30.9/net/ipv4/raw.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/raw.c	2013-05-02 01:47:59.295226607 +0300
@@ -107,6 +107,51 @@ void raw_unhash_sk(struct sock *sk)
 }
 EXPORT_SYMBOL_GPL(raw_unhash_sk);
 
+
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(char * buf,struct inet_sock * inet);
+extern int dump_sock_skb_info(char * buf,struct sock * sk);
+
+int dumpRawSockInfo(char * buf)
+{
+	unsigned long flags;
+	int hash;
+	struct hlist_head *head;
+	struct sock *sk;
+	struct hlist_node *node;
+	int len=0;
+
+	if(buf==NULL)
+	{
+		return 0;
+	}
+		
+	for(hash=0;hash<RAW_HTABLE_SIZE; hash++)
+	{
+		read_lock(&raw_v4_hashinfo.lock);
+		head = &raw_v4_hashinfo.ht[hash];
+		if (hlist_empty(head))
+			goto out;
+		local_irq_save( flags);
+		for(sk = __sk_head(head);sk!=NULL;sk=sk_next(sk))
+		 {	
+			len+=sprintf(buf+len,"raw sock,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			len+=dump_inet_sock(buf+len,inet_sk(sk));
+			len+=dump_sock_skb_info(buf+len,sk);
+			len+=sprintf(buf+len,"--------------------------------------------------------------------------------------------\n");	
+			
+		}
+		local_irq_restore( flags);
+	out:
+		read_unlock(&raw_v4_hashinfo.lock);
+
+	}
+
+	return len;
+
+}
+
+#endif
 static struct sock *__raw_v4_lookup(struct net *net, struct sock *sk,
 		unsigned short num, __be32 raddr, __be32 laddr, int dif)
 {
@@ -114,13 +159,24 @@ static struct sock *__raw_v4_lookup(stru
 
 	sk_for_each_from(sk, node) {
 		struct inet_sock *inet = inet_sk(sk);
-
+		#if defined (CONFIG_RTL_819X)
+		if(num==47)
+		{
+			if (net_eq(sock_net(sk), net) && inet->num == num	&&
+			    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
+			    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
+				goto found; /* gotcha */
+		}
+		else
+		#endif
+		{
 		if (net_eq(sock_net(sk), net) && inet->num == num	&&
 		    !(inet->daddr && inet->daddr != raddr) 		&&
 		    !(inet->rcv_saddr && inet->rcv_saddr != laddr)	&&
 		    !(sk->sk_bound_dev_if && sk->sk_bound_dev_if != dif))
 			goto found; /* gotcha */
 	}
+	}
 	sk = NULL;
 found:
 	return sk;
--- linux-2.6.30.9/net/ipv4/route.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/route.c	2013-05-02 01:47:59.296226607 +0300
@@ -113,11 +113,15 @@
 
 #define IP_MAX_MTU	0xFFF0
 
-#define RT_GC_TIMEOUT (300*HZ)
+//#define RT_GC_TIMEOUT (300*HZ)
+#define RT_GC_TIMEOUT (60*HZ)
+
+//static int ip_rt_max_size;
+int ip_rt_max_size;
 
-static int ip_rt_max_size;
 static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
-static int ip_rt_gc_interval __read_mostly	= 60 * HZ;
+//static int ip_rt_gc_interval __read_mostly	= 60 * HZ;
+static int ip_rt_gc_interval __read_mostly	= 12 * HZ;
 static int ip_rt_gc_min_interval __read_mostly	= HZ / 2;
 static int ip_rt_redirect_number __read_mostly	= 9;
 static int ip_rt_redirect_load __read_mostly	= HZ / 50;
@@ -129,7 +133,8 @@ static int ip_rt_mtu_expires __read_most
 static int ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;
 static int ip_rt_min_advmss __read_mostly	= 256;
 static int ip_rt_secret_interval __read_mostly	= 10 * 60 * HZ;
-static int rt_chain_length_max __read_mostly	= 20;
+//static int rt_chain_length_max __read_mostly	= 20;
+static int rt_chain_length_max __read_mostly	= 128;
 
 static void rt_worker_func(struct work_struct *work);
 static DECLARE_DELAYED_WORK(expires_work, rt_worker_func);
@@ -639,7 +644,10 @@ static int rt_may_expire(struct rtable *
 	int ret = 0;
 
 	if (atomic_read(&rth->u.dst.__refcnt))
+	{
+		//printk("---%s(%d),src(0x%x),dst(0x%x),refcnt(%d)\n",__FUNCTION__,__LINE__,rth->fl.fl4_src,rth->fl.fl4_dst,rth->u.dst.__refcnt);
 		goto out;
+	}
 
 	ret = 1;
 	if (rth->u.dst.expires &&
@@ -929,6 +937,66 @@ static void rt_emergency_hash_rebuild(st
 	rt_secret_rebuild_oneshot(net);
 }
 
+//hyking:dst garbage collect for memory size issue
+#if  0 //defined(CONFIG_RTL_819X)
+extern struct dst_gc dst_garbage;
+static inline void rt_cache_clean(int count) 
+{
+      struct dst_entry * dst, **dstp;
+	 struct rtable *rt;
+	int refcnt_gc,colcnt_gc;
+	refcnt_gc = colcnt_gc = 0;
+	spin_lock_bh(&dst_garbage.lock);
+      if(dst_garbage.list != NULL){
+		dstp = &dst_garbage.list;
+		while ((dst = *dstp) != NULL) {
+			*dstp = dst->next;
+			if(atomic_read(&dst->__refcnt))
+			{
+				refcnt_gc++;
+				rt = (struct rtable*)dst;
+				if(net_ratelimit())
+					printk("------%s(%d),dst refcnt(%d),sip(%u.%u.%u.%u),dip(%u.%u.%u.%u)\n",__FUNCTION__,__LINE__,atomic_read(&dst->__refcnt),
+					NIPQUAD(rt->rt_src),NIPQUAD(rt->rt_dst));
+			}
+			else
+			{
+				colcnt_gc++;
+				dst_destroy(dst);
+			}
+		}
+	}
+	spin_unlock_bh(&dst_garbage.lock);
+	if(net_ratelimit())
+		printk("--------%s(%d),refcnt(%d),collcnt(%d),dst cache(%d)\n",__FUNCTION__,__LINE__,refcnt_gc,colcnt_gc,atomic_read(&ipv4_dst_ops.entries));
+}
+static void rtl_cache_count(void)
+{
+	  struct dst_entry * dst, **dstp;
+	int refcnt_gc,colcnt_gc;
+
+	refcnt_gc = colcnt_gc = 0;	
+	spin_lock_bh(&dst_garbage.lock);
+	  if(dst_garbage.list != NULL){
+		dstp = &dst_garbage.list;
+		while ((dst = *dstp) != NULL) 
+		{
+			*dstp = dst->next;			
+			if(atomic_read(&dst->__refcnt))
+			{
+				refcnt_gc++;			
+			}
+			else
+			{
+				colcnt_gc++;
+			}
+		}
+	}
+	spin_unlock_bh(&dst_garbage.lock);
+	printk("--------%s(%d),refcnt(%d),collcnt(%d),dst cache(%d)\n",__FUNCTION__,__LINE__,refcnt_gc,colcnt_gc,atomic_read(&ipv4_dst_ops.entries));
+}
+#endif
+
 /*
    Short description of GC goals.
 
@@ -941,13 +1009,14 @@ static void rt_emergency_hash_rebuild(st
    is idle expires is large enough to keep enough of warm entries,
    and when load increases it reduces to limit cache size.
  */
+//extern void dst_gc_task(struct work_struct *work);
 
 static int rt_garbage_collect(struct dst_ops *ops)
 {
 	static unsigned long expire = RT_GC_TIMEOUT;
-	static unsigned long last_gc;
-	static int rover;
-	static int equilibrium;
+	static unsigned long last_gc = 0;
+	static int rover = 0;
+	static int equilibrium = 0;
 	struct rtable *rth, **rthp;
 	unsigned long now = jiffies;
 	int goal;
@@ -966,6 +1035,7 @@ static int rt_garbage_collect(struct dst
 	}
 
 	/* Calculate number of entries, which we want to expire now. */
+	//hyking:entries - 1 << 10
 	goal = atomic_read(&ipv4_dst_ops.entries) -
 		(ip_rt_gc_elasticity << rt_hash_log);
 	if (goal <= 0) {
@@ -1041,14 +1111,37 @@ static int rt_garbage_collect(struct dst
 				atomic_read(&ipv4_dst_ops.entries), goal, i);
 #endif
 
+		if (atomic_read(&ipv4_dst_ops.entries) < (ip_rt_max_size))
+			goto out;
+#if 0 //defined(CONFIG_RTL_819X)
+		else
+		{
+			rt_cache_clean(ip_rt_max_size);
 		if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
 			goto out;
+		}
+#endif
 	} while (!in_softirq() && time_before_eq(jiffies, now));
 
 	if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
 		goto out;
+#if 0 //defined(CONFIG_RTL_819X)
+	else
+	{
+		rt_cache_clean(ip_rt_max_size);
+		if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
+			goto out;
+	}
+#endif
+
 	if (net_ratelimit())
+	{
+#if 0 //defined(CONFIG_RTL_819X)
+		rt_cache_clean(ip_rt_max_size);
+#endif
 		printk(KERN_WARNING "dst cache overflow\n");
+	}
+	
 	RT_CACHE_STAT_INC(gc_dst_overflow);
 	return 1;
 
@@ -2169,6 +2262,7 @@ brd_input:
 	RT_CACHE_STAT_INC(in_brd);
 
 local_input:
+//printk("=========%s(%d) ip_rt_max_size(%d),gc_thresh(%d),rt_hash_mask(%d)\n",__FUNCTION__,__LINE__,ip_rt_max_size,ipv4_dst_ops.gc_thresh,rt_hash_mask);
 	rth = dst_alloc(&ipv4_dst_ops);
 	if (!rth)
 		goto e_nobufs;
@@ -2244,6 +2338,50 @@ martian_source:
 	goto e_inval;
 }
 
+#if 0 //defined(CONFIG_RTL_819X)
+int ip_route_input_fast(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+		   u8 tos, struct net_device *dev)
+{
+	struct rtable * rth;
+	unsigned	hash;
+	int iif = dev->ifindex;
+	struct net *net;
+
+	net = dev_net(dev);
+
+	if (!rt_caching(net))
+		goto skip_cache;
+
+	tos &= IPTOS_RT_MASK;
+	hash = rt_hash(daddr, saddr, iif, rt_genid(net));
+
+	rcu_read_lock();
+	for (rth = rcu_dereference(rt_hash_table[hash].chain); rth;
+	     rth = rcu_dereference(rth->u.dst.rt_next)) {
+		if (((rth->fl.fl4_dst ^ daddr) |
+		     (rth->fl.fl4_src ^ saddr) |
+		     (rth->fl.iif ^ iif) |
+		     rth->fl.oif |
+		     (rth->fl.fl4_tos ^ tos)) == 0 &&
+		    rth->fl.mark == skb->mark &&
+		    net_eq(dev_net(rth->u.dst.dev), net) &&
+		    !rt_is_expired(rth)) {
+			dst_use(&rth->u.dst, jiffies);
+			RT_CACHE_STAT_INC(in_hit);
+			rcu_read_unlock();
+			skb->rtable = rth;
+			return 0;
+		}
+		RT_CACHE_STAT_INC(in_hlist_search);
+	}
+	rcu_read_unlock();
+
+skip_cache:
+	return -EINVAL;
+	
+}
+#endif
+
 int ip_route_input(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		   u8 tos, struct net_device *dev)
 {
@@ -2300,6 +2438,12 @@ skip_cache:
 		if ((in_dev = __in_dev_get_rcu(dev)) != NULL) {
 			int our = ip_check_mc(in_dev, daddr, saddr,
 				ip_hdr(skb)->protocol);
+#if defined (CONFIG_RTL_IGMP_PROXY) && defined (CONFIG_IP_MROUTE)
+			if(net->ipv4.mroute_sk)
+			{
+				our = 1;
+			}
+#endif
 			if (our
 #ifdef CONFIG_IP_MROUTE
 			    || (!ipv4_is_local_multicast(daddr) &&
@@ -3022,6 +3166,45 @@ void ip_rt_multicast_event(struct in_dev
 	rt_cache_flush(dev_net(in_dev->dev), 0);
 }
 
+#if 0
+int ipv4_dump_all_dst_cache(void)
+{
+	struct rtable *rth;
+	int hash;
+	int cnt;
+	//unsigned long flags;	
+	
+
+	cnt = 0;
+	//local_irq_save(flags);
+	for (hash = 0; hash <= rt_hash_mask; hash++)
+	{
+		if (!rt_hash_table[hash].chain)
+			continue;
+		
+		//printk("genid(%d),hash chain[%d]:\n",rt_genid(&init_net) ,hash);
+		//rcu_read_lock();
+		for (rth = (rt_hash_table[hash].chain); rth;
+			rth = (rth->u.dst.rt_next)) 
+		{
+			cnt++;
+			#if 0
+			printk("sip(%u.%u.%u.%u),dip(%u.%u.%u.%u),rt_genid(%d),dst->ops(0x%x),dst->hy1(0x%x),dst->refcnt(%d)\n",NIPQUAD(rth->rt_src),NIPQUAD(rth->rt_dst),rth->rt_genid,
+				rth->u.dst.ops,rth->u.dst.hyking_test1,atomic_read(&rth->u.dst.__refcnt));
+			
+			(*((volatile unsigned int *)(0xb800311c))) = 0x00e00000;
+			#endif
+		}
+		//rcu_read_unlock();
+	}
+
+	printk("total cnt = %d,ipv4_dst_ops.entries(%d),genid(%d)\n",cnt,atomic_read(&ipv4_dst_ops.entries),rt_genid(&init_net));
+	//local_irq_restore(flags);
+
+	rtl_cache_count();
+	return 0;
+}
+#endif
 #ifdef CONFIG_SYSCTL
 static int ipv4_sysctl_rtcache_flush(ctl_table *__ctl, int write,
 					struct file *filp, void __user *buffer,
--- linux-2.6.30.9/net/ipv4/tcp_ipv4.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/tcp_ipv4.c	2013-05-02 01:47:59.303226607 +0300
@@ -488,10 +488,17 @@ void tcp_v4_send_check(struct sock *sk,
 		skb->csum_start = skb_transport_header(skb) - skb->head;
 		skb->csum_offset = offsetof(struct tcphdr, check);
 	} else {
+		//Hyking:fixme
+		//it's seem that the skb->csum is wrong
+		//fix it after....
+		#if 0
 		th->check = tcp_v4_check(len, inet->saddr, inet->daddr,
 					 csum_partial(th,
 						      th->doff << 2,
 						      skb->csum));
+		#endif		
+		__wsum tmp = csum_partial(th,len,0);
+		th->check = tcp_v4_check(len, inet->saddr, inet->daddr,tmp);		
 	}
 }
 
@@ -1518,6 +1525,78 @@ csum_err:
 	goto discard;
 }
 
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(char * buf,struct inet_sock * inet);
+extern int  dump_inet_timewait_sock(char * buf,struct inet_timewait_sock * inet_tw);
+extern int dump_sock_skb_info(char * buf,struct sock * sk);
+int dumpTcpSockInfo(char *buf)
+{
+	unsigned long flags;
+	struct sock *sk;
+	const struct hlist_nulls_node *node;
+	unsigned int hash ;
+	struct udp_hslot *hslot;
+	struct sk_buff *list=NULL;
+	struct inet_listen_hashbucket *ilb;
+	struct inet_ehash_bucket *head=NULL;
+	unsigned int slot;
+	int len=0;
+	
+	if(buf==NULL)
+	{
+		return 0;
+	}
+	
+	for(hash=0; hash <INET_LHTABLE_SIZE; hash++)
+	{
+	
+		ilb = &tcp_hashinfo.listening_hash[hash];
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &ilb->head) {
+			len+=sprintf(buf+len,"tcp listener socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			len+=dump_inet_sock(buf+len,inet_sk(sk));
+			len+=dump_sock_skb_info(buf+len,sk);
+			len+=sprintf(buf+len,"--------------------------------------------------------------------------------------------\n");	
+		}
+		
+		local_irq_restore( flags);
+
+	}
+
+	//printk("%s:%d,tcp_hashinfo.ehash_size is %d\n",__FUNCTION__,__LINE__,tcp_hashinfo.ehash_size);
+	for(slot=0; slot <tcp_hashinfo.ehash_size; slot++)
+	{
+	
+		head = &tcp_hashinfo.ehash[slot];
+		
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &head->chain) {
+			
+			len+=sprintf(buf+len,"tcp established socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			len+=dump_inet_sock(buf+len,inet_sk(sk));
+			len+=dump_sock_skb_info(buf+len,sk);
+			len+=sprintf(buf+len,"--------------------------------------------------------------------------------------------\n");	
+		
+		}
+	
+		sk_nulls_for_each_rcu(sk, node, &head->twchain) {
+			
+			len+=sprintf(buf+len,"tcp time-wait socket socket,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			len+=dump_inet_timewait_sock(buf+len,inet_twsk(sk));
+			len+=dump_sock_skb_info(buf+len,sk);
+			len+=sprintf(buf+len,"--------------------------------------------------------------------------------------------\n");	
+		
+
+		}
+		local_irq_restore( flags);
+		
+
+	}
+	
+	return len;
+	
+}
+#endif
 /*
  *	From tcp_input.c
  */
--- linux-2.6.30.9/net/ipv4/udp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv4/udp.c	2013-05-02 01:47:59.307226606 +0300
@@ -93,6 +93,7 @@
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <linux/mm.h>
+#include <linux/config.h>
 #include <linux/inet.h>
 #include <linux/netdevice.h>
 #include <net/tcp_states.h>
@@ -103,6 +104,10 @@
 #include <net/icmp.h>
 #include <net/route.h>
 #include <net/checksum.h>
+#ifdef CONFIG_RTK_VOIP_MODULE
+#include <linux/module.h>
+#define CONFIG_RTK_VOIP
+#endif
 #include <net/xfrm.h>
 #include "udp_impl.h"
 
@@ -122,6 +127,21 @@ EXPORT_SYMBOL(udp_memory_allocated);
 
 #define PORTS_PER_CHAIN (65536 / UDP_HTABLE_SIZE)
 
+#ifdef CONFIG_RTK_VOIP
+void **udp_rtk_trap_profile_header = NULL;
+int (*udp_rtk_trap_hook)(struct sk_buff *skb) = NULL;
+#endif
+
+#ifdef CONFIG_RTK_VOIP_MODULE
+extern unsigned long __nat_speedup_start;
+extern unsigned long __imem_start;
+EXPORT_SYMBOL(__nat_speedup_start);
+EXPORT_SYMBOL(__imem_start);
+EXPORT_SYMBOL(udp_rtk_trap_profile_header);
+EXPORT_SYMBOL(udp_rtk_trap_hook);
+#endif
+
+
 static int udp_lib_lport_inuse(struct net *net, __u16 num,
 			       const struct udp_hslot *hslot,
 			       unsigned long *bitmap,
@@ -1142,7 +1162,45 @@ drop:
 	kfree_skb(skb);
 	return -1;
 }
+#if defined (CONFIG_RTL_SOCK_DEBUG)
+extern int dump_inet_sock(char * buf,struct inet_sock * inet);
+extern int dump_sock_skb_info(char * buf,struct sock * sk);
+int dumpUdpSockInfo(char *buf)
+{
+	unsigned long flags;
+	struct sock *sk;
+	struct hlist_nulls_node *node;
+	unsigned int hash ;
+	struct udp_hslot *hslot;
+	struct inet_sock *inet;
+	int len=0;
+
+	if(buf==NULL)
+	{
+		return 0;
+	}
+	
+	rcu_read_lock();
+	for(hash=0;hash<UDP_HTABLE_SIZE;hash++)
+	{
+		hslot = &udp_table.hash[hash];
+		local_irq_save( flags);
+		sk_nulls_for_each_rcu(sk, node, &hslot->head)
+		{	
+			len+=sprintf(buf+len,"udp sock,hash:%d,sk is 0x%x,\n",hash,(unsigned int)sk);	
+			len+=dump_inet_sock(buf+len,inet_sk(sk));
+			len+=dump_sock_skb_info(buf+len,sk);
+			len+=sprintf(buf+len,"--------------------------------------------------------------------------------------------\n");		
+		}
+		local_irq_restore( flags);
+	}
+	rcu_read_unlock();
+	
+	return len;
+	
+}
 
+#endif
 /*
  *	Multicasts and broadcasts go to each listener.
  *
@@ -1265,6 +1323,16 @@ int __udp4_lib_rcv(struct sk_buff *skb,
 	saddr = ip_hdr(skb)->saddr;
 	daddr = ip_hdr(skb)->daddr;
 
+#ifdef CONFIG_RTK_VOIP
+	if( udp_rtk_trap_profile_header != NULL 
+	    && *udp_rtk_trap_profile_header != NULL 
+	    && udp_rtk_trap_hook != NULL)
+       	{
+   		if ( udp_rtk_trap_hook(skb) == 0)
+			return 0;
+       	}
+#endif
+
 	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
 		return __udp4_lib_mcast_deliver(net, skb, uh,
 				saddr, daddr, udptable);
--- linux-2.6.30.9/net/ipv6/addrconf.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/addrconf.c	2013-05-02 01:47:59.313226606 +0300
@@ -185,8 +185,16 @@ static struct ipv6_devconf ipv6_devconf
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_MROUTE
+	.mc_forwarding		= 1,
+#endif
 	.disable_ipv6		= 0,
+#ifdef CONFIG_RTL_IPV6READYLOGO
+	.accept_dad			= 2,
+#else
 	.accept_dad		= 1,
+#endif
+
 };
 
 static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {
@@ -219,8 +227,16 @@ static struct ipv6_devconf ipv6_devconf_
 #endif
 	.proxy_ndp		= 0,
 	.accept_source_route	= 0,	/* we do not accept RH0 by default. */
+#ifdef CONFIG_IPV6_MROUTE
+	.mc_forwarding		= 1,
+#endif
 	.disable_ipv6		= 0,
+#ifdef CONFIG_RTL_IPV6READYLOGO
+	.accept_dad			= 2,
+#else
 	.accept_dad		= 1,
+#endif
+
 };
 
 /* IPv6 Wildcard Address and Loopback Address defined by RFC2553 */
@@ -2325,6 +2341,17 @@ static void addrconf_dev_config(struct n
 		return;
 	}
 
+#if defined(CONFIG_RTL_IPV6READYLOGO)
+		/*We only add link local address on br0 for LAN and eth1 for WAN*/
+		if(strcmp(dev->name,"eth1")){
+        	if(!strncmp(dev->name,"eth",strlen("eth")))
+                return;
+				
+       		if(!strncmp(dev->name,"wlan",strlen("wlan")))
+                return;
+		}
+#endif
+
 	idev = addrconf_add_dev(dev);
 	if (idev == NULL)
 		return;
@@ -2786,6 +2813,27 @@ static void addrconf_dad_start(struct in
 out:
 	read_unlock_bh(&idev->lock);
 }
+#if defined(CONFIG_RTL_IPV6READYLOGO)
+#include <bridge/br_private.h>
+static int delay_flag=0;
+int check_lan_port_state(struct net_device *dev)
+{
+	struct net_device *sdev;
+	if(!(dev->br_port ) ) 
+	{
+		struct net *net = dev_net(dev);		
+		for_each_netdev(net, sdev)
+		{
+			if((sdev->br_port) && (!memcmp(sdev->name,"eth",3)))
+			{
+				if(!sdev->br_port) return 0;
+				return sdev->br_port->state;
+			}
+			continue;
+		}	        	
+	}
+	return 0;
+}
 
 static void addrconf_dad_timer(unsigned long data)
 {
@@ -2799,6 +2847,69 @@ static void addrconf_dad_timer(unsigned
 		goto out;
 	}
 	spin_lock_bh(&ifp->lock);
+	
+	if(check_lan_port_state(idev->dev) != BR_STATE_FORWARDING)
+	{
+		if(!ifp->probes) ifp->probes=1;
+	}
+	else 
+	{
+		if(!delay_flag) 
+		{
+			if(!ifp->probes) ifp->probes=1;
+			delay_flag=1;
+		}
+	}   	
+	if (ifp->probes == 0) {
+		/*
+		 * DAD was successful
+		 */
+
+		ifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC);
+		spin_unlock_bh(&ifp->lock);
+		read_unlock_bh(&idev->lock);
+
+		addrconf_dad_completed(ifp);
+
+		goto out;
+	}
+	else
+	{
+		
+		/* send a neighbour solicitation for our addr */		
+		if(delay_flag)
+		{
+			ifp->probes--;
+			addrconf_mod_timer(ifp, AC_DAD, 50);
+			spin_unlock_bh(&ifp->lock);
+			read_unlock_bh(&idev->lock);
+			addrconf_addr_solict_mult(&ifp->addr, &mcaddr);
+			ndisc_send_ns(ifp->idev->dev, NULL, &ifp->addr, &mcaddr, &in6addr_any);
+		}
+		else
+		{
+			ifp->probes--;
+			addrconf_mod_timer(ifp, AC_DAD, ifp->idev->nd_parms->retrans_time);
+			spin_unlock_bh(&ifp->lock);
+			read_unlock_bh(&idev->lock);
+		}
+	}
+out:
+	in6_ifa_put(ifp);
+}
+#else
+static void addrconf_dad_timer(unsigned long data)
+{
+	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *) data;
+	struct inet6_dev *idev = ifp->idev;
+	struct in6_addr mcaddr;
+
+	read_lock_bh(&idev->lock);
+	if (idev->dead) {
+		read_unlock_bh(&idev->lock);
+		goto out;
+	}
+	spin_lock_bh(&ifp->lock);
 	if (ifp->probes == 0) {
 		/*
 		 * DAD was successful
@@ -2824,7 +2935,7 @@ static void addrconf_dad_timer(unsigned
 out:
 	in6_ifa_put(ifp);
 }
-
+#endif
 static void addrconf_dad_completed(struct inet6_ifaddr *ifp)
 {
 	struct net_device *	dev = ifp->idev->dev;
@@ -4213,7 +4324,7 @@ static struct addrconf_sysctl_table
 			.procname	=	"mc_forwarding",
 			.data		=	&ipv6_devconf.mc_forwarding,
 			.maxlen		=	sizeof(int),
-			.mode		=	0444,
+			.mode		=	0644,
 			.proc_handler	=	proc_dointvec,
 		},
 #endif
--- linux-2.6.30.9/net/ipv6/af_inet6.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/af_inet6.c	2013-05-02 01:47:59.314226606 +0300
@@ -294,10 +294,8 @@ int inet6_bind(struct socket *sock, stru
 		    v4addr != htonl(INADDR_ANY) &&
 		    chk_addr_ret != RTN_LOCAL &&
 		    chk_addr_ret != RTN_MULTICAST &&
-		    chk_addr_ret != RTN_BROADCAST) {
-			err = -EADDRNOTAVAIL;
+		    chk_addr_ret != RTN_BROADCAST)
 			goto out;
-		}
 	} else {
 		if (addr_type != IPV6_ADDR_ANY) {
 			struct net_device *dev = NULL;
--- linux-2.6.30.9/net/ipv6/datagram.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/datagram.c	2013-05-02 01:47:59.315226606 +0300
@@ -398,6 +398,16 @@ int datagram_recv_ctl(struct sock *sk, s
 		put_cmsg(msg, SOL_IPV6, IPV6_PKTINFO, sizeof(src_info), &src_info);
 	}
 
+#ifdef	CONFIG_RTL_IPV6READYLOGO
+	if (np->rxopt.bits.srcaddr) {
+		struct in6_pktinfo src_info;
+
+		src_info.ipi6_ifindex = opt->iif;
+		ipv6_addr_copy(&src_info.ipi6_addr, &ipv6_hdr(skb)->saddr);
+		put_cmsg(msg, SOL_IPV6, IPV6_SRC_ADDR, sizeof(src_info), &src_info);
+	}
+#endif
+
 	if (np->rxopt.bits.rxhlim) {
 		int hlim = ipv6_hdr(skb)->hop_limit;
 		put_cmsg(msg, SOL_IPV6, IPV6_HOPLIMIT, sizeof(hlim), &hlim);
--- linux-2.6.30.9/net/ipv6/exthdrs.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/exthdrs.c	2013-05-02 01:47:59.316226606 +0300
@@ -378,6 +378,20 @@ looped_back:
 	}
 
 	switch (hdr->type) {
+		/*deprecate RH0 by RFC5095 because of security problem*/
+#if 0//defined(CONFIG_RTL_IPV6READYLOGO)	
+		case IPV6_SRCRT_TYPE_0:
+		//printk("[%s][%d]-[%p][offset=%x]\n", __FUNCTION__, __LINE__, (&hdr->nexthdr), (&hdr->nexthdr) - skb_network_header(skb));
+		if (hdr->hdrlen & 0x01) {
+			IP6_INC_STATS_BH(net, ip6_dst_idev(skb->dst),
+					 IPSTATS_MIB_INHDRERRORS);
+			//icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, (&hdr->hdrlen) - skb->nh.raw);
+			icmpv6_param_prob(skb, ICMPV6_HDR_FIELD,
+			(&hdr->nexthdr) - skb_network_header(skb)+1);
+			return -1;
+		}
+		break;
+#endif		
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 	case IPV6_SRCRT_TYPE_2:
 		if (accept_source_route < 0)
--- linux-2.6.30.9/net/ipv6/ip6_input.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/ip6_input.c	2013-05-02 01:47:59.324226605 +0300
@@ -139,9 +139,6 @@ int ipv6_rcv(struct sk_buff *skb, struct
 
 	rcu_read_unlock();
 
-	/* Must drop socket now because of tproxy. */
-	skb_orphan(skb);
-
 	return NF_HOOK(PF_INET6, NF_INET_PRE_ROUTING, skb, dev, NULL,
 		       ip6_rcv_finish);
 err:
--- linux-2.6.30.9/net/ipv6/ip6mr.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/ip6mr.c	2013-05-02 01:47:59.326226605 +0300
@@ -62,6 +62,22 @@ static DEFINE_RWLOCK(mrt_lock);
 
 #define MIF_EXISTS(_net, _idx) ((_net)->ipv6.vif6_table[_idx].dev != NULL)
 
+/*IPV6 READY LOGO phase 2*/
+#define IPV6_READY_LOGO 1
+
+#if defined	IPV6_READY_LOGO
+#define IN6_IS_ADDR_MULTICAST(a) (((__const uint8_t *) (a))[0] == 0xff)
+	
+#define IN6_IS_ADDR_MC_LINKLOCAL(a) \
+		(IN6_IS_ADDR_MULTICAST(a)						  \
+		 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x2))
+		 
+#define	IN6_IS_ADDR_RESVER_0(a) \
+		(IN6_IS_ADDR_MULTICAST(a)						  \
+		 && ((((__const uint8_t *) (a))[1] & 0xf) == 0x0))
+#endif
+
+
 static struct mfc6_cache *mfc_unres_queue;		/* Queue of unresolved entries */
 
 /* Special spinlock for queue of unresolved entries */
@@ -1650,11 +1666,56 @@ int ip6_mr_input(struct sk_buff *skb)
 {
 	struct mfc6_cache *cache;
 	struct net *net = dev_net(skb->dev);
+#if defined (CONFIG_RTL_MLD_PROXY)
+	int vif_index;
+	struct in6_addr origin_tmp;
+	struct net_device *dev=skb->dev;
+#endif
+	
+#if defined IPV6_READY_LOGO
+	struct ipv6hdr *ipv6h=ipv6_hdr(skb);
+	//multicast link local address
+	if ( IN6_IS_ADDR_MC_LINKLOCAL(&ipv6_hdr(skb)->daddr)){
+		/*
+		printk("IN6_IS_ADDR_MC_LINKLOCAL!![%s]:[%d].\n",__FUNCTION__,__LINE__);
+		printk("ipv6h->daddr is 0x%x-%x-%x-%x\n",
+		ipv6h->daddr.s6_addr32[0],ipv6h->daddr.s6_addr32[1],ipv6h->daddr.s6_addr32[2],ipv6h->daddr.s6_addr32[3]);
+		*/
+		return 0;
+	}
+	//reserver area is set to zero
+	if (IN6_IS_ADDR_RESVER_0(&ipv6_hdr(skb)->daddr)){
+		/*
+		printk("IN6_IS_ADDR_RESVER_0!![%s]:[%d].\n",__FUNCTION__,__LINE__);
+		printk("ipv6h->daddr is 0x%x-%x-%x-%x\n",
+		ipv6h->daddr.s6_addr32[0],ipv6h->daddr.s6_addr32[1],ipv6h->daddr.s6_addr32[2],ipv6h->daddr.s6_addr32[3]);
+		*/
+		return 0;
+	}
+		
+#endif
 
 	read_lock(&mrt_lock);
+#if defined (CONFIG_RTL_MLD_PROXY)
+	cache=NULL;
+	vif_index=ip6mr_find_vif(dev);
+	memset(&origin_tmp,0,sizeof(struct in6_addr));
+	origin_tmp.s6_addr[15]=(__u8)vif_index;
+	/*
+	if(net_ratelimit())
+	printk("origin_tmp is 0x%x-%x-%x-%x\n",
+		origin_tmp.s6_addr32[0],origin_tmp.s6_addr32[1],origin_tmp.s6_addr32[2],origin_tmp.s6_addr32[3]);
+	*/
 	cache = ip6mr_cache_find(net,
 				 &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);
+	if (cache==NULL)
+		cache = ip6mr_cache_find(net,
+					 &origin_tmp, &ipv6_hdr(skb)->daddr);
+#else
 
+	cache = ip6mr_cache_find(net,
+				 &ipv6_hdr(skb)->saddr, &ipv6_hdr(skb)->daddr);
+#endif
 	/*
 	 *	No usable cache entry
 	 */
--- linux-2.6.30.9/net/ipv6/ipv6_sockglue.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/ipv6_sockglue.c	2013-05-02 01:47:59.327226605 +0300
@@ -247,6 +247,15 @@ static int do_ipv6_setsockopt(struct soc
 		retv = 0;
 		break;
 
+#ifdef	CONFIG_RTL_IPV6READYLOGO
+	case IPV6_SRC_ADDR:
+		if (optlen < sizeof(int))
+			goto e_inval;
+		np->rxopt.bits.srcaddr = valbool;
+		retv = 0;
+		break;
+#endif
+
 	case IPV6_2292PKTINFO:
 		if (optlen < sizeof(int))
 			goto e_inval;
@@ -983,6 +992,12 @@ static int do_ipv6_getsockopt(struct soc
 		val = np->rxopt.bits.rxinfo;
 		break;
 
+#ifdef CONFIG_RTL_IPV6READYLOGO
+	case IPV6_SRC_ADDR:
+		val = np->rxopt.bits.srcaddr;
+		break;
+#endif
+
 	case IPV6_2292PKTINFO:
 		val = np->rxopt.bits.rxoinfo;
 		break;
--- linux-2.6.30.9/net/ipv6/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/Kconfig	2013-05-02 01:47:59.310226606 +0300
@@ -20,7 +20,9 @@ menuconfig IPV6
 	  module will be called ipv6.
 
 if IPV6
-
+config RTL_IPV6READYLOGO 
+	bool "IPv6: ready logo patch"
+	default n
 config IPV6_PRIVACY
 	bool "IPv6: Privacy Extensions (RFC 3041) support"
 	---help---
--- linux-2.6.30.9/net/ipv6/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/ipv6/Makefile	2013-05-02 01:47:59.311226606 +0300
@@ -40,3 +40,4 @@ obj-$(CONFIG_IPV6_TUNNEL) += ip6_tunnel.
 obj-y += addrconf_core.o exthdrs_core.o
 
 obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
+EXTRA_CFLAGS += -I $(DIR_LINUX)/net/
--- linux-2.6.30.9/net/mac80211/main.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/mac80211/main.c	2013-05-02 01:47:59.381226600 +0300
@@ -633,7 +633,8 @@ void ieee80211_tx_status(struct ieee8021
 	rthdr = (struct ieee80211_tx_status_rtap_hdr *)
 				skb_push(skb, sizeof(*rthdr));
 
-	memset(rthdr, 0, sizeof(*rthdr));
+        //by brian
+	memset(rthdr, 0, sizeof(*rthdr)-2);
 	rthdr->hdr.it_len = cpu_to_le16(sizeof(*rthdr));
 	rthdr->hdr.it_present =
 		cpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |
--- linux-2.6.30.9/net/mac80211/rx.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/mac80211/rx.c	2013-05-02 01:47:59.387226600 +0300
@@ -1389,7 +1389,8 @@ ieee80211_deliver_skb(struct ieee80211_r
 	if (skb) {
 		int align __maybe_unused;
 
-#if defined(CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT) || !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+//#if defined(CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT) || !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+#if 0
 		/*
 		 * 'align' will only take the values 0 or 2 here
 		 * since all frames are required to be aligned
--- linux-2.6.30.9/net/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/Makefile	2013-05-02 01:47:59.190226616 +0300
@@ -65,3 +65,13 @@ ifeq ($(CONFIG_NET),y)
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
 obj-$(CONFIG_WIMAX)		+= wimax/
+
+ifeq ($(CONFIG_RTL_IPTABLES_FAST_PATH),y)
+obj-$(CONFIG_RTL_IPTABLES_FAST_PATH) += rtl/fastpath/
+endif
+ifeq ($(CONFIG_NET),y)
+ifeq ($(CONFIG_RTL_819X),y)
+obj-$(CONFIG_RTL_819X) += rtl/features/
+endif
+endif
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_conn.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_conn.c	2013-05-02 01:47:59.394226599 +0300
@@ -36,6 +36,10 @@
 #include <net/net_namespace.h>
 #include <net/ip_vs.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 
 /*
  *  Connection hash table: for input and output packets lookups of IPVS
@@ -614,8 +618,15 @@ static void ip_vs_conn_expire(unsigned l
 {
 	struct ip_vs_conn *cp = (struct ip_vs_conn *)data;
 
+
 	cp->timeout = 60*HZ;
 
+	#if defined (CONFIG_RTL_819X)  
+	if(rtl_ip_vs_conn_expire_hooks1(cp)==RTL_PS_HOOKS_RETURN) {
+		return;
+	}
+	#endif
+
 	/*
 	 *	hey, I'm using it
 	 */
@@ -645,6 +656,10 @@ static void ip_vs_conn_expire(unsigned l
 		if (cp->control)
 			ip_vs_control_del(cp);
 
+		#if defined (CONFIG_RTL_819X)  
+		rtl_ip_vs_conn_expire_hooks2(cp);
+		#endif
+
 		if (unlikely(cp->app != NULL))
 			ip_vs_unbind_app(cp);
 		ip_vs_unbind_dest(cp);
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_tcp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_tcp.c	2013-05-02 01:47:59.398226599 +0300
@@ -24,6 +24,9 @@
 
 #include <net/ip_vs.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
 
 static struct ip_vs_conn *
 tcp_conn_in_get(int af, const struct sk_buff *skb, struct ip_vs_protocol *pp,
@@ -582,6 +586,11 @@ tcp_state_transition(struct ip_vs_conn *
 
 	spin_lock(&cp->lock);
 	set_tcp_state(pp, cp, direction, th);
+	
+#if defined (CONFIG_RTL_819X)
+	rtl_tcp_state_transition_hooks(cp, direction, skb, pp);
+#endif
+
 	spin_unlock(&cp->lock);
 
 	return 1;
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_udp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_udp.c	2013-05-02 01:47:59.398226599 +0300
@@ -23,6 +23,10 @@
 #include <net/ip_vs.h>
 #include <net/ip.h>
 #include <net/ip6_checksum.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 
 static struct ip_vs_conn *
 udp_conn_in_get(int af, const struct sk_buff *skb, struct ip_vs_protocol *pp,
@@ -494,7 +498,12 @@ udp_state_transition(struct ip_vs_conn *
 		     const struct sk_buff *skb,
 		     struct ip_vs_protocol *pp)
 {
+
+
 	cp->timeout = pp->timeout_table[IP_VS_UDP_S_NORMAL];
+#if defined (CONFIG_RTL_819X)	
+	rtl_udp_state_transition_hooks(cp, direction, skb, pp);
+#endif
 	return 1;
 }
 
--- linux-2.6.30.9/net/netfilter/ipvs/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/Makefile	2013-05-02 01:47:59.393226599 +0300
@@ -31,3 +31,4 @@ obj-$(CONFIG_IP_VS_NQ) += ip_vs_nq.o
 
 # IPVS application helpers
 obj-$(CONFIG_IP_VS_FTP) += ip_vs_ftp.o
+EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
--- linux-2.6.30.9/net/netfilter/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/Kconfig	2013-05-02 01:47:59.392226599 +0300
@@ -4,6 +4,14 @@ menu "Core Netfilter Configuration"
 config NETFILTER_NETLINK
 	tristate
 
+config RTL_NF_CONNTRACK_GARBAGE_NEW
+	bool "connection tracking garbage"
+	default n
+	help
+	  connection tracking garbage mechanism will release a
+	  connection tracking when not enough memory for create
+	  a new connection tracking.
+
 config NETFILTER_NETLINK_QUEUE
 	tristate "Netfilter NFQUEUE over NFNETLINK interface"
 	depends on NETFILTER_ADVANCED
@@ -212,6 +220,37 @@ config NF_CONNTRACK_NETBIOS_NS
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+#
+# Desc:add ip sec for alg
+#
+config NF_CONNTRACK_IPSEC
+        tristate "IPSEC protocol support"
+        depends on NETFILTER_ADVANCED
+        help
+          This module adds support for IPSEC connection tracking and NAT.
+          To compile it as a module, choose M here. If unsure, say N.
+
+#
+# Desc:add rtsp for alg
+#
+config NF_CONNTRACK_RTSP
+    tristate "RTSP protocol support"
+    depends on NETFILTER_ADVANCED
+    help
+      This module adds support for RTSP connection tracking and NAT.
+      To compile it as a module, choose M here. If unsure, say N.
+
+
+#
+# Desc:add l2tp for alg
+#
+config NF_CONNTRACK_L2TP
+    tristate "L2TP protocol support"
+    depends on NETFILTER_ADVANCED
+    help
+      This module adds support for L2TP connection tracking and NAT.
+      To compile it as a module, choose M here. If unsure, say N.
+
 config NF_CONNTRACK_PPTP
 	tristate "PPtP protocol support"
 	depends on NETFILTER_ADVANCED
@@ -268,6 +307,16 @@ config NF_CONNTRACK_TFTP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config RTL_BATTLENET_ALG
+        tristate "BATTLENET alg support"
+        depends on NETFILTER_ADVANCED
+	default n
+        help
+          TFTP connection tracking helper, this is required depending
+          on how restrictive your ruleset is.
+
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config NF_CT_NETLINK
 	tristate 'Connection tracking netlink interface'
 	select NETFILTER_NETLINK
@@ -626,6 +675,17 @@ config NETFILTER_XT_MATCH_DSCP
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config RTL_DSCP_IPTABLE_CHECK
+        tristate 'dscp iptable check while set IMPROVE_QOS'
+        depends on NETFILTER_XT_MATCH_DSCP
+        help
+          This option adds 'DSCP' check in addNaptConnection while IMPROVE_QOS
+          is enabled, and record the newer 'DSCP' in the conntrack session, so
+          the other packet of the seesion will update 'DSCP' in fastpath too.
+
+          If this option is not sellected, some iptables rule in mangle table for
+          modify 'DSCP' will not work in fastpath while IMPROVE_QOS enabled.
+
 config NETFILTER_XT_MATCH_ESP
 	tristate '"esp" match support'
 	depends on NETFILTER_ADVANCED
@@ -705,6 +765,27 @@ config NETFILTER_XT_MATCH_MAC
 	  Ethernet address of the packet.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+config RTL_MAC_FILTER_CARE_INPORT
+        tristate 'Check in port for "mac" address match support'
+        depends on NETFILTER_XT_MATCH_MAC
+
+config NETFILTER_XT_MATCH_VLAN
+        tristate '"VLAN"  match support'
+        depends on NETFILTER_XTABLES
+        help
+          VLAN matching allows you to match packets based on the VLAN priority
+          of the packet.
+ 
+          To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_PHYPORT
+        tristate '"Physical port"  match support'
+        depends on NETFILTER_XTABLES
+        help
+          Physical port matching allows you to match packets based on the phy port number
+          of the packet.
+ 
+          To compile it as a module, choose M here.  If unsure, say N.
 
 config NETFILTER_XT_MATCH_MARK
 	tristate '"mark" match support'
@@ -858,6 +939,26 @@ config NETFILTER_XT_MATCH_STATE
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_LAYER7
+	tristate '"layer7" match support'
+	depends on NETFILTER_XTABLES
+	depends on EXPERIMENTAL && (IP_NF_CONNTRACK || NF_CONNTRACK)
+	depends on NF_CT_ACCT
+	help
+	  Say Y if you want to be able to classify connections (and their
+	  packets) based on regular expression matching of their applications
+	  layer data.   This is one way to classify applications such as
+	  peer-to-peer filesharing systems that do not always use the same
+	  port.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_LAYER7_DEBUG
+	bool 'Layer 7 debugging output'
+	depends on NETFILTER_XT_MATCH_LAYER7
+	help
+	  Say Y to get lots of debugging output.
+
 config NETFILTER_XT_MATCH_STATISTIC
 	tristate '"statistic" match support'
 	depends on NETFILTER_ADVANCED
--- linux-2.6.30.9/net/netfilter/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/Makefile	2013-05-02 01:47:59.392226599 +0300
@@ -33,7 +33,9 @@ obj-$(CONFIG_NF_CONNTRACK_PPTP) += nf_co
 obj-$(CONFIG_NF_CONNTRACK_SANE) += nf_conntrack_sane.o
 obj-$(CONFIG_NF_CONNTRACK_SIP) += nf_conntrack_sip.o
 obj-$(CONFIG_NF_CONNTRACK_TFTP) += nf_conntrack_tftp.o
-
+obj-$(CONFIG_NF_CONNTRACK_L2TP) += nf_conntrack_l2tp.o
+obj-$(CONFIG_NF_CONNTRACK_RTSP) += nf_conntrack_rtsp.o
+obj-$(CONFIG_NF_CONNTRACK_IPSEC) += nf_conntrack_ipsec.o
 # transparent proxy support
 obj-$(CONFIG_NETFILTER_TPROXY) += nf_tproxy_core.o
 
@@ -88,11 +90,17 @@ obj-$(CONFIG_NETFILTER_XT_MATCH_RECENT)
 obj-$(CONFIG_NETFILTER_XT_MATCH_SCTP) += xt_sctp.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_SOCKET) += xt_socket.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATE) += xt_state.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_LAYER7) += xt_layer7.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STATISTIC) += xt_statistic.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_STRING) += xt_string.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TIME) += xt_time.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_U32) += xt_u32.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_VLAN) += xt_vlanpriority.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PHYPORT) += xt_phyport.o
 
 # IPVS
 obj-$(CONFIG_IP_VS) += ipvs/
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
--- linux-2.6.30.9/net/netfilter/nf_conntrack_core.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_core.c	2013-05-02 01:47:59.402226599 +0300
@@ -30,6 +30,9 @@
 #include <linux/socket.h>
 #include <linux/mm.h>
 #include <linux/rculist_nulls.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
@@ -42,6 +45,11 @@
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+#include <net/rtl/features/rtl_ps_log.h>
+
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
 int (*nfnetlink_parse_nat_setup_hook)(struct nf_conn *ct,
@@ -160,8 +168,8 @@ nf_ct_invert_tuple(struct nf_conntrack_t
 }
 EXPORT_SYMBOL_GPL(nf_ct_invert_tuple);
 
-static void
-clean_from_lists(struct nf_conn *ct)
+#if !defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+static void clean_from_lists(struct nf_conn *ct)
 {
 	pr_debug("clean_from_lists(%p)\n", ct);
 	hlist_nulls_del_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode);
@@ -170,6 +178,7 @@ clean_from_lists(struct nf_conn *ct)
 	/* Destroy all pending expectations */
 	nf_ct_remove_expectations(ct);
 }
+#endif
 
 static void
 destroy_conntrack(struct nf_conntrack *nfct)
@@ -177,6 +186,9 @@ destroy_conntrack(struct nf_conntrack *n
 	struct nf_conn *ct = (struct nf_conn *)nfct;
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_l4proto *l4proto;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	pr_debug("destroy_conntrack(%p)\n", ct);
 	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
@@ -189,6 +201,13 @@ destroy_conntrack(struct nf_conntrack *n
 	/* To make sure we don't get any weird locking issues here:
 	 * destroy_conntrack() MUST NOT be called with a write lock
 	 * to nf_conntrack_lock!!! -HW */
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+
+	rtl_nf_conntrack_destroy_hooks(&conn_info);
+	#endif
+
 	rcu_read_lock();
 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
 	if (l4proto && l4proto->destroy)
@@ -203,6 +221,13 @@ destroy_conntrack(struct nf_conntrack *n
 	 * too. */
 	nf_ct_remove_expectations(ct);
 
+	#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto)
+		kfree(ct->layer7.app_proto);
+	if(ct->layer7.app_data)
+	kfree(ct->layer7.app_data);
+	#endif
+
 	/* We overload first tuple to link into unconfirmed list. */
 	if (!nf_ct_is_confirmed(ct)) {
 		BUG_ON(hlist_nulls_unhashed(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode));
@@ -219,13 +244,56 @@ destroy_conntrack(struct nf_conntrack *n
 	nf_conntrack_free(ct);
 }
 
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+static void death_by_timeout_forced(unsigned long ul_conntrack)
+{
+	struct nf_conn *ct = (void *)ul_conntrack;
+	struct net *net = nf_ct_net(ct);
+	struct nf_conn_help *help;
+	struct nf_conntrack_helper *helper;
+
+	help = nfct_help(ct);
+	if (help) {
+		rcu_read_lock();
+		helper = rcu_dereference(help->helper);
+		if (helper && helper->destroy)
+			helper->destroy(ct);
+		rcu_read_unlock();
+	}
+
+	spin_lock_bh(&nf_conntrack_lock);
+	/* Inside lock so preempt is disabled on module removal path.
+	 * Otherwise we can get spurious warnings. */
+	NF_CT_STAT_INC(net, delete_list);
+
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	clean_from_lists(ct, net);
+	#else
+	clean_from_lists(ct);
+	#endif
+
+
+	spin_unlock_bh(&nf_conntrack_lock);
+	nf_ct_put(ct);
+}
+#endif
+
 static void death_by_timeout(unsigned long ul_conntrack)
 {
 	struct nf_conn *ct = (void *)ul_conntrack;
 	struct net *net = nf_ct_net(ct);
-	struct nf_conn_help *help = nfct_help(ct);
+	struct nf_conn_help *help;
 	struct nf_conntrack_helper *helper;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
 
+	conn_info.net = net;
+	conn_info.ct = ct;
+	if (RTL_PS_HOOKS_RETURN==rtl_nf_conntrack_death_by_timeout_hooks(&conn_info))
+		return;
+	#endif
+
+	help = nfct_help(ct);
 	if (help) {
 		rcu_read_lock();
 		helper = rcu_dereference(help->helper);
@@ -238,7 +306,12 @@ static void death_by_timeout(unsigned lo
 	/* Inside lock so preempt is disabled on module removal path.
 	 * Otherwise we can get spurious warnings. */
 	NF_CT_STAT_INC(net, delete_list);
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	clean_from_lists((void*)ct, (void*)net);
+	#else
 	clean_from_lists(ct);
+	#endif
+
 	spin_unlock_bh(&nf_conntrack_lock);
 	nf_ct_put(ct);
 }
@@ -345,6 +418,9 @@ __nf_conntrack_confirm(struct sk_buff *s
 	struct hlist_nulls_node *n;
 	enum ip_conntrack_info ctinfo;
 	struct net *net;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s		conn_info;
+	#endif
 
 	ct = nf_ct_get(skb, &ctinfo);
 	net = nf_ct_net(ct);
@@ -386,6 +462,14 @@ __nf_conntrack_confirm(struct sk_buff *s
 	/* Remove from unconfirmed list */
 	hlist_nulls_del_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode);
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.ctinfo = ctinfo;
+	rtl_nf_conntrack_confirm_hooks(&conn_info);
+	#endif
+
 	/* Timer relative to confirmation time, not original
 	   setting time, otherwise we'd get timer wrap in
 	   weird delay cases. */
@@ -454,6 +539,7 @@ EXPORT_SYMBOL_GPL(nf_conntrack_tuple_tak
 
 #define NF_CT_EVICTION_RANGE	8
 
+#if !defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)	/* used only when NOT define GARBAGE_NEW */
 /* There's a small race here where we may free a just-assured
    connection.  Too bad: we're in trouble anyway. */
 static noinline int early_drop(struct net *net, unsigned int hash)
@@ -495,6 +581,9 @@ static noinline int early_drop(struct ne
 	nf_ct_put(ct);
 	return dropped;
 }
+#endif
+
+
 
 struct nf_conn *nf_conntrack_alloc(struct net *net,
 				   const struct nf_conntrack_tuple *orig,
@@ -511,11 +600,33 @@ struct nf_conn *nf_conntrack_alloc(struc
 
 	/* We don't want any race condition at early drop stage */
 	atomic_inc(&net->ct.count);
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	if(nf_conntrack_max &&
+		((atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold))&&
+		(atomic_read(&net->ct.count) < (nf_conntrack_max-1)))
+	{
+		if(isReservedConntrack(orig,repl))
+		{
+			/*use reserved conntrack,continue to allocate*/
+			goto alloc_reserved_conn;
+		}
+	}
+#endif
 
-	if (nf_conntrack_max &&
-	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold))
+#else
+	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > nf_conntrack_max))
+#endif
+	{
+		/* Try dropping from this hash chain. */
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		if(!drop_one_conntrack(orig,repl))
+#else
 		unsigned int hash = hash_conntrack(orig);
-		if (!early_drop(net, hash)) {
+		if (!early_drop(net, hash))
+#endif
+		{
 			atomic_dec(&net->ct.count);
 			if (net_ratelimit())
 				printk(KERN_WARNING
@@ -525,13 +636,14 @@ struct nf_conn *nf_conntrack_alloc(struc
 		}
 	}
 
+alloc_reserved_conn:
 	/*
 	 * Do not use kmem_cache_zalloc(), as this cache uses
 	 * SLAB_DESTROY_BY_RCU.
 	 */
 	ct = kmem_cache_alloc(nf_conntrack_cachep, gfp);
 	if (ct == NULL) {
-		pr_debug("nf_conntrack_alloc: Can't alloc conntrack.\n");
+		LOG_WARN("nf_conntrack_alloc: Can't alloc conntrack.\n");
 		atomic_dec(&net->ct.count);
 		return ERR_PTR(-ENOMEM);
 	}
@@ -573,6 +685,146 @@ EXPORT_SYMBOL_GPL(nf_conntrack_free);
 
 /* Allocate a new conntrack: we return -ENOMEM if classification
    failed due to stress.  Otherwise it really is unclassifiable. */
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+unsigned int wan_ip = 0;
+unsigned int wan_mask = 0;
+
+struct nf_conn *rtl_find_ct_by_tuple_dst(struct nf_conntrack_tuple *tuple, int *flag)
+{
+	int i;
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple_hash *h;
+	struct hlist_nulls_node *n;
+
+	for(i=0; i< nf_conntrack_htable_size; i++)
+	{
+		hlist_nulls_for_each_entry(h, n, &init_net.ct.hash[i], hnnode)
+		{
+			if((__nf_ct_tuple_dst_equal(tuple, &h->tuple)) &&
+			  ((h->tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask))&&
+			   (h->tuple.src.u.all == BATTLENET_PORT))
+			  {
+				//memcpy(&reply_tuple_temp, h, sizeof(struct nf_conntrack_tuple_hash));
+				ct = nf_ct_tuplehash_to_ctrack(h);
+
+				if(((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+				    ((ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip & _br0_mask) != (_br0_ip & _br0_mask))&&
+				     (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip != tuple->src.u3.ip)){
+						*flag = 1;
+						return ct;
+					}
+			  }
+		}
+	}
+
+	return NULL;
+
+}
+
+struct nf_conn *rtl_find_ct_by_tuple_src(struct nf_conntrack_tuple *tuple, int *flag)
+{
+	int i;
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+	struct nf_conn *ct;
+	struct nf_conntrack_tuple_hash *h;
+	struct hlist_nulls_node *n;
+
+	for(i=0; i< nf_conntrack_htable_size; i++)
+	{
+		hlist_nulls_for_each_entry(h, n, &init_net.ct.hash[i], hnnode)
+		{
+			if((__nf_ct_tuple_src_equal(tuple, &h->tuple)) &&
+			   (h->tuple.src.u3.ip  != wan_ip))
+			  {
+				ct = nf_ct_tuplehash_to_ctrack(h);
+
+				if(((ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u3.ip & _br0_mask) != (_br0_ip & _br0_mask)) &&
+				     (ct->tuplehash[IP_CT_DIR_REPLY].tuple.src.u.all == BATTLENET_PORT)&&
+				     (ct->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u3.ip == wan_ip)){
+						*flag = 1;
+						return ct;
+					}
+			  }
+		}
+	}
+
+	return NULL;
+
+}
+
+static void rtl_reconfig_reply_tupe(struct sk_buff *skb, const struct nf_conntrack_tuple *tuple,
+	struct nf_conntrack_tuple *repl_tuple)
+{
+
+	extern unsigned int _br0_ip;
+	extern unsigned int _br0_mask;
+
+	int flag_reply = 0;
+	int flag_ori = 0;
+	struct nf_conn *ct_temp_reply = NULL;
+	struct nf_conn *ct_temp_ori = NULL;
+	struct net_device *wan_device = NULL;
+
+	//struct nf_conntrack_tuple_hash reply_tuple_temp;
+	//memset(&reply_tuple_temp, 0, sizeof(struct nf_conntrack_tuple_hash));
+
+	wan_device = rtl865x_getBattleNetWanDev();
+	rtl865x_getBattleNetDevIpAndNetmask(wan_device, &wan_ip, &wan_mask);
+	/*
+	1. protocol is udp;
+	2. original src port is 6112;
+	3. original src ip is lan ip;
+	4. original dst ip is wan ip(ppp dev ip);
+	e.g:
+	original:192.168.1.100:6112->192.168.123.2:6112
+	reply_1: 192.168.123.2:6112->192.168.1.100:6112
+	reply_2: 192.168.1.101:6112->192.168.123.2:6112
+	*/
+	//printk("_br0_ip is %2x, _br0_mask is %2x\n", _br0_ip, _br0_mask);
+	if((ip_hdr(skb)->protocol == IPPROTO_UDP) &&
+		(ntohs(tuple->src.u.all) == BATTLENET_PORT) &&
+		((tuple->src.u3.ip & _br0_mask) == (_br0_ip & _br0_mask)) &&
+		((wan_ip!=0)&&(tuple->dst.u3.ip == wan_ip)))
+	{
+		spin_lock_bh(&nf_conntrack_lock);
+		ct_temp_reply = rtl_find_ct_by_tuple_dst(tuple, &flag_reply);
+
+		if((flag_reply == 1) && (ct_temp_reply != NULL))
+		{
+			/*printk("%s[%d],  sip is %2x, sport is %d; dip is %2x, dport is %d\n", __FUNCTION__, __LINE__,
+				h->tuple.src.u3.ip, h->tuple.src.u.all,
+				h->tuple.dst.u3.ip, h->tuple.dst.u.all);*/
+
+			/*printk("%s[%d],  sip is %2x, sport is %d; dip is %2x, dport is %d\n", __FUNCTION__, __LINE__,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip,
+					ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.all);*/
+
+			ct_temp_ori = rtl_find_ct_by_tuple_src(tuple, &flag_ori);
+
+			if((flag_ori == 1) && (ct_temp_ori != NULL))
+			{
+				/*change ct's reply src ip and port as the original tuple found*/
+				repl_tuple->src.u3.ip = ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+				repl_tuple->src.u.all  = ct_temp_reply->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.all;
+
+				/*change ct's reply dst ip and port as original dst ip and port*/
+				repl_tuple->dst.u3.ip = tuple->dst.u3.ip;
+				repl_tuple->dst.u.all  = ct_temp_ori->tuplehash[IP_CT_DIR_REPLY].tuple.dst.u.all;
+			}
+		}
+
+		spin_unlock_bh(&nf_conntrack_lock);
+
+	}
+
+}
+#endif
+
 static struct nf_conntrack_tuple_hash *
 init_conntrack(struct net *net,
 	       const struct nf_conntrack_tuple *tuple,
@@ -585,12 +837,19 @@ init_conntrack(struct net *net,
 	struct nf_conn_help *help;
 	struct nf_conntrack_tuple repl_tuple;
 	struct nf_conntrack_expect *exp;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l3proto, l4proto)) {
 		pr_debug("Can't invert tuple.\n");
 		return NULL;
 	}
 
+#if defined(CONFIG_RTL_BATTLENET_ALG)
+	rtl_reconfig_reply_tupe(skb, tuple, &repl_tuple);
+#endif
+
 	ct = nf_conntrack_alloc(net, tuple, &repl_tuple, GFP_ATOMIC);
 	if (IS_ERR(ct)) {
 		pr_debug("Can't allocate conntrack.\n");
@@ -632,6 +891,19 @@ init_conntrack(struct net *net,
 		NF_CT_STAT_INC(net, new);
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.l3proto = l3proto;
+	conn_info.l4proto = l4proto;
+	rtl_nf_init_conntrack_hooks(&conn_info);
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	ct->drop_flag = -1;
+	ct->removed   = 0;
+	#endif
+	#endif
+
 	/* Overload tuple linked list to put us in unconfirmed list. */
 	hlist_nulls_add_head_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode,
 		       &net->ct.unconfirmed);
@@ -718,6 +990,9 @@ nf_conntrack_in(struct net *net, u_int8_
 	u_int8_t protonum;
 	int set_reply = 0;
 	int ret;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s		conn_info;
+	#endif
 
 	/* Previously seen (loopback or untracked)?  Ignore. */
 	if (skb->nfct) {
@@ -779,6 +1054,18 @@ nf_conntrack_in(struct net *net, u_int8_
 		return -ret;
 	}
 
+ 	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.l3proto = l3proto;
+	conn_info.l4proto = l4proto;
+	conn_info.protonum = protonum;
+	conn_info.hooknum = hooknum;
+	conn_info.ctinfo = ctinfo;
+	rtl_nf_conntrack_in_hooks(&conn_info);
+	#endif
+
 	if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
 		nf_conntrack_event_cache(IPCT_STATUS, ct);
 
@@ -1012,7 +1299,13 @@ void nf_ct_iterate_cleanup(struct net *n
 	while ((ct = get_next_corpse(net, iter, data, &bucket)) != NULL) {
 		/* Time to push up daises... */
 		if (del_timer(&ct->timeout))
+		{
+			#if defined (CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+			death_by_timeout_forced((unsigned long)ct);
+			#else
 			death_by_timeout((unsigned long)ct);
+			#endif
+		}
 		/* ... else the timer will get him soon. */
 
 		nf_ct_put(ct);
@@ -1234,6 +1527,10 @@ static int nf_conntrack_init_init_net(vo
 	if (ret < 0)
 		goto err_helper;
 
+#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_init_hooks();
+#endif
+
 	return 0;
 
 err_helper:
@@ -1296,6 +1593,95 @@ err_stat:
 	return ret;
 }
 
+#ifdef RTL_NF_ALG_CTL
+
+struct alg_entry alg_list[alg_type_end] =
+{
+    ALG_CTL_DEF(ftp,  1),
+    ALG_CTL_DEF(tftp, 1),
+    ALG_CTL_DEF(rtsp, 1),
+    ALG_CTL_DEF(pptp, 1),
+    ALG_CTL_DEF(l2tp, 1),
+    ALG_CTL_DEF(ipsec,1),
+    ALG_CTL_DEF(sip,  1),
+    ALG_CTL_DEF(h323, 1),
+};
+
+int alg_enable(int type)
+{
+    return alg_list[type].enable;
+}
+EXPORT_SYMBOL_GPL(alg_enable);
+
+static struct proc_dir_entry *proc_alg = NULL;
+
+static int proc_alg_debug_read(char *page, char **start, off_t off,
+			  int count, int *eof, void *data)
+{
+    char *out = page;
+	int len = 0;
+    int i = 0;
+
+    out += sprintf(out, "\n===================================================\n");
+    for (i = 0; i < alg_type_end; i++)
+    {
+        out += sprintf(out, "| %s=%d\n", alg_list[i].name, alg_list[i].enable);
+    }
+    out += sprintf(out, "---------------------------------------------------\n");
+
+	len = out - page;
+	len -= off;
+	if (len < count) {
+		*eof = 1;
+		if (len <= 0)
+            return 0;
+	} else
+		len = count;
+
+	*start = page + off;
+	return len;
+}
+
+static int proc_alg_debug_write( struct file *filp, const char __user *buf,unsigned long len, void *data )
+{
+	int ret;
+	char str_buf[256];
+	char action[20] = {0};
+	int val = 0;
+	int i = 0;
+
+	if(len > 255)
+	{
+		printk("Usage: echo ftp 1 > /proc/alg \n");
+		return len;
+	}
+
+	copy_from_user(str_buf,buf,len);
+	str_buf[len] = '\0';
+
+	ret = sscanf(str_buf, "%s %d", action, (int*)&val);
+	if(ret != 2 || val < 0 )
+	{
+		printk("Error. Sample: echo ftp 1 > /proc/alg \n");
+		return len;
+	}
+
+	for (i = 0; i < alg_type_end; i++)
+	{
+	    if (0 == strcmp(action, alg_list[i].name))
+	    {
+	        alg_list[i].enable = val;
+	        return len;
+	    }
+	}
+
+	printk("Error: Unkown command.\n");
+
+	return len;
+}
+#endif
+
+
 int nf_conntrack_init(struct net *net)
 {
 	int ret;
@@ -1314,6 +1700,14 @@ int nf_conntrack_init(struct net *net)
 		rcu_assign_pointer(ip_ct_attach, nf_conntrack_attach);
 		rcu_assign_pointer(nf_ct_destroy, destroy_conntrack);
 	}
+
+#ifdef RTL_NF_ALG_CTL
+	proc_alg = create_proc_entry("alg", 0, NULL);
+	if (proc_alg) {
+		proc_alg->read_proc = proc_alg_debug_read;
+		proc_alg->write_proc = proc_alg_debug_write;
+	}
+#endif
 	return 0;
 
 out_net:
--- linux-2.6.30.9/net/netfilter/nf_conntrack_expect.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_expect.c	2013-05-02 01:47:59.403226599 +0300
@@ -102,6 +102,39 @@ __nf_ct_expect_find(struct net *net, con
 }
 EXPORT_SYMBOL_GPL(__nf_ct_expect_find);
 
+#if defined(CONFIG_IP_NF_TARGET_CONENAT)
+static inline int
+exp_src_cmp(const struct nf_conntrack_expect * exp,
+	    const struct nf_conntrack_tuple * tp)
+{
+	return	exp->saved_ip == tp->src.u3.ip &&
+			exp->saved_proto.udp.port == tp->src.u.udp.port &&
+			exp->tuple.dst.protonum == tp->dst.protonum;
+}
+
+struct nf_conntrack_expect *
+__nf_ct_expect_find_bysave(struct net *net, const struct nf_conntrack_tuple *tupleMake, const struct nf_conntrack_tuple *tuple)
+{
+	struct nf_conntrack_expect *i;
+	struct hlist_node *n;
+	unsigned int h;
+
+	if (!net->ct.expect_count)
+		return NULL;
+
+	h = nf_ct_expect_dst_hash(tupleMake);
+
+	hlist_for_each_entry(i, n, &net->ct.expect_hash[h], hnode) {
+
+		if (exp_src_cmp(i, tuple)){
+				return i;
+			}
+	}
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(__nf_ct_expect_find_bysave);
+#endif
+
 /* Just find a expectation corresponding to a tuple. */
 struct nf_conntrack_expect *
 nf_ct_expect_find_get(struct net *net, const struct nf_conntrack_tuple *tuple)
--- linux-2.6.30.9/net/netfilter/nf_conntrack_ftp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_ftp.c	2013-05-02 01:47:59.403226599 +0300
@@ -367,6 +367,10 @@ static int help(struct sk_buff *skb,
 	int found = 0, ends_in_nl;
 	typeof(nf_nat_ftp_hook) nf_nat_ftp;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_ftp);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED
 	    && ctinfo != IP_CT_ESTABLISHED+IP_CT_IS_REPLY) {
--- linux-2.6.30.9/net/netfilter/nf_conntrack_h323_main.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_h323_main.c	2013-05-02 01:47:59.404226599 +0300
@@ -569,6 +569,10 @@ static int h245_help(struct sk_buff *skb
 	int dataoff;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
@@ -1115,6 +1119,10 @@ static int q931_help(struct sk_buff *skb
 	int dataoff;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
+
 	/* Until there's been traffic both ways, don't look in packets. */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY) {
@@ -1695,6 +1703,9 @@ static int ras_help(struct sk_buff *skb,
 	int datalen = 0;
 	int ret;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_h323);
+	#endif
 	pr_debug("nf_ct_ras: skblen = %u\n", skb->len);
 
 	spin_lock_bh(&nf_h323_lock);
--- linux-2.6.30.9/net/netfilter/nf_conntrack_pptp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_pptp.c	2013-05-02 01:47:59.408226598 +0300
@@ -516,6 +516,10 @@ conntrack_pptp_help(struct sk_buff *skb,
 	int ret;
 	u_int16_t msg;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_pptp);
+	#endif
+
 	/* don't do any tracking before tcp handshake complete */
 	if (ctinfo != IP_CT_ESTABLISHED &&
 	    ctinfo != IP_CT_ESTABLISHED + IP_CT_IS_REPLY)
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto.c	2013-05-02 01:47:59.408226598 +0300
@@ -29,7 +29,12 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_core.h>
 
-static struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX] __read_mostly;
+#if defined(FAST_PATH_SPI_ENABLED)
+	struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX]  __read_mostly;
+#else
+	static struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX] __read_mostly;
+#endif
+
 struct nf_conntrack_l3proto *nf_ct_l3protos[AF_MAX] __read_mostly;
 EXPORT_SYMBOL_GPL(nf_ct_l3protos);
 
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto_tcp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_tcp.c	2013-05-02 01:47:59.411226598 +0300
@@ -28,6 +28,14 @@
 #include <net/netfilter/nf_log.h>
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+#include <net/netfilter/nf_nat_core.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+#if defined(FAST_PATH_SPI_ENABLED)
+extern int fast_spi;
+#endif
 
 /* Protects ct->proto.tcp */
 static DEFINE_RWLOCK(tcp_lock);
@@ -261,6 +269,13 @@ static const u8 tcp_conntracks[2][6][TCP
 	}
 };
 
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
+int	tcp_get_timeouts_by_state(u_int8_t	state)
+{
+	return tcp_timeouts[state];
+}
+#endif
+
 static bool tcp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
 			     struct nf_conntrack_tuple *tuple)
 {
@@ -482,7 +497,10 @@ static void tcp_sack(const struct sk_buf
 	}
 }
 
-static bool tcp_in_window(const struct nf_conn *ct,
+#if !defined(FAST_PATH_SPI_ENABLED)
+static
+#endif
+	bool tcp_in_window(const struct nf_conn *ct,
 			  struct ip_ct_tcp *state,
 			  enum ip_conntrack_dir dir,
 			  unsigned int index,
@@ -812,6 +831,7 @@ static int tcp_error(struct net *net,
 	return NF_ACCEPT;
 }
 
+//#define RTL_FP_CHECK_SPI_ENABLED 1
 /* Returns verdict for packet, or -1 for invalid. */
 static int tcp_packet(struct nf_conn *ct,
 		      const struct sk_buff *skb,
@@ -828,6 +848,9 @@ static int tcp_packet(struct nf_conn *ct
 	struct tcphdr _tcph;
 	unsigned long timeout;
 	unsigned int index;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
 	BUG_ON(th == NULL);
@@ -839,6 +862,17 @@ static int tcp_packet(struct nf_conn *ct
 	new_state = tcp_conntracks[dir][index][old_state];
 	tuple = &ct->tuplehash[dir].tuple;
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.hooknum = hooknum;
+	conn_info.ctinfo = ctinfo;
+	conn_info.new_state=new_state;
+	conn_info.old_state=old_state;
+	rtl_tcp_packet_hooks(&conn_info);
+	#endif
+
 	switch (new_state) {
 	case TCP_CONNTRACK_SYN_SENT:
 		if (old_state < TCP_CONNTRACK_TIME_WAIT)
@@ -959,11 +993,18 @@ static int tcp_packet(struct nf_conn *ct
 		break;
 	}
 
-	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
+#if defined(FAST_PATH_SPI_ENABLED) || !(defined(CONFIG_RTL_IPTABLES_FAST_PATH) ||defined(CONFIG_RTL_HARDWARE_NAT))
+	if (
+#if defined(FAST_PATH_SPI_ENABLED)
+(fast_spi == 1) &&
+#endif
+		!tcp_in_window(ct, &ct->proto.tcp, dir, index,
 			   skb, dataoff, th, pf)) {
 		write_unlock_bh(&tcp_lock);
 		return -NF_ACCEPT;
 	}
+#endif
+
      in_window:
 	/* From now on we have got in-window packets */
 	ct->proto.tcp.last_index = index;
@@ -1015,7 +1056,13 @@ static int tcp_packet(struct nf_conn *ct
 		set_bit(IPS_ASSURED_BIT, &ct->status);
 		nf_conntrack_event_cache(IPCT_STATUS, ct);
 	}
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	nf_ct_refresh_acct_tcp(ct, ctinfo, skb, timeout, old_state, new_state);
+#else
 	nf_ct_refresh_acct(ct, ctinfo, skb, timeout);
+#endif
+	//nf_ct_refresh_acct(ct, ctinfo, skb, timeout);
 
 	return NF_ACCEPT;
 }
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto_udp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_udp.c	2013-05-02 01:47:59.411226598 +0300
@@ -24,9 +24,12 @@
 #include <net/netfilter/nf_log.h>
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
 
-static unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
-static unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
+unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
+unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
 
 static bool udp_pkt_to_tuple(const struct sk_buff *skb,
 			     unsigned int dataoff,
@@ -74,12 +77,22 @@ static int udp_packet(struct nf_conn *ct
 	/* If we've seen traffic both ways, this is some kind of UDP
 	   stream.  Extend timeout. */
 	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		nf_ct_refresh_acct_udp(ct, ctinfo, skb, nf_ct_udp_timeout_stream, "ASSURED"); // assured
+#else
 		nf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_udp_timeout_stream);
+#endif			
+		
 		/* Also, more likely to be important, and not a probe */
 		if (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))
 			nf_conntrack_event_cache(IPCT_STATUS, ct);
-	} else
+	} else {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		nf_ct_refresh_acct_udp(ct, ctinfo, skb, nf_ct_udp_timeout, "UNREPLIED"); // unreplied
+#else
 		nf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_udp_timeout);
+#endif
+	}
 
 	return NF_ACCEPT;
 }
--- linux-2.6.30.9/net/netfilter/nf_conntrack_sip.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_sip.c	2013-05-02 01:47:59.413226598 +0300
@@ -1268,6 +1268,10 @@ static int sip_help(struct sk_buff *skb,
 	int ret;
 	typeof(nf_nat_sip_hook) nf_nat_sip;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_sip);
+	#endif
+
 	/* No Data ? */
 	dataoff = protoff + sizeof(struct udphdr);
 	if (dataoff >= skb->len)
--- linux-2.6.30.9/net/netfilter/nf_conntrack_standalone.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_standalone.c	2013-05-02 01:47:59.413226598 +0300
@@ -27,6 +27,11 @@
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_conntrack_acct.h>
 
+
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 MODULE_LICENSE("GPL");
 
 #ifdef CONFIG_PROC_FS
@@ -113,6 +118,7 @@ static int ct_seq_show(struct seq_file *
 	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);
 	const struct nf_conntrack_l3proto *l3proto;
 	const struct nf_conntrack_l4proto *l4proto;
+	//hyking add for hw use
 	int ret = 0;
 
 	NF_CT_ASSERT(ct);
@@ -129,6 +135,12 @@ static int ct_seq_show(struct seq_file *
 	NF_CT_ASSERT(l4proto);
 
 	ret = -ENOSPC;
+	//hyking add for hw use
+	#if defined(CONFIG_RTL_819X)
+	if(rtl_ct_seq_show_hooks(s,ct)==RTL_PS_HOOKS_BREAK)
+		goto release;		
+	#endif
+	
 	if (seq_printf(s, "%-8s %u %-8s %u %ld ",
 		       l3proto->name, nf_ct_l3num(ct),
 		       l4proto->name, nf_ct_protonum(ct),
@@ -171,6 +183,13 @@ static int ct_seq_show(struct seq_file *
 		goto release;
 #endif
 
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_LAYER7) || defined(CONFIG_NETFILTER_XT_MATCH_LAYER7_MODULE)
+	if(ct->layer7.app_proto &&
+           seq_printf(s, "l7proto=%s ", ct->layer7.app_proto))
+		return -ENOSPC;
+#endif
+
 	if (seq_printf(s, "use=%u\n", atomic_read(&ct->ct_general.use)))
 		goto release;
 
@@ -338,7 +357,29 @@ static int log_invalid_proto_max = 255;
 
 static struct ctl_table_header *nf_ct_netfilter_header;
 
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+extern unsigned int conntrack_min;
+extern unsigned int conntrack_max;
+extern unsigned int prot_limit[];
+
+extern int conntrack_dointvec(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+extern int conntrack_dointvec_minmax(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+#endif 
+
+
 static ctl_table nf_ct_sysctl_table[] = {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	{
+		.ctl_name	= NET_NF_CONNTRACK_MAX,
+		.procname	= "nf_conntrack_max",
+		.data		= &nf_conntrack_max,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec,
+	},
+#else
 	{
 		.ctl_name	= NET_NF_CONNTRACK_MAX,
 		.procname	= "nf_conntrack_max",
@@ -347,6 +388,7 @@ static ctl_table nf_ct_sysctl_table[] =
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#endif
 	{
 		.ctl_name	= NET_NF_CONNTRACK_COUNT,
 		.procname	= "nf_conntrack_count",
@@ -390,6 +432,29 @@ static ctl_table nf_ct_sysctl_table[] =
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#if defined(CONFIG_RTL_CONNTRACK_GARBAGE_NEW)
+	{ 
+		.ctl_name	= NET_NF_CONNTRACK_GARBAGE_TCP,
+		.procname	= "nf_conntrack_tcp",
+		.data		= &prot_limit[PROT_TCP],
+		.maxlen		= sizeof(prot_limit[PROT_TCP]), 
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec_minmax,
+		.extra1		= &conntrack_min,
+		.extra2		= &conntrack_max,
+	},
+	{ 
+		.ctl_name	= NET_NF_CONNTRACK_GARBAGE_UDP,
+		.procname	= "nf_conntrack_udp",
+		.data		= &prot_limit[PROT_UDP],
+		.maxlen		= sizeof(prot_limit[PROT_UDP]), 
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec_minmax,
+		.extra1		= &conntrack_min,
+		.extra2		= &conntrack_max,
+	},
+#endif
+
 	{ .ctl_name = 0 }
 };
 
@@ -402,7 +467,11 @@ static ctl_table nf_ct_netfilter_table[]
 		.data		= &nf_conntrack_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		.proc_handler	= &conntrack_dointvec,
+#else
 		.proc_handler	= proc_dointvec,
+#endif
 	},
 	{ .ctl_name = 0 }
 };
--- linux-2.6.30.9/net/netfilter/nf_conntrack_tftp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_tftp.c	2013-05-02 01:47:59.414226598 +0300
@@ -47,6 +47,10 @@ static int tftp_help(struct sk_buff *skb
 	unsigned int ret = NF_ACCEPT;
 	typeof(nf_nat_tftp_hook) nf_nat_tftp;
 
+	#ifdef RTL_NF_ALG_CTL
+	ALG_CHECK_ONOFF(alg_type_tftp);
+	#endif
+
 	tfh = skb_header_pointer(skb, protoff + sizeof(struct udphdr),
 				 sizeof(_tftph), &_tftph);
 	if (tfh == NULL)
--- linux-2.6.30.9/net/netfilter/xt_dscp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_dscp.c	2013-05-02 01:47:59.424226597 +0300
@@ -17,6 +17,12 @@
 #include <linux/netfilter/xt_dscp.h>
 #include <linux/netfilter_ipv4/ipt_tos.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
+
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
 MODULE_LICENSE("GPL");
@@ -34,6 +40,29 @@ dscp_mt(const struct sk_buff *skb, const
 	return (dscp == info->dscp) ^ !!info->invert;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int dscp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct xt_dscp_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL || rule == NULL)
+		return 1;
+	
+	rule->ruleType_ = RTL865X_ACL_IP;
+	rule->tos_ = ipv4_get_dsfield((struct iphdr *)ip);
+	rule->tosMask_ = XT_DSCP_MASK;
+
+	return 0;
+}
+#endif
+
 static bool
 dscp_mt6(const struct sk_buff *skb, const struct xt_match_param *par)
 {
@@ -83,6 +112,10 @@ static struct xt_match dscp_mt_reg[] __r
 		.match		= dscp_mt,
 		.matchsize	= sizeof(struct xt_dscp_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= dscp_match2acl,
+#endif
+
 	},
 	{
 		.name		= "dscp",
--- linux-2.6.30.9/net/netfilter/xt_iprange.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_iprange.c	2013-05-02 01:47:59.425226597 +0300
@@ -16,6 +16,12 @@
 #include <linux/netfilter/xt_iprange.h>
 #include <linux/netfilter_ipv4/ipt_iprange.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
+
 static bool
 iprange_mt_v0(const struct sk_buff *skb, const struct xt_match_param *par)
 {
@@ -85,6 +91,113 @@ iprange_mt4(const struct sk_buff *skb, c
 	return true;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int iprange_match2acl(const char *tablename,
+                          const void *ip,
+                          const struct xt_match *match,
+                          void *matchinfo,
+                          void *acl_rule,
+                          unsigned int *invflags)
+{
+ 
+        const struct ipt_iprange_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+ 
+        if(ip == NULL || matchinfo == NULL || rule == NULL)
+                return 1;
+ 
+        switch(rule->ruleType_)
+        {
+                case            RTL865X_ACL_TCP:
+                        rule->ruleType_ = RTL865X_ACL_TCP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_UDP:
+                        rule->ruleType_ = RTL865X_ACL_UDP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_IGMP:
+                        rule->ruleType_ = RTL865X_ACL_ICMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_ICMP:
+                        rule->ruleType_ = RTL865X_ACL_IGMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_SRCFILTER:
+                        rule->ruleType_ = RTL865X_ACL_SRCFILTER_IPRANGE;
+                        break;
+                case            RTL865X_ACL_MAC:
+                case            RTL865X_ACL_IP:
+                        rule->ruleType_ = RTL865X_ACL_IP_RANGE;
+                        break;
+                default:
+                        return 1;
+        }
+
+        rule->srcIpAddrLB_ = rule->dstIpAddrLB_ = 0;
+        rule->srcIpAddrUB_ = rule->dstIpAddrUB_ = 0xffffffff;
+        if (info->flags & IPRANGE_SRC) {
+                rule->srcIpAddrLB_ = ntohl(info->src.min_ip);
+                rule->srcIpAddrUB_ = ntohl(info->src.max_ip);
+        }
+        if (info->flags & IPRANGE_DST) {
+                rule->dstIpAddrLB_ = ntohl(info->dst.min_ip);
+                rule->dstIpAddrUB_ = ntohl(info->dst.max_ip);
+        }
+ 
+        return 0;
+}
+static int iprange_match2acl_mt4(const char *tablename,
+                          const void *ip,
+                          const struct xt_match *match,
+                          void *matchinfo,
+                          void *acl_rule,
+                          unsigned int *invflags)
+{
+ 
+        const struct xt_iprange_mtinfo *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+ 
+        if(ip == NULL || matchinfo == NULL || rule == NULL)
+                return 1;
+ 
+        switch(rule->ruleType_)
+        {
+                case            RTL865X_ACL_TCP:
+                        rule->ruleType_ = RTL865X_ACL_TCP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_UDP:
+                        rule->ruleType_ = RTL865X_ACL_UDP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_IGMP:
+                        rule->ruleType_ = RTL865X_ACL_ICMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_ICMP:
+                        rule->ruleType_ = RTL865X_ACL_IGMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_SRCFILTER:
+                        rule->ruleType_ = RTL865X_ACL_SRCFILTER_IPRANGE;
+                        break;
+                case            RTL865X_ACL_MAC:
+                case            RTL865X_ACL_IP:
+                        rule->ruleType_ = RTL865X_ACL_IP_RANGE;
+                        break;
+                default:
+                        return 1;
+        }
+
+        rule->srcIpAddrLB_ = rule->dstIpAddrLB_ = 0;
+        rule->srcIpAddrUB_ = rule->dstIpAddrUB_ = 0xffffffff;
+        if (info->flags & IPRANGE_SRC) {
+                rule->srcIpAddrLB_ = info->src_min.in.s_addr;
+                rule->srcIpAddrUB_ = info->src_max.in.s_addr;
+        }
+        if (info->flags & IPRANGE_DST) {
+                rule->dstIpAddrLB_ = info->dst_min.in.s_addr;
+                rule->dstIpAddrUB_ = info->dst_max.in.s_addr;
+        }
+ 
+        return 0;
+}
+#endif
+
 static inline int
 iprange_ipv6_sub(const struct in6_addr *a, const struct in6_addr *b)
 {
@@ -132,6 +245,10 @@ static struct xt_match iprange_mt_reg[]
 		.match     = iprange_mt_v0,
 		.matchsize = sizeof(struct ipt_iprange_info),
 		.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+        	.match2acl      = iprange_match2acl,
+#endif
+
 	},
 	{
 		.name      = "iprange",
@@ -140,6 +257,9 @@ static struct xt_match iprange_mt_reg[]
 		.match     = iprange_mt4,
 		.matchsize = sizeof(struct xt_iprange_mtinfo),
 		.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+        	.match2acl      = iprange_match2acl_mt4,
+#endif
 	},
 	{
 		.name      = "iprange",
--- linux-2.6.30.9/net/netfilter/xt_mac.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_mac.c	2013-05-02 01:47:59.426226597 +0300
@@ -17,6 +17,13 @@
 #include <linux/netfilter_ipv6.h>
 #include <linux/netfilter/xt_mac.h>
 #include <linux/netfilter/x_tables.h>
+#include <net/dst.h>
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
@@ -24,37 +31,149 @@ MODULE_DESCRIPTION("Xtables: MAC address
 MODULE_ALIAS("ipt_mac");
 MODULE_ALIAS("ip6t_mac");
 
+static int compare_with_header_cache_dest_mac(const struct sk_buff *skb, char *macaddr)
+{
+	struct dst_entry *dst = skb->dst;
+	struct hh_cache *hh;
+	int ret = 0;
+	
+	if ((dst)&&(dst->hh)&&(dst->hh->hh_data))
+	{
+	    	hh = dst->hh;
+	    	if (hh && (hh->hh_type==ETH_P_IP || hh->hh_type==ETH_P_IPV6))
+		{
+	    		read_lock_bh(&hh->hh_lock);
+	      		memcpy(skb->data - 16, hh->hh_data, 16);
+	      		if (memcmp((((u8*)hh->hh_data) + 2), macaddr, ETH_ALEN) == 0)
+	      		    ret = 1;
+	    		read_unlock_bh(&hh->hh_lock);
+	    	}
+	}
+	else
+	{
+		if(!compare_ether_addr(eth_hdr(skb)->h_dest, macaddr))
+		{
+			ret=1;
+		}
+	}
+	return ret;
+}
+
 static bool mac_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
     const struct xt_mac_info *info = par->matchinfo;
 
+	#if defined(CONFIG_RTL_MAC_FILTER_CARE_INPORT)
+	if((info->flags&INPORT_FLAG) && !((1<<(skb->srcPhyPort)) & info->inPortMask)){
+		return 0;
+	}
+	#endif
+	
+	if (info->flags & MAC_SRC) {
     /* Is mac pointer valid? */
-    return skb_mac_header(skb) >= skb->head &&
-	   skb_mac_header(skb) + ETH_HLEN <= skb->data
+	    if ((skb_mac_header(skb) >= skb->head
+		    && (skb_mac_header(skb) + ETH_HLEN) <= skb->data
 	   /* If so, compare... */
-	   && ((!compare_ether_addr(eth_hdr(skb)->h_source, info->srcaddr))
-		^ info->invert);
+		    && ((!compare_ether_addr(eth_hdr(skb)->h_source, info->srcaddr.macaddr))
+			^ !!(info->flags & MAC_SRC_INV)))==0)
+	    	{
+			return 0;
+	    	}
+	}
+
+	if (info->flags & MAC_DST) {
+	     /* Is mac pointer valid? */
+	    if( (skb_mac_header(skb) >= skb->head
+		    && (skb_mac_header(skb) + ETH_HLEN) <= skb->data
+		    /* If so, compare... */
+		    && (compare_with_header_cache_dest_mac(skb, (char*)(info->dstaddr.macaddr)) ^ !!(info->flags & MAC_DST_INV)))==0)
+	    	{
+			return 0;
+	    	}
+	}
+
+	return 1;
+
+}
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int mac_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct xt_mac_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+	if(matchinfo == NULL || rule == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_MAC;
+
+	//To initial first
+	memset(rule->srcMac_.octet, 0, ETH_ALEN);
+	memset(rule->srcMacMask_.octet, 0, ETH_ALEN);
+	memset(rule->dstMac_.octet, 0, ETH_ALEN);
+	memset(rule->dstMacMask_.octet, 0, ETH_ALEN);
+	
+	if (info->flags & MAC_SRC) {
+		memcpy(rule->srcMac_.octet, info->srcaddr.macaddr, ETH_ALEN);
+		memset(rule->srcMacMask_.octet, 0xff, ETH_ALEN);
+	}
+
+	if (info->flags & MAC_DST) {
+		memcpy(rule->dstMac_.octet, info->dstaddr.macaddr, ETH_ALEN);
+		memset(rule->dstMacMask_.octet, 0xff, ETH_ALEN);
+	}
+	
+	rule->typeLen_ = rule->typeLenMask_ = 0;
+	
+	return 0;
 }
+#endif
 
-static struct xt_match mac_mt_reg __read_mostly = {
+static struct xt_match mac_mt_reg[] __read_mostly = {
+	{
+	.name      = "mac",
+	.revision  = 0,
+	.family    = NFPROTO_IPV4,
+	.match     = mac_mt,
+	.matchsize = sizeof(struct xt_mac_info),
+/*	.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |
+	             (1 << NF_INET_FORWARD),
+*/
+	.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	.match2acl	= mac_match2acl,
+#endif
+	},
+	{
 	.name      = "mac",
 	.revision  = 0,
-	.family    = NFPROTO_UNSPEC,
+	.family    = NFPROTO_IPV6,
 	.match     = mac_mt,
 	.matchsize = sizeof(struct xt_mac_info),
-	.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |
+/*	.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |
 	             (1 << NF_INET_FORWARD),
+*/
 	.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	.match2acl	= mac_match2acl,
+#endif
+	},
+
 };
 
 static int __init mac_mt_init(void)
 {
-	return xt_register_match(&mac_mt_reg);
+	return xt_register_matches(mac_mt_reg, ARRAY_SIZE(mac_mt_reg));	
 }
 
 static void __exit mac_mt_exit(void)
 {
-	xt_unregister_match(&mac_mt_reg);
+	xt_unregister_matches(mac_mt_reg, ARRAY_SIZE(mac_mt_reg));
 }
 
 module_init(mac_mt_init);
--- linux-2.6.30.9/net/netfilter/xt_MARK.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_MARK.c	2013-05-02 01:47:59.420226597 +0300
@@ -17,6 +17,12 @@
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_MARK.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <net/pkt_cls.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Marc Boucher <marc@mbsi.ca>");
@@ -146,6 +152,141 @@ static int mark_tg_compat_to_user_v1(voi
 }
 #endif /* CONFIG_COMPAT */
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+int xt_target2acl_v0(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_target_info *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+int xt_target2acl_v1(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_target_info_v1 *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+int xt_target2acl_v2(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_tginfo2 *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+#endif
+
 static struct xt_target mark_tg_reg[] __read_mostly = {
 	{
 		.name		= "MARK",
@@ -160,6 +301,9 @@ static struct xt_target mark_tg_reg[] __
 		.compat_to_user	= mark_tg_compat_to_user_v0,
 #endif
 		.table		= "mangle",
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v0,
+#endif
 		.me		= THIS_MODULE,
 	},
 	{
@@ -175,6 +319,9 @@ static struct xt_target mark_tg_reg[] __
 		.compat_to_user	= mark_tg_compat_to_user_v1,
 #endif
 		.table		= "mangle",
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v1,
+#endif
 		.me		= THIS_MODULE,
 	},
 	{
@@ -183,6 +330,9 @@ static struct xt_target mark_tg_reg[] __
 		.family         = NFPROTO_UNSPEC,
 		.target         = mark_tg,
 		.targetsize     = sizeof(struct xt_mark_tginfo2),
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v2,
+#endif
 		.me             = THIS_MODULE,
 	},
 };
--- linux-2.6.30.9/net/netfilter/xt_state.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_state.c	2013-05-02 01:47:59.428226597 +0300
@@ -52,6 +52,25 @@ static void state_mt_destroy(const struc
 	nf_ct_l3proto_module_put(par->match->family);
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int state_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct xt_state_info *sinfo = (struct xt_state_info *)matchinfo;
+	
+	if(sinfo->statemask & XT_STATE_BIT(IP_CT_ESTABLISHED))
+	{
+		return RTL865X_ESTABLISH_RULE;
+	}
+	/*if state rule is added, don't add this rule to rtl865x ACL table...skip this rule now.*/
+	return RTL865X_SKIP_THIS_RULE;	
+}
+#endif
+
 static struct xt_match state_mt_reg[] __read_mostly = {
 	{
 		.name		= "state",
@@ -61,6 +80,9 @@ static struct xt_match state_mt_reg[] __
 		.destroy	= state_mt_destroy,
 		.matchsize	= sizeof(struct xt_state_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= state_match2acl,
+#endif
 	},
 	{
 		.name		= "state",
@@ -70,6 +92,9 @@ static struct xt_match state_mt_reg[] __
 		.destroy	= state_mt_destroy,
 		.matchsize	= sizeof(struct xt_state_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= state_match2acl,
+#endif
 	},
 };
 
--- linux-2.6.30.9/net/netfilter/xt_tcpudp.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_tcpudp.c	2013-05-02 01:47:59.429226597 +0300
@@ -10,6 +10,11 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 MODULE_DESCRIPTION("Xtables: TCP, UDP and UDP-Lite match");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("xt_tcp");
@@ -126,6 +131,43 @@ static bool tcp_mt(const struct sk_buff
 	return true;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int tcp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct xt_tcp *tcpinfo = matchinfo;
+	rtl865x_AclRule_t * rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_TCP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->tcpSrcPortLB_	= tcpinfo->spts[0];
+	rule->tcpSrcPortUB_	= tcpinfo->spts[1];
+	rule->tcpDstPortLB_	= tcpinfo->dpts[0];
+	rule->tcpDstPortUB_	= tcpinfo->dpts[1];
+	rule->tcpFlag_		= tcpinfo->flg_cmp;
+	rule->tcpFlagMask_	= tcpinfo->flg_mask;
+
+	if(tcpinfo->invflags & (XT_TCP_INV_SRCPT | XT_TCP_INV_DSTPT | XT_TCP_INV_FLAGS))
+		if(invflags)
+			*invflags = 1;	
+	
+	return 0;
+}
+#endif
+
 static bool tcp_mt_check(const struct xt_mtchk_param *par)
 {
 	const struct xt_tcp *tcpinfo = par->matchinfo;
@@ -161,6 +203,41 @@ static bool udp_mt(const struct sk_buff
 			      !!(udpinfo->invflags & XT_UDP_INV_DSTPT));
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int udp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct xt_udp *udpinfo = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_UDP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->udpSrcPortLB_	= udpinfo->spts[0];
+	rule->udpSrcPortUB_	= udpinfo->spts[1];
+	rule->udpDstPortLB_	= udpinfo->dpts[0];
+	rule->udpDstPortUB_	= udpinfo->dpts[1];
+	
+
+	if(udpinfo->invflags & (XT_UDP_INV_SRCPT | XT_UDP_INV_DSTPT))
+		if(invflags)
+			*invflags = 1;	
+		
+	return 0;
+}
+#endif
+
 static bool udp_mt_check(const struct xt_mtchk_param *par)
 {
 	const struct xt_udp *udpinfo = par->matchinfo;
@@ -178,6 +255,9 @@ static struct xt_match tcpudp_mt_reg[] _
 		.matchsize	= sizeof(struct xt_tcp),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= tcp_match2acl,
+#endif
 	},
 	{
 		.name		= "tcp",
@@ -187,6 +267,9 @@ static struct xt_match tcpudp_mt_reg[] _
 		.matchsize	= sizeof(struct xt_tcp),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= tcp_match2acl,
+#endif
 	},
 	{
 		.name		= "udp",
@@ -196,6 +279,9 @@ static struct xt_match tcpudp_mt_reg[] _
 		.matchsize	= sizeof(struct xt_udp),
 		.proto		= IPPROTO_UDP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= udp_match2acl,
+#endif
 	},
 	{
 		.name		= "udp",
@@ -205,6 +291,9 @@ static struct xt_match tcpudp_mt_reg[] _
 		.matchsize	= sizeof(struct xt_udp),
 		.proto		= IPPROTO_UDP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= udp_match2acl,
+#endif
 	},
 	{
 		.name		= "udplite",
--- linux-2.6.30.9/net/netlink/af_netlink.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/netlink/af_netlink.c	2013-05-02 01:47:59.434226596 +0300
@@ -1491,8 +1491,61 @@ out_sock_release_nosk:
 	return NULL;
 }
 EXPORT_SYMBOL(netlink_kernel_create);
+#if defined(CONFIG_RTL_819X)
+int rtk_nlrecvmsg(struct sk_buff *skb,int _len, void *_recv_data)
+{
+	int pid;
+//	struct sk_buff *skb;
+  	struct nlmsghdr *nlh;
+	
+	pid=0;
+//  	printk("net_link: data is ready to read.\n");
+  	//skb = skb_get(_skb);
+	
+	if (skb->len >= NLMSG_SPACE(0)) {
+    		nlh = nlmsg_hdr(skb);
+		memcpy(_recv_data,NLMSG_DATA(nlh),_len);
+    		pid = nlh->nlmsg_pid; /*pid of sending process */
+//    		printk("net_link: pid is %d\n", pid);    		
+		//kfree_skb(skb);	
+		return pid;
+  	}
+	else
+	{
+		//kfree_skb(skb);	
+		return -1;
+	}
+}
+EXPORT_SYMBOL(rtk_nlrecvmsg);
 
+int rtk_nlsendmsg (int _pid,struct sock *_nl_sk,int _len,void *_send_info) 
+{
+        struct nlmsghdr *nlh;
+        struct sk_buff *skb;
+        int rc;
+        int len;
+
+	 len = NLMSG_SPACE(_len+sizeof(struct nlmsghdr)+32);
 
+        skb = alloc_skb(len, GFP_ATOMIC);
+        if (!skb){
+                printk(KERN_ERR "net_link: allocate failed.\n");
+                return -1;
+        }
+        nlh = nlmsg_put(skb,0,0,0,len,0);
+        NETLINK_CB(skb).pid = 0; /* from kernel */
+ 
+        memcpy(NLMSG_DATA(nlh), _send_info, _len);
+//        printk("net_link: going to send.\n");
+        rc = netlink_unicast(_nl_sk, skb, _pid, MSG_DONTWAIT);
+        if (rc < 0) {
+                printk(KERN_ERR "net_link: can not unicast skb (%d)\n", rc);
+        }
+//        printk("net_link: send to %d is ok.\n",_pid);
+        return 0;
+}
+EXPORT_SYMBOL(rtk_nlsendmsg);
+#endif
 void
 netlink_kernel_release(struct sock *sk)
 {
--- linux-2.6.30.9/net/sched/cls_api.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/sched/cls_api.c	2013-05-02 01:47:59.488226592 +0300
@@ -29,6 +29,11 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 /* The list of all installed classifier types */
 
@@ -136,6 +141,9 @@ static int tc_ctl_tfilter(struct sk_buff
 	unsigned long fh;
 	int err;
 	int tp_created = 0;
+	#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	int	handle;
+	#endif
 
 	if (net != &init_net)
 		return -EINVAL;
@@ -322,6 +330,20 @@ replay:
 			*back = tp;
 			spin_unlock_bh(root_lock);
 		}
+
+		#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		cops->getHandleByKey(t->tcm_handle, &handle, q);
+		switch (n->nlmsg_type) {
+			case RTM_NEWTFILTER:
+				rtl_qosSetPriorityByMark(dev->name, t->tcm_handle, handle, TRUE);
+				break;
+			case RTM_DELTFILTER:
+				rtl_qosSetPriorityByMark(dev->name, t->tcm_handle, handle, FALSE);
+				break;
+			default:
+				break;
+		};
+		#endif
 		tfilter_notify(skb, n, tp, fh, RTM_NEWTFILTER);
 	} else {
 		if (tp_created)
@@ -337,6 +359,58 @@ errout:
 	return err;
 }
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_getHandleByKey(__u32 key, __u32 *handle, struct net_device *d, struct net_device **m)
+{
+	struct Qdisc  *q;
+	struct Qdisc_class_ops *cops;
+	int			i;
+	char			*ifName;
+	struct net_device *dev;
+
+	if (d==NULL)
+	{
+		for(i=0;i<NETIF_NUMBER;i++)
+		{
+			ifName = &netIfNameArray[i][0];
+			if (ifName[0]!=0&&
+				(dev = __dev_get_by_name(&init_net, ifName))!=NULL)
+			{
+				q = netdev_get_tx_queue(dev, 0)->qdisc_sleeping;
+
+				if ((cops = q->ops->cl_ops)==NULL || cops->getHandleByKey==NULL)
+				{
+					continue;
+				}
+				else if (cops->getHandleByKey(key, handle, q)!=0)
+				{
+					continue;
+				}
+				else
+				{
+					*m = dev;
+					return 0;
+				}
+			}
+		}
+	}
+	else
+	{
+		q = netdev_get_tx_queue(d, 0)->qdisc_sleeping;
+		if ((cops = q->ops->cl_ops)==NULL || cops->getHandleByKey==NULL)
+		{
+			return -1;
+		}
+		else
+		{
+			return cops->getHandleByKey(key, handle, q);
+		}
+	}
+
+	return -1;
+}
+#endif
+
 static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,
 			 unsigned long fh, u32 pid, u32 seq, u16 flags, int event)
 {
--- linux-2.6.30.9/net/sched/cls_fw.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/sched/cls_fw.c	2013-05-02 01:47:59.489226592 +0300
@@ -27,6 +27,11 @@
 #include <net/netlink.h>
 #include <net/act_api.h>
 #include <net/pkt_cls.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 #define HTSIZE (PAGE_SIZE/sizeof(struct fw_filter *))
 
@@ -78,6 +83,62 @@ static __inline__ int fw_hash(u32 handle
 		return handle & (HTSIZE - 1);
 }
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+static int fw_classifyMark(__u32 mark, struct tcf_proto *tp,
+			  struct tcf_result *res)
+{
+	struct fw_head *head;
+	struct fw_filter *f;
+	u32 id;
+
+	head = (struct fw_head*)tp->root;
+	
+	if (head != NULL) {
+		id = mark & head->mask;
+		for (f=head->ht[fw_hash(id)]; f; f=f->next) {
+			if (f->id == id) {
+				*res = f->res;
+				return 0;
+			}
+		}
+	} else {
+		/* old method */
+		id = mark;
+		if (id && (TC_H_MAJ(id) == 0 || !(TC_H_MAJ(id^tp->q->handle)))) {
+			res->classid = id;
+			res->class = 0;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int fw_arrange_rules(struct tcf_proto *tp)
+{
+	rtl865x_qos_rule_t	*qosRule;
+	struct tcf_result	res;
+
+	qosRule = rtl865x_qosRuleHead;
+	while(qosRule)
+	{
+		if (fw_classifyMark(qosRule->mark, tp, &res)==0)
+		{
+			qosRule->handle = res.classid;
+		}
+		else if(TC_H_MAJ(qosRule->handle)==TC_H_MAJ(tp->classid))
+			qosRule->handle = 0;
+
+		qosRule = qosRule->next;
+	}
+
+	rtl865x_qosArrangeRuleByNetif();
+	
+	return SUCCESS;
+}
+
+#endif
+
 static int fw_classify(struct sk_buff *skb, struct tcf_proto *tp,
 			  struct tcf_result *res)
 {
@@ -141,6 +202,9 @@ static int fw_init(struct tcf_proto *tp)
 static inline void
 fw_delete_filter(struct tcf_proto *tp, struct fw_filter *f)
 {
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
 	tcf_unbind_filter(tp, &f->res);
 	tcf_exts_destroy(tp, &f->exts);
 	kfree(f);
@@ -228,6 +292,10 @@ fw_change_attrs(struct tcf_proto *tp, st
 
 	tcf_exts_change(tp, &f->exts, &e);
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
+
 	return 0;
 errout:
 	tcf_exts_destroy(tp, &e);
@@ -292,6 +360,11 @@ static int fw_change(struct tcf_proto *t
 	tcf_tree_unlock(tp);
 
 	*arg = (unsigned long)f;
+
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
+
 	return 0;
 
 errout:
@@ -374,6 +447,9 @@ nla_put_failure:
 static struct tcf_proto_ops cls_fw_ops __read_mostly = {
 	.kind		=	"fw",
 	.classify	=	fw_classify,
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	.classifyMark	=	fw_classifyMark,
+#endif
 	.init		=	fw_init,
 	.destroy	=	fw_destroy,
 	.get		=	fw_get,
--- linux-2.6.30.9/net/sched/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/sched/Makefile	2013-05-02 01:47:59.486226592 +0300
@@ -46,3 +46,6 @@ obj-$(CONFIG_NET_EMATCH_NBYTE)	+= em_nby
 obj-$(CONFIG_NET_EMATCH_U32)	+= em_u32.o
 obj-$(CONFIG_NET_EMATCH_META)	+= em_meta.o
 obj-$(CONFIG_NET_EMATCH_TEXT)	+= em_text.o
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+EXTRA_AFLAGS += $(EXTRA_CFLAGS)
--- linux-2.6.30.9/net/sched/sch_api.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/sched/sch_api.c	2013-05-02 01:47:59.492226591 +0300
@@ -33,6 +33,10 @@
 #include <net/sock.h>
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 static int qdisc_notify(struct sk_buff *oskb, struct nlmsghdr *n, u32 clid,
 			struct Qdisc *old, struct Qdisc *new);
@@ -939,6 +943,31 @@ check_loop_fn(struct Qdisc *q, unsigned
 	return 0;
 }
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+/*
+   Patch for hardware
+  */
+
+static int tc_sync_hardware(struct net_device *dev)
+{
+	struct Qdisc_class_ops *cops;
+
+	if (dev==NULL||netdev_get_tx_queue(dev,0)->qdisc_sleeping==NULL
+		||netdev_get_tx_queue(dev,0)->qdisc_sleeping->ops==NULL)
+		return -EINVAL;
+
+	cops = netdev_get_tx_queue(dev,0)->qdisc_sleeping->ops->cl_ops;
+
+	if (cops && cops->syncHwQueue)
+		return cops->syncHwQueue(dev);
+	else
+	{
+		rtl865x_qosFlushBandwidth(dev->name);
+		return rtl865x_closeQos(dev->name);
+	}
+}
+#endif
+
 /*
  * Delete/get qdisc.
  */
@@ -998,6 +1027,10 @@ static int tc_get_qdisc(struct sk_buff *
 			return -ENOENT;
 		if ((err = qdisc_graft(dev, p, skb, n, clid, NULL, q)) != 0)
 			return err;
+
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		tc_sync_hardware(dev);
+#endif
 	} else {
 		qdisc_notify(skb, n, clid, NULL, q);
 	}
@@ -1144,6 +1177,10 @@ graft:
 		return err;
 	}
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	tc_sync_hardware(dev);
+#endif
+
 	return 0;
 }
 
@@ -1624,6 +1661,23 @@ int tc_classify_compat(struct sk_buff *s
 }
 EXPORT_SYMBOL(tc_classify_compat);
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_classifyMark(__u32 mark, struct tcf_proto *tp, struct tcf_result *res)
+{
+	for ( ; tp; tp = tp->next)
+	{
+		if (tp->ops!=NULL && tp->ops->classifyMark!=NULL &&
+			tp->ops->classifyMark(mark, tp, res)==0)
+		{
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+#endif
+
 int tc_classify(struct sk_buff *skb, struct tcf_proto *tp,
 		struct tcf_result *res)
 {
--- linux-2.6.30.9/net/sched/sch_htb.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/net/sched/sch_htb.c	2013-05-02 01:47:59.497226591 +0300
@@ -38,6 +38,16 @@
 #include <linux/workqueue.h>
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+//#include <AsicDriver/rtl865x_asicCom.h>
+//#include <AsicDriver/rtl865x_asicL2.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#if defined(CONFIG_PROC_FS)
+#include <linux/proc_fs.h>
+#endif
+#endif
 
 /* HTB algorithm.
     Author: devik@cdi.cz
@@ -1508,6 +1518,261 @@ static void htb_unbind_filter(struct Qdi
 		cl->filter_cnt--;
 }
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+
+#define	BANDWIDTH_GAP_FOR_PORT		10000
+#if defined(CONFIG_RTL_8196C) ||defined(CONFIG_RTL_819XD)
+#define	FULL_SPEED	100000000
+#elif defined(CONFIG_RTL_8198)
+#define	FULL_SPEED	1000000000
+#else
+#error "Please select the correct chip model."
+#endif
+
+static int htb_syncHwQueue(struct net_device *dev)
+{
+	/*	Qdisc exist	*/
+	struct Qdisc	*q;
+	u32			queueNum;
+	u32			topClassNum;
+	u32			idx;
+	struct htb_class	*cl;
+	struct htb_class	*classHandle[TC_HTB_MAXDEPTH-1];
+	rtl865x_qos_t		queueInfo[RTL8651_OUTPUTQUEUE_SIZE];
+	struct htb_sched 	*defQ;
+	u32				defClassId;
+	u32 tmpBandwidth1, tmpBandwidth2;
+	int				i;
+
+	memset(queueInfo, 0, RTL8651_OUTPUTQUEUE_SIZE*sizeof(rtl865x_qos_t));
+	queueNum = topClassNum = 0;
+
+	defQ = qdisc_priv(netdev_get_tx_queue(dev, 0)->qdisc_sleeping);
+	defClassId = TC_H_MAKE(netdev_get_tx_queue(dev, 0)->qdisc_sleeping->handle, defQ->defcls);
+
+	for (i = 0; i < dev->num_tx_queues; i++)
+	{
+		struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+		struct Qdisc *txq_root = txq->qdisc_sleeping;
+		spin_lock_bh(qdisc_lock(txq_root));
+		list_for_each_entry(q, &txq_root->list, list)
+		{
+			if (q->parent)
+			{
+				cl = htb_find(q->parent, netdev_get_tx_queue(dev, 0)->qdisc_sleeping);
+
+				if (cl==NULL)
+				{
+					spin_unlock_bh(qdisc_lock(txq_root));
+					return -EINVAL;
+				}
+				{
+					queueInfo[queueNum].bandwidth = cl->rate->rate.rate<<3;
+					queueInfo[queueNum].ceil = cl->ceil->rate.rate<<3;
+					queueInfo[queueNum].handle = queueInfo[queueNum].queueId = cl->common.classid;
+					memcpy(queueInfo[queueNum].ifname, 
+						dev->name, sizeof(dev->name));
+									
+					if (cl->common.classid==defClassId)
+						queueInfo[queueNum].flags |= QOS_DEF_QUEUE;
+					else
+						queueInfo[queueNum].flags &= (~QOS_DEF_QUEUE);
+
+					if (queueInfo[queueNum].bandwidth==queueInfo[queueNum].ceil)
+					{
+						/*	Consider ceil==rate as as STR	*/
+						queueInfo[queueNum].flags = (queueInfo[queueNum].flags & (~QOS_TYPE_MASK)) | QOS_TYPE_STR | QOS_VALID_MASK;
+					}
+					else
+					{
+						/*	Otherwise, set all queue as WFQ	*/
+						queueInfo[queueNum].flags = (queueInfo[queueNum].flags & (~QOS_TYPE_MASK)) | QOS_TYPE_WFQ | QOS_VALID_MASK;
+					}
+
+					while(cl && cl->level!=TC_HTB_MAXDEPTH-1)
+					{
+						cl = cl->parent;
+					}
+
+					if (cl&&(cl->level==TC_HTB_MAXDEPTH-1))
+					{
+						int	newRoot;
+						
+						newRoot = 1;
+						for(idx=0;idx<topClassNum;idx++)
+						{
+							if (classHandle[idx]->common.classid==cl->common.classid)
+							{
+								newRoot = 0;
+								break;
+							}
+						}
+
+						if (newRoot)
+						{
+							classHandle[topClassNum] = cl;
+							topClassNum++;
+						}
+					}
+				}
+				queueNum++;
+			}
+		}
+		spin_unlock_bh(qdisc_lock(txq_root));
+	}
+
+	if (topClassNum == 0)
+	{
+		rtl865x_qosFlushBandwidth(dev->name);
+		rtl865x_closeQos(dev->name);
+	}
+	else
+	{
+		int32		i;
+		int32		portBandwidth, tmpPortBandwidth;
+		int32		totalRnum;
+		int32		totalGbandwidth, totalRbandwidth, calcRbandwidth;
+
+		portBandwidth = 0;
+		for(idx=0;idx<topClassNum;idx++)
+		{
+			{
+				portBandwidth += (classHandle[idx]->ceil->rate.rate<<3);
+			}
+		}
+
+		/*	Do port bandwidth adjust here		*/
+		tmpPortBandwidth = portBandwidth + (BANDWIDTH_GAP_FOR_PORT);
+#if 0
+		tmpPortBandwidth = portBandwidth<<3;
+		tmpPortBandwidth += tmpPortBandwidth>>3;
+		tmpPortBandwidth -= tmpPortBandwidth>>5;
+		if (tmpPortBandwidth>0x200000)
+			tmpPortBandwidth = ((tmpPortBandwidth/1000)<<10);
+		else
+			tmpPortBandwidth = ((tmpPortBandwidth<<10)/1000);
+#endif
+
+		/////////////////////////////////////////////////////////////////////////////
+		//Patch for qos: to improve no-match rule throughput especially for low speed(~500kbps)
+		//tmpPortBandwidth+=192000;	//Added 192kbps
+		/////////////////////////////////////////////////////////////////////////////
+
+		rtl865x_qosSetBandwidth(dev->name, tmpPortBandwidth);
+
+		totalGbandwidth = totalRbandwidth = totalRnum = 0;
+
+		/*	Check for G type queue's total bandwidth	*/
+		for(i=0; i<queueNum; i++)
+		{
+			if((queueInfo[i].ceil==portBandwidth)
+				&& queueInfo[i].bandwidth<queueInfo[i].ceil)	/* change bandwidth granulity from bps(bit/sec) to Bps(byte/sec) */
+			{
+				/*totalGbandwidth += ((queueInfo[i].bandwidth<<3)/1000)<<7;*/
+				totalGbandwidth += ((queueInfo[i].bandwidth));
+			}
+			else if (queueInfo[i].ceil<portBandwidth)
+			{
+				/*totalRbandwidth += ((queueInfo[i].ceil<<3)/1000)<<7;*/
+				totalRbandwidth += ((queueInfo[i].ceil));
+				totalRnum++;
+
+				tmpBandwidth1=queueInfo[i].ceil;
+				tmpBandwidth2=(tmpBandwidth1>>13)<<13;
+				if(tmpBandwidth1-tmpBandwidth2>(EGRESS_BANDWIDTH_GRANULARITY>>1))	// 4KByte which is 32kbit
+				{
+					queueInfo[i].bandwidth=queueInfo[i].ceil=((queueInfo[i].ceil>>13)+1)<<13;
+				}
+				else
+				{
+					queueInfo[i].bandwidth=queueInfo[i].ceil=(queueInfo[i].ceil>>13)<<13;
+				}
+				
+				if(queueInfo[i].bandwidth<EGRESS_BANDWIDTH_GRANULARITY)	/* 8K bytes == 64K bits	*/
+					queueInfo[i].bandwidth=queueInfo[i].ceil=EGRESS_BANDWIDTH_GRANULARITY;
+			}
+			/*
+			else
+			{
+				printk("Set output queue error: Queue bandwidth[%d]bps > Port bandwidth[%d]bps\n", 
+					queueInfo[i].ceil, portBandwidth);
+			}
+			*/
+		}
+
+		if ( totalRbandwidth!=0 && ((totalGbandwidth+totalRbandwidth)>portBandwidth))
+		{
+			/*	Should reduce the R type bandwidth	*/
+			calcRbandwidth = portBandwidth - totalGbandwidth;
+
+#if 0
+			for(i=0; i<queueNum; i++)
+			{
+				if (queueInfo[i].bandwidth==queueInfo[i].ceil)
+				{
+					queueInfo[i].ceil = queueInfo[i].bandwidth 
+						= queueInfo[i].bandwidth - (totalRbandwidth-calcRbandwidth)/totalRnum;
+				}
+			}
+#endif
+		}
+
+		for(i=0; i<queueNum; i++)
+		{
+			if (queueInfo[i].bandwidth!=queueInfo[i].ceil)
+			{
+				/*	Do queue bandwidth adjust here		*/
+				queueInfo[i].ceil += queueInfo[i].ceil>>3;
+				if (queueInfo[i].ceil>0x200000)
+					queueInfo[i].ceil = ((queueInfo[i].ceil/1000)<<10);
+				else
+					queueInfo[i].ceil = ((queueInfo[i].ceil<<10)/1000);
+
+				if (queueInfo[i].ceil>FULL_SPEED)
+					queueInfo[i].ceil = FULL_SPEED;
+			}
+			else
+			{
+				/*	str	*/
+				if (queueInfo[i].ceil>1000000)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = (queueInfo[i].ceil/1000000)<<20;
+				else if (queueInfo[i].ceil>1000)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = (queueInfo[i].ceil/1000)<<10;
+
+				if (queueInfo[i].ceil>FULL_SPEED)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = FULL_SPEED;
+			}
+		}
+
+		rtl865x_qosProcessQueue(dev->name, queueInfo);
+	}
+
+	return 0;
+}
+
+static int htb_getClassIDByMark(__u32 mark, __u32 *classID, struct Qdisc *sch)
+{
+	struct htb_sched	*q = qdisc_priv(sch);
+	struct tcf_result	res;
+	struct tcf_proto	*tcf;
+
+	tcf = q->filter_list;
+	if(tcf)
+	{
+		if ((tc_classifyMark(mark, tcf, &res))==SUCCESS)
+		{
+			*classID = res.classid;
+			return SUCCESS;
+		}
+
+		/* we have got inner class; apply inner filter chain */
+	}
+
+	return FAILED;
+}
+
+#endif
+
 static void htb_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
 	struct htb_sched *q = qdisc_priv(sch);
@@ -1547,6 +1812,10 @@ static const struct Qdisc_class_ops htb_
 	.unbind_tcf	=	htb_unbind_filter,
 	.dump		=	htb_dump_class,
 	.dump_stats	=	htb_dump_class_stats,
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	.syncHwQueue =	htb_syncHwQueue,
+	.getHandleByKey	=	htb_getClassIDByMark,
+#endif
 };
 
 static struct Qdisc_ops htb_qdisc_ops __read_mostly = {
